LARAVEL VIEWS CONVERSION
Generated: 2025-10-21 15:25:11
Project: C:\material-connect
================================================================================


------------------------------------------------------------
FILE: Http/Controllers/Admin/MasterProductsController.php
------------------------------------------------------------
<?php

namespace App\Http\Controllers\Admin;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Validator;
use Illuminate\Support\Facades\Storage;
use App\Models\MasterProducts;
use App\Models\SupplierOffers;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Str;

class MasterProductsController extends Controller
{
    /**
     * List all master products.
     */
    public function index(Request $request)
    {
        $perPage = (int) $request->get('per_page', 10);
        $page = (int) $request->get('page', 1);

        $query = MasterProducts::with(['added_by', 'approved_by', 'category']);

        // Apply filters
        if ($request->filled('search')) {
            $search = $request->get('search');
            $query->where('product_name', 'like', "%{$search}%");
        }

        if ($request->filled('category')) {
            $query->where('category', $request->get('category'));
        }

        if ($request->filled('is_approved')) {
            $query->where('is_approved', $request->get('is_approved'));
        }

        // Paginate after filters
        $products = $query->paginate($perPage, ['*'], 'page', $page);

        // Append supplier offers count
        $products->getCollection()->transform(function ($product) {
            $product->supplierOffersCount = SupplierOffers::where('master_product_id', $product->id)->count();
            return $product;
        });

        return response()->json($products, 200);
    }


    /**
     * Show a specific master product.
     */
    public function show($id)
    {
        $product = MasterProducts::with(['added_by', 'approved_by', 'category'])->find($id);
        $product->supplierOffers = SupplierOffers::with('supplier')->where('master_product_id', $product->id)->get();

        if (!$product) {
            return response()->json(['error' => 'Product not found'], 404);
        }

        return response()->json($product, 200);
    }

    /**
     * Create a new master product.
     */
    public function store(Request $request)
    {
        $validator = Validator::make($request->all(), [
            'product_name' => 'required|string|max:255|unique:master_products,product_name',
            'product_type' => 'required|string|max:255',
            'specifications' => 'nullable|string',
            'unit_of_measure' => 'nullable|string|max:100',
            'tech_doc' => 'nullable|file|mimes:pdf,docx,xlsx',
            'photo' => 'nullable|image|mimes:jpeg,png,jpg,gif|max:2048',
            'is_approved' => 'boolean',
            'category' => 'nullable|string|max:255|exists:category,id'
        ]);

        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 400);
        }

        $techDocPath = null;
        if ($request->hasFile('tech_doc') && $request->file('tech_doc')->isValid()) {
            $techDocPath = $request->file('tech_doc')->store('tech_docs', 'public');
        }

        $photoPath = null;
        if ($request->hasFile('photo') && $request->file('photo')->isValid()) {
            $photoPath = $request->file('photo')->store('product_photos', 'public');
        }

        $approverId = null;
        if ($request->is_approved) {
            $approverId = Auth::id();
        }

        $product = MasterProducts::create([
            'product_name' => $request->product_name,
            'product_type' => $request->product_type,
            'specifications' => $request->specifications,
            'unit_of_measure' => $request->unit_of_measure,
            'tech_doc' => $techDocPath,
            'photo' => $photoPath,
            'added_by' => Auth::id(),
            'is_approved' => $request->is_approved ?? false,
            'approved_by' => $approverId,
            'slug' => Str::slug($request->product_name) . '-' . Str::random(6),
            'category' => $request->category,
        ]);

        return response()->json(['message' => 'Product created successfully', 'product' => $product], 201);
    }

    /**
     * Update a master product.
     */
    public function update(Request $request, $id)
    {
        $product = MasterProducts::find($id);

        if (!$product) {
            return response()->json(['error' => 'Product not found'], 404);
        }

        $validator = Validator::make($request->all(), [
            'product_name' => 'sometimes|required|string|max:255',
            'product_type' => 'sometimes|required|string|max:255',
            'specifications' => 'nullable|string',
            'unit_of_measure' => 'nullable|string|max:100',
            'tech_doc' => 'nullable|file|mimes:pdf,docx,xlsx',
            'photo' => 'nullable|image|mimes:jpeg,png,jpg,gif|max:2048',
            'is_approved' => 'boolean',
            'category' => 'nullable|string|max:255|exists:category,id'
        ]);

        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 400);
        }

        if ($request->hasFile('tech_doc') && $request->file('tech_doc')->isValid()) {
            if ($product->tech_doc) {
                Storage::delete('public/' . $product->tech_doc);
            }
            $product->tech_doc = $request->file('tech_doc')->store('tech_docs', 'public');
        }

        if ($request->hasFile('photo') && $request->file('photo')->isValid()) {
            if ($product->photo) {
                Storage::delete('public/' . $product->photo);
            }
            $product->photo = $request->file('photo')->store('product_photos', 'public');
        }

        if ($request->has('is_approved')) {
            if ($request->is_approved && !$product->is_approved) {
                $product->approved_by = Auth::id();
            } elseif (!$request->is_approved) {
                $product->approved_by = null;
            }
            $product->is_approved = $request->is_approved;
        }

        $product->update([
            'product_name' => $request->product_name ?? $product->product_name,
            'product_type' => $request->product_type ?? $product->product_type,
            'specifications' => $request->specifications ?? $product->specifications,
            'unit_of_measure' => $request->unit_of_measure ?? $product->unit_of_measure,
            'slug' => $request->product_name ? Str::slug($request->product_name) . '-' . Str::random(6) : $product->slug,
            'is_approved' => $product->is_approved,
            'approved_by' => $product->approved_by,
            'category' => $request->category ?? $product->category,
            'tech_doc' => $product->tech_doc,
            'photo' => $product->photo,
        ]);

        return response()->json(['message' => 'Product updated successfully', 'product' => $product], 200);
    }

    /**
     * Delete a master product.
     */
    public function destroy($id)
    {
        $product = MasterProducts::find($id);

        if (!$product) {
            return response()->json(['error' => 'Product not found'], 404);
        }

        if ($product->tech_doc) {
            Storage::delete('public/' . $product->tech_doc);
        }

        if ($product->photo) {
            Storage::delete('public/' . $product->photo);
        }

        $product->delete();

        return response()->json(['message' => 'Product deleted successfully'], 200);
    }

    public function approveRejectMasterProduct($id)
    {
        $product = MasterProducts::find($id);

        if (!$product) {
            return response()->json(['error' => 'Product not found'], 404);
        }

        if($product->is_approved) {
            // If already approved, reject it
            $product->is_approved = false;
            $product->approved_by = null;
        } else {
            // If not approved, approve it
            $product->is_approved = true;
            $product->approved_by = Auth::id();
        }
        $product->save();

        return response()->json(['message' => 'Product approval status updated', 'is_approved' => $product->is_approved], 200);
        
    }

    public function approveRejectSupplierOffer(Request $request , $id)
    {
        $offer = SupplierOffers::find($id);

        if (!$offer) {
            return response()->json(['error' => 'Supplier offer not found'], 404);
        }

        $validator = Validator::make($request->all(), [
            'status' => 'required|in:Approved,Rejected,Pending',
        ]);
        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 400);
        }
        $offer->status = $request->status;
        $offer->save();

        return response()->json(['message' => 'Supplier offer approval status updated', 'status' => $offer->status], 200);
        
    }
}


------------------------------------------------------------
FILE: Http/Controllers/Admin/OrderAdminController.php
------------------------------------------------------------
<?php

namespace App\Http\Controllers\Admin;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;
use App\Models\Orders; // Adjust if your model is named Order
use App\Models\Projects;
use App\Models\OrderItems;
use App\Models\SupplierOffers;
use App\Models\User; // assuming clients are users with role=client
use Illuminate\Validation\Rule;
use Illuminate\Support\Facades\Validator;
use Pest\Configuration\Project;

class OrderAdminController extends Controller
{
    //


    public function index(Request $request)
    {
        $perPage = (int) $request->get('per_page', 10);
        $search = trim((string) $request->get('search', ''));
        $clientId = $request->get('client_id');
        $projectId = $request->get('project_id');
        $supplierId= $request->get('supplier_id');
        $workflow = $request->get('workflow');
        $payment = $request->get('payment_status');
        $ddFrom = $request->get('delivery_date_from');
        $ddTo = $request->get('delivery_date_to');
        $method = $request->get('delivery_method');
        $repeat = $request->get('repeat_order') ?? null;
        $hasMissing= $request->get('has_missing_supplier');
        $confirms = $request->has('supplier_confirms') ? (int)$request->get('supplier_confirms') : null; // 0/1
        $minTotal = $request->get('min_total');
        $maxTotal = $request->get('max_total');
        $sort = $request->get('sort', 'created_at');
        $dir = strtolower($request->get('dir', 'desc')) === 'asc' ? 'asc' : 'desc';
        $details = filter_var($request->get('details', false), FILTER_VALIDATE_BOOLEAN);


        // Allowed sort columns
        $sortMap = [
        'po_number' => 'po_number',
        'delivery_date' => 'delivery_date',
        'created_at' => 'created_at',
        'updated_at' => 'updated_at',
        // pricing related (ensure these fields exist in your Orders table)
        'total' => 'total', // alias of customer_cost if you prefer
        'customer_cost' => 'customer_cost',
        'supplier_cost' => 'supplier_cost',
        'admin_margin' => DB::raw('(COALESCE(customer_cost,0) - COALESCE(supplier_cost,0))'),
        'items_count' => DB::raw('items_count'), // will order by appended attribute; fallback to created_at if driver rejects
        ];
        if (!array_key_exists($sort, $sortMap)) {
        $sort = 'created_at';
        }


        // Base query
        $query = Orders::query()
        ->with([
            'client:id,name',
            'project:id,name',
            'items:id,order_id,supplier_id,quantity,supplier_confirms'
        ])
        // derive counts in SQL for efficiency
        ->withCount([
            'items as items_count',
            'items as unassigned_items_count' => function ($q) {
                $q->whereNull('supplier_id');
            },
        ])
        // Optional: expose suppliers_count per order
        ->withCount(['items as suppliers_count' => function ($q) {
            $q->whereNotNull('supplier_id')->select(DB::raw('COUNT(DISTINCT supplier_id)'));
        }]);


        // Text search on PO number
        if ($search !== '') {
            $query->where('po_number', 'like', "%{$search}%");
        }
        if ($clientId) {
            $query->where('client_id', $clientId);
        }
        if ($projectId) {
            $query->where('project_id', $projectId);
        }
        if ($workflow) {
            $query->where('workflow', $workflow);
        }
        if ($payment) {
            $query->where('payment_status', $payment);
        }
        if ($method) {
            $query->where('delivery_method', $method);
        }
        if ($ddFrom) {
            $query->whereDate('delivery_date', '>=', $ddFrom);
        }
        if ($ddTo) {
            $query->whereDate('delivery_date', '<=', $ddTo);
        }

        if (isset($repeat) && $repeat !== '' && $repeat !== null && ($repeat === true || $repeat === false)) {
            $query->where('repeat_order', $repeat ? 1 : 0);
        }
        if ($supplierId) {
            $query->whereHas('items', function ($q) use ($supplierId) {
                $q->where('supplier_id', $supplierId);
            });
        }
        if ($hasMissing) {
            $query->whereHas('items', function ($q) {
                $q->whereNull('supplier_id');
            });
        }
        if (!is_null($confirms)) {
            $query->whereHas('items', function ($q) use ($confirms) {
                $q->where('supplier_confirms', $confirms);
            });
        }
        if ($minTotal !== null) {
            $query->where(function ($q) use ($minTotal) {
                // prefer customer_cost/total
                $q->where('customer_cost', '>=', $minTotal)
                ->orWhere('total', '>=', $minTotal);
            });
        }
        if ($maxTotal !== null) {
            $query->where(function ($q) use ($maxTotal) {
                $q->where('customer_cost', '<=', $maxTotal)
                ->orWhere('total', '<=', $maxTotal);
            });
        }
        // Sorting
        if ($sort === 'admin_margin') {
            $query->orderByRaw('(COALESCE(customer_cost,0) - COALESCE(supplier_cost,0)) ' . $dir);
        } elseif ($sort === 'items_count') {
            $query->orderBy('items_count', $dir);
        } else {
            $query->orderBy($sortMap[$sort], $dir);
        }
        $paginator = $query->paginate($perPage);
        // Transform rows for the list table
        $data = $paginator->getCollection()->map(function (Orders $o) {
        // Compute pricing view values. Adjust field names if different in your schema.
            $customer = $o->customer_cost ?? $o->total ?? 0;
            $supplier = $o->supplier_cost ?? 0;
            $margin = ($o->admin_margin ?? null) !== null
            ? $o->admin_margin
            : ($customer - $supplier);


            // Optional info text similar to client list
            $orderInfo = null;
            if ($o->workflow === 'Supplier Missing' && $o->unassigned_items_count > 0) {
                $orderInfo = 'Supplier missing for ' . $o->unassigned_items_count . ' items';
            } elseif ($o->workflow === 'Supplier Assigned') {
                $orderInfo = 'Waiting for suppliers to confirm';
            } elseif ($o->workflow === 'Payment Requested') {
                $orderInfo = 'Awaiting client payment';
            }


            return [
            'id' => $o->id,
            'po_number' => $o->po_number,
            'client' => optional($o->client)->name,
            'project' => optional($o->project)->name,
            'delivery_date' => $o->delivery_date,
            'delivery_time' => $o->delivery_time,
            'workflow' => $o->workflow,
            'payment_status' => $o->payment_status,
            'items_count' => $o->items_count,
            'unassigned_items_count' => $o->unassigned_items_count,
            'supplier_cost' => round((float)$supplier, 2),
            'customer_cost' => round((float)$customer, 2),
            'admin_margin' => round((float)$margin, 2),
            'order_info' => $orderInfo,
            'created_at' => $o->created_at,
            'updated_at' => $o->updated_at,
            ];
        });
        // Metrics
        $base = Orders::query();
        $metrics = [
        'total_orders_count' => (clone $base)->count(),
        'supplier_missing_count' => (clone $base)->where('workflow', 'Supplier Missing')->count(),
        'supplier_assigned_count'=> (clone $base)->where('workflow', 'Supplier Assigned')->count(),
        'awaiting_payment_count' => (clone $base)->where('workflow', 'Payment Requested')->count(),
        'delivered_count' => (clone $base)->where('workflow', 'Delivered')->count(),
        ];
        $response = [
            'data' => $data,
            'pagination' => [
                'per_page' => $paginator->perPage(),
                'current_page' => $paginator->currentPage(),
                'total_pages' => $paginator->lastPage(),
                'total_items' => $paginator->total(),
                'has_more_pages'=> $paginator->hasMorePages(),
            ],
            'metrics' => $metrics,
        ];
        if ($details) {
            $response['filters'] = [
                'clients' => User::query()->where('role', 'client')->select('id','name','profile_image')->orderBy('name')->get(),
                'suppliers' => User::where('role','supplier')->select('id','name','profile_image')->orderBy('name')->get(),
                'projects' => Projects::query()->select('id','name')->orderBy('name')->get(),
                'workflows' => ['Requested','Supplier Missing','Supplier Assigned','Payment Requested','On Hold','Delivered'],
                'payment_statuses' => ['Pending','Requested','Paid','Partially Paid','Partial Refunded','Refunded'],
                'delivery_methods' => ['Other','Tipper','Agitator','Pump','Ute'],
            ];
        }
        return response()->json($response);
    }


    public function show(Orders $order)
    {
        $order->load(['client:id,name', 'project:id,name', 'items.product:id,product_name']);
     
        $deliveryLat = $order->delivery_lat ?? null;   // adjust if different
        $deliveryLng = $order->delivery_long ?? null;
        
        $filters['projects'] = Projects::where('added_by', $order->client_id)->get();
        

        $payload = [
            'id' => $order->id,
            'po_number' => $order->po_number,
            'client' => optional($order->client)->name,
            'project' => optional($order->project)->name,
            'delivery_address' => $order->delivery_address,
            'delivery_date' => $order->delivery_date,
            'delivery_time' => $order->delivery_time,
            'workflow' => $order->workflow,
            'payment_status' => $order->payment_status,
            'supplier_cost' => round((float)$order->supplier_cost, 2),
            'customer_cost' => round((float)$order->customer_cost, 2),
            'admin_margin' => round((float)$order->admin_margin, 2),
            'gst_tax'=> round((float)$order->gst_tax),
            'subtotal'=>round((float)$order->subtotal),
            'discount'=>round((float)$order->discount),
            'fuel_levy'=>round((float)$order->fuel_levy),
            'other_charges'=>round((float)$order->other_charges),
            'items' => [],
            'filters'=>$filters
        ];

        // If not Supplier Missing, return items without eligibility calc
        if ($order->workflow !== 'Supplier Missing') {
            foreach ($order->items as $it) {
                $payload['items'][] = [
                    'id' => $it->id,
                    'product_id' => $it->product_id,
                    'product_name' => optional($it->product)->product_name,
                    'quantity' => $it->quantity,
                    'supplier_id' => $it->supplier_id,
                    'choosen_offer_id' => $it->choosen_offer_id ?? null,
                    'supplier_confirms' => $it->supplier_confirms,
                    'supplier_unit_cost' => $it->supplier_unit_cost,
                    'supplier_delivery_cost' => $it->supplier_delivery_cost,
                    'supplier_discount' => $it->supplier_discount,
                    'eligible_suppliers' => [],
                ];
            }
            return response()->json(['data' => $payload]);
        }

        $canComputeDistance = is_numeric($deliveryLat) && is_numeric($deliveryLng);

        // preload offers for all products on this order
        $masterIds = $order->items->pluck('product_id')->filter()->unique()->values();

        $offersByProduct = SupplierOffers::query()
            ->whereIn('master_product_id', $masterIds)
            ->with(['supplier:id,name,role,delivery_zones'])
            ->get()
            ->groupBy('master_product_id');
     
        foreach ($order->items as $it) {
            // already assigned → just echo item info
            if (!is_null($it->supplier_id)) {
                $payload['items'][] = [
                    'id' => $it->id,
                    'product_id' => $it->product_id,
                    'product_name' => optional($it->product)->product_name,
                    'quantity' => $it->quantity,
                    'supplier_id' => $it->supplier_id,
                    'choosen_offer_id' => $it->choosen_offer_id ?? null,
                    'supplier_confirms' => $it->supplier_confirms,
                    'supplier_unit_cost' => $it->supplier_unit_cost,
                    'supplier_delivery_cost' => $it->supplier_delivery_cost,
                    'supplier_discount' => $it->supplier_discount,
                    'eligible_suppliers' => [],
                ];
                continue;
            }

            // unassigned → build eligible_suppliers
            $eligible = [];
            $productOffers = $offersByProduct->get($it->product_id, collect());

            foreach ($productOffers as $offer) {
                $supplier = $offer->supplier; // users table row
                if (!$supplier) continue;
                if (strtolower((string)$supplier->role) !== 'supplier') continue;

                if (empty($supplier->delivery_zones)) continue; // must not be null/empty
                $zones = is_array($supplier->delivery_zones)
                    ? $supplier->delivery_zones
                    : $this->decodeZones($supplier->delivery_zones);
                if (empty($zones)) continue;

                $distance = null;
                // dd($canComputeDistance);
                // $canComputeDistance = true;
                if ($canComputeDistance) {
                    // dd($zones, $deliveryLat, $deliveryLng);
                    $distance = $this->nearestZoneDistanceKm($zones, (float)$deliveryLat, (float)$deliveryLng);
                }

                $eligible[] = [
                    'supplier_id' => (int) $supplier->id,
                    'offer_id'    => (int) $offer->id,
                    'distance'    => is_null($distance) ? null : round($distance, 3),
                ];
            }

            usort($eligible, function ($a, $b) {
                if ($a['distance'] === null && $b['distance'] === null) return 0;
                if ($a['distance'] === null) return 1;
                if ($b['distance'] === null) return -1;
                return $a['distance'] <=> $b['distance'];
            });

            $payload['items'][] = [
                'id' => $it->id,
                'product_id' => $it->product_id,
                'product_name' => optional($it->product)->product_name,
                'quantity' => $it->quantity,
                'supplier_id' => $it->supplier_id,
                'eligible_suppliers' => $eligible,
            ];
        }

        return response()->json(['data' => $payload]);
    }

    public function adminUpdate(Request $request, Orders $order)
    {
        // only admins hit this via middleware
        $v = Validator::make($request->all(), [
            'project_id'      => ['sometimes','required','exists:projects,id'],
            'delivery_date'   => ['sometimes','required','date'],
            'delivery_method' => ['sometimes','required', Rule::in(Orders::DELIVERY_METHOD)],
            // "special instruction" lives on order as special_notes
            'special_notes'   => ['sometimes','nullable','string','max:1000'],
            'discount'        => ['sometimes','required','numeric','min:0'],
        ]);

        if ($v->fails()) {
            return response()->json(['error' => $v->errors()], 422);
        }

        $dirty = [];

        if ($request->has('project_id')) {
            $dirty['project_id'] = (int)$request->project_id;
        }
        if ($request->has('delivery_date')) {
            $dirty['delivery_date'] = $request->delivery_date;
        }
        if ($request->has('delivery_method')) {
            $dirty['delivery_method'] = $request->delivery_method;
        }
        if ($request->has('special_notes')) {
            $dirty['special_notes'] = $request->special_notes;
        }
        if ($request->has('discount')) {
            $dirty['discount'] = (float)$request->discount;

            // Recompute total with the new discount using existing breakdown
            $subtotal     = (float)$order->subtotal;
            $gst          = (float)$order->gst_tax;
            $fuelLevy     = (float)$order->fuel_levy;
            $otherCharges = (float)$order->other_charges;
            $dirty['total_price'] = $subtotal + $gst + $fuelLevy + $otherCharges - $dirty['discount'];
            // leave supplier_cost/admin_margin unchanged
        }

        // Apply updates
        $order->update($dirty);

        // If delivery_date changed, align supplier delivery dates on items
        if (array_key_exists('delivery_date', $dirty)) {
            $order->items()->update(['supplier_delivery_date' => $order->delivery_date]);
        }

        // Refresh minimal payload
        $order->load(['project:id,name','items:id,order_id,product_id,supplier_id,supplier_delivery_date']);

        return response()->json([
            'success' => true,
            'message' => 'Order updated by admin',
            'order'   => $order,
        ]);
    }


    /** Decode users.delivery_zones JSON to [['lat'=>..,'lng'=>..,'radius_km'=>?...],...] */
    private function decodeZones($json): array
    {
        try {
            $raw = is_array($json) ? $json : json_decode($json, true, 512, JSON_THROW_ON_ERROR);
        } catch (\Throwable $e) {
            return [];
        }
        $zones = [];
        foreach ((array)$raw as $z) {
            $lat = $z['lat'] ?? $z['latitude'] ?? null;
            $lng = $z['lng'] ?? $z['longitude'] ?? null;
            $rkm = $z['radius_km'] ?? $z['radius'] ?? null;
            if (is_numeric($lat) && is_numeric($lng)) {
                $zones[] = ['lat'=>(float)$lat,'lng'=>(float)$lng,'radius_km'=>is_numeric($rkm)?(float)$rkm:null];
            }
        }
        return $zones;
    }

    /** Nearest zone’s center distance in km */
    private function nearestZoneDistanceKm(array $zones, float $lat, float $lng): ?float
    {
        // dd($zones, $lat , $lng);
        $min = null;
        foreach ($zones as $z) {
            $d = $this->haversineKm($lat, $lng, $z['lat'], $z['long']);
            if ($min === null || $d < $min) $min = $d;
        }
        return $min;
    }

    /** Haversine distance in km */
    private function haversineKm(float $lat1, float $lon1, float $lat2, float $lon2): float
    {
        $R = 6371;
        $dLat = deg2rad($lat2 - $lat1);
        $dLon = deg2rad($lon2 - $lon1);
        $a = sin($dLat/2)**2 + cos(deg2rad($lat1))*cos(deg2rad($lat2))*sin($dLon/2)**2;
        return 2 * $R * atan2(sqrt($a), sqrt(1 - $a));
    }
}


------------------------------------------------------------
FILE: Http/Controllers/AdminController.php
------------------------------------------------------------
<?php
//To be deleted
namespace App\Http\Controllers;

use App\Models\User;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;



class AdminController extends Controller
{
    public function clients()
    {
        // dd('here');
        $clients = User::where('role', 'client')->get();
        $totalClients = $clients->count();
        $activeClients = $clients->where('status', 'Active')->count();
        $inactiveClients = $clients->where('status', 'In-Active')->count();
        $joinedThisMonth = $clients->where('created_at', '>=', now()->startOfMonth())->count();
        return view('clients.index', compact('clients','totalClients','activeClients','inactiveClients','joinedThisMonth'));
    }

    public function addClient(Request $request)
    {
        $data = $request->validate([
            'name'           => 'required|string|max:120',
            'email'          => 'required|email|max:120|unique:users,email',
            'password'       => 'required|string|min:8|confirmed',
            'company_name'   => 'nullable|string|max:120',
            'contact_name'   => 'nullable|string|max:100',
            'contact_number' => 'nullable|string|max:20',
            'shipping_address' => 'nullable|string|max:255',
            'delivery_address' => 'nullable|string|max:255',
        ]);


        $user = User::create([
            'name'           => $data['name'],
            'email'          => $data['email'],
            'password'       => Hash::make($data['password']),   // <-- hashed here
            'role'           => 'client',
            'company_name'   => $data['company_name'] ?? null,
            'contact_name'   => $data['contact_name'] ?? null,
            'contact_number' => $data['contact_number'] ?? null,
            'shipping_address' => $data['shipping_address'] ?? null,
            'delivery_address' => $data['delivery_address'] ?? null,
            'status'         => 'Active', // Default status
        ]);


        return redirect()->route('clients')->with('success', 'Client added successfully');
    }


    
}


------------------------------------------------------------
FILE: Http/Controllers/ApiAuthController.php
------------------------------------------------------------
<?php
namespace App\Http\Controllers;

use App\Models\User;
use App\Models\Company;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Str;
use Illuminate\Support\Facades\Validator;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Storage;
use Laravel\Sanctum\HasApiTokens;

class ApiAuthController extends Controller
{
    // Register Client
    public function registerClient(Request $request)
    {
        $validator = Validator::make($request->all(), [
            'name' => 'required|string|max:255',
            'email' => 'required|email|unique:users,email',
            'password' => 'required|string|min:6',
            'contact_name' => 'required|string|max:255',
            'contact_number' => 'required|string|max:255',
            'shipping_address' => 'required|string|max:255',
            'billing_address' => 'required|string|max:255',
            'profile_image' => 'nullable|image|max:2048', // Optional profile image
            'company_name' => 'nullable|string|max:255',
            'lat' => 'nullable|numeric',
            'long' => 'nullable|numeric',
        ]);

        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 400);
        }

        $imageUrl = null;
        // Handle profile image
        if ($request->hasFile('profile_image') && $request->file('profile_image')->isValid()) {
            // Store the file under 'profile_images' directory in the 'public' disk
            $path = $request->file('profile_image')->store('profile_images', 'public');
            $imageUrl = 'storage/' . $path; // Relative path to the image
        } 

        // Check if company exists, or create new
        $company = Company::firstOrCreate([
            'name' => Str::lower($request->company_name),
        ]);

        // Generate unique client ID
        do {
            $clientPublicId = 'MC-' . rand(100, 999);
        } while (User::where('client_public_id', $clientPublicId)->exists());

        // Register client
        $user = User::create([
            'name' => $request->name,
            'email' => $request->email,
            'password' => Hash::make($request->password),
            'role' => 'client',
            'company_id' => $company->id,
            'contact_name' => $request->contact_name,
            'contact_number' => $request->contact_number,
            'shipping_address' => $request->shipping_address,
            'billing_address' => $request->billing_address,
            'client_public_id' => $clientPublicId,
            'isDeleted' => false,
            'profile_image' => $imageUrl, // Store the relative path
            'lat' => $request->lat,
            'long' => $request->long,
        ]);

        // Create Sanctum Token for the user
        $token = $user->createToken('ClientApp')->plainTextToken;


        return response()->json([
            'message' => 'Client registered successfully.',
            'token' => $token,
            'user' => $user,
            'role' => $user->role,
            'profile_image_url' => $imageUrl, // Return the image URL in response
        ], 201);
    }


    // Register Supplier
    public function registerSupplier(Request $request)
    {
        $validator = Validator::make($request->all(), [
            'name' => 'required|string|max:255',
            'email' => 'required|email|unique:users,email',
            'password' => 'required|string|min:6',
            'contact_name' => 'required|string|max:255',
            'contact_number' => 'required|string|max:255',
            'location' => 'nullable|string|max:255',
            'company_name' => 'required|string|max:255',
            'profile_image' => 'nullable|image|max:2048', // Optional profile image
        ]);

        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 400);
        }

        // Check if company exists, or create new
        $company = Company::firstOrCreate([
            'name' => Str::lower($request->company_name), // Assuming the company name is based on contact name
        ]);

        $imageUrl = null;
        // Handle profile image
        if ($request->hasFile('profile_image') && $request->file('profile_image')->isValid()) {
            // Store the file under 'profile_images' directory in the 'public' disk
            $path = $request->file('profile_image')->store('profile_images', 'public');
            $imageUrl = 'storage/' . $path; // Relative path to the image
        }

        // Register supplier (auto-role assignment)
        $user = User::create([
            'name' => $request->name,
            'email' => $request->email,
            'password' => Hash::make($request->password),
            'role' => 'supplier', // Set role as supplier for registration
            'company_id' => $company->id,
            'contact_name' => $request->contact_name,
            'contact_number' => $request->contact_number,
            'location' => $request->location,
            'isDeleted' => false,
            'profile_image' => $imageUrl,
        ]);

        // Create Sanctum Token for the user
        $token = $user->createToken('SupplierApp')->plainTextToken;

        return response()->json([
            'message' => 'Supplier registered successfully.',
            'token' => $token,
            'user' => $user,
            'role' => $user->role,
            'profile_image_url' => $imageUrl, // Return the image URL in response
        ], 201);
    }
    
    // Login Function
    public function login(Request $request)
    {
        $validator = Validator::make($request->all(), [
            'email' => 'required|email',
            'password' => 'required|string|min:6',
        ]);

        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 400);
        }

        if (!User::where('email', $request->email)->exists()) {
            return response()->json(['error' => 'Email not registered.'], 404);
        }

        // Check credentials
        if (Auth::attempt(['email' => $request->email, 'password' => $request->password])) {
            $user = Auth::user();

            // Create a new token for the user
            $token = $user->createToken('UserApp')->plainTextToken;

            return response()->json([
                'message' => 'Login successful.',
                'token' => $token,
                'user' => $user,
                'role' => $user->role,
            ], 200);
        }

        return response()->json(['error' => 'Password is wrong'], 401);
    }


    public function checkAuth(Request $request)
    {
        // Check if the user is authenticated using Sanctum or session authentication
        if (Auth::check()) {
            // The user is authenticated
            $user = Auth::user()->load('company'); // Get the authenticated user
            if($user->role === 'supplier' && $user->delivery_zones && $user->delivery_zones !== 'null' && $user->delivery_zones !== null ) {
                $user->delivery_zones = json_decode($user->delivery_zones, true);
            }
    
            // Return the user details along with the role
            return response()->json([
                'message' => 'User is authenticated',
                'user' => $user,
                'role' => $user->role,
            ], 200); // 200 OK status code
        } else {
            // The user is not authenticated
            return response()->json([
                'message' => 'User is not authenticated',
            ], 401); // Unauthorized status code
        }
    }


    public function logout(Request $request)
    {
        $user = Auth::user();
        if ($request->boolean('all')) {
            $user->tokens()->delete();                 // revoke all tokens
        } else {
            $user->currentAccessToken()?->delete();    // revoke current token
        }
        return response()->json(['message' => 'Logged out'], 200);
    }

    /**
     * Update profile (no password). Handles client and supplier fields.
     * Accepts:
     *  - Common: name, email, contact_name, contact_number, profile_image
     *  - Client: shipping_address, billing_address, lat, long, company_name
     *  - Supplier: location, delivery_radius, company_name
     */
    public function updateProfile(Request $request)
    {
        $user = Auth::user();

        $validator = Validator::make($request->all(), [
            'name'            => 'sometimes|string|max:255',
            'email'           => 'sometimes|email|unique:users,email,' . $user->id,
            'contact_name'    => 'sometimes|nullable|string|max:255',
            'contact_number'  => 'sometimes|nullable|string|max:255',
            'profile_image'   => 'sometimes|file|image|max:4096',

            // client fields
            'shipping_address'=> 'sometimes|nullable|string|max:255',
            'billing_address' => 'sometimes|nullable|string|max:255',
            'lat'             => 'sometimes|nullable|numeric',
            'long'            => 'sometimes|nullable|numeric',

            // supplier fields
            'location'        => 'sometimes|nullable|string|max:255',
            'delivery_radius' => 'sometimes|nullable|numeric',

            // both roles may set or change company
            'company_name'    => 'sometimes|nullable|string|max:255',
        ]);

        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 422);
        }

        // company
        $companyId = $user->company_id;
        if ($request->filled('company_name')) {
            $company = Company::firstOrCreate(['name' => Str::lower($request->company_name)]);
            $companyId = $company->id;
        }

        // profile image
        $profileImagePath = $user->profile_image;
        if ($request->hasFile('profile_image') && $request->file('profile_image')->isValid()) {
            if ($profileImagePath) {
                $old = str_replace('storage/', '', $profileImagePath);
                Storage::disk('public')->delete($old);
            }
            $stored = $request->file('profile_image')->store('profile_images', 'public');
            $profileImagePath = 'storage/' . $stored;
        }

        // payload
        $data = [
            'name'            => $request->input('name', $user->name),
            'email'           => $request->input('email', $user->email),
            'contact_name'    => $request->input('contact_name', $user->contact_name),
            'contact_number'  => $request->input('contact_number', $user->contact_number),
            'profile_image'   => $profileImagePath,
            'company_id'      => $companyId,
        ];

        if ($user->role === 'client') {
            $data += [
                'shipping_address'=> $request->input('shipping_address', $user->shipping_address),
                'billing_address' => $request->input('billing_address', $user->billing_address),
                'lat'             => $request->input('lat', $user->lat),
                'long'            => $request->input('long', $user->long),
            ];
        }

        if ($user->role === 'supplier') {
            $data += [
                'location'        => $request->input('location', $user->location),
                'delivery_radius' => $request->input('delivery_radius', $user->delivery_radius),
            ];
        }

        $user->update($data);

        return response()->json([
            'message' => 'Profile updated',
            'user'    => $user->fresh((['company'])),
        ], 200);
    }

    /**
     * Change password.
     * Required: current_password, new_password, new_password_confirmation
     */
    public function changePassword(Request $request)
    {
        $validator = Validator::make($request->all(), [
            'current_password'        => 'required|string',
            'new_password'            => 'required|string|min:6|confirmed',
            // field name must be new_password_confirmation
        ], [
            'new_password.confirmed' => 'New password confirmation does not match.',
        ]);

        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 422);
        }

        $user = Auth::user();

        if (!Hash::check($request->current_password, $user->password)) {
            return response()->json(['error' => ['current_password' => ['Current password is incorrect.']]], 400);
        }

        $user->password = Hash::make($request->new_password);
        $user->save();

        // Optional: rotate token on password change
        $request->user()->tokens()->delete();
        $newToken = $user->createToken('UserApp')->plainTextToken;

        return response()->json([
            'message' => 'Password updated',
            'token'   => $newToken,
        ], 200);
    }
}


------------------------------------------------------------
FILE: Http/Controllers/AuthController.php
------------------------------------------------------------
<?php
//To be deleted
namespace App\Http\Controllers;

use App\Models\User;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Facades\Log;

class AuthController extends Controller
{
    public function registerAdmin(Request $request)
    {
        
        $data = $request->validate([
            'name'     => 'required|string|max:120',
            'email'    => 'required|email|max:120|unique:users,email',
            'password' => 'required|string|min:8|confirmed',
        ]);

        $user = User::create([
            'name'     => $data['name'],
            'email'    => $data['email'],
            'password' => Hash::make($data['password']),   // <-- hashed here
            'role'     => 'admin',
        ]);

        Auth::login($user);

        return response()->json(['message' => 'Admin registered successfully'], 201);

        // return redirect()->route('dashboard')->with('success', 'Admin registered successfully');
    }


    // Register (client only)
    public function register(Request $request)
    {
        $data = $request->validate([
            'name'           => 'required|string|max:120',
            'email'          => 'required|email|max:120|unique:users,email',
            'password'       => 'required|string|min:8|confirmed',
            'company_name'   => 'nullable|string|max:120',
            'contact_name'   => 'nullable|string|max:100',
            'contact_number' => 'nullable|string|max:20',
            'shipping_address' => 'nullable|string|max:255',
            'delivery_address' => 'nullable|string|max:255',
        ]);
        // dd($data);

        $user = User::create([
            'name'           => $data['name'],
            'email'          => $data['email'],
            'password'       => Hash::make($data['password']),   // <-- hashed here
            'role'           => 'client',
            'company_name'   => $data['company_name'] ?? null,
            'contact_name'   => $data['contact_name'] ?? null,
            'contact_number' => $data['contact_number'] ?? null,
            'shipping_address' => $data['shipping_address'] ?? null,
            'delivery_address' => $data['delivery_address'] ?? null,
            'status'         => 'Active', // Default status
        ]);

        Auth::login($user);
        // dd($user);
        return redirect()->route('dashboard')->with('success', 'Registered successfully');
    }

    // Login
  public function login(Request $request){
        $credentials = $request->validate([
            'email' => 'required|email',
            'password' => 'required',
        ]);

        if (Auth::attempt($credentials)) {
            $request->session()->regenerate();
            

            
            return redirect()->intended('/dashboard');
        }

        return back()->withErrors([
            'email' => 'Invalid credentials.',
        ]);
    }


    // Logout
    public function logout(Request $request)
    {
        Auth::logout();
        $request->session()->invalidate();
        $request->session()->regenerateToken();
        return redirect('/');
    }

    //dashboard
    public function dashboard()
    {
        
        return view('dashboard');
    }
}


------------------------------------------------------------
FILE: Http/Controllers/Controller.php
------------------------------------------------------------
<?php

namespace App\Http\Controllers;

abstract class Controller
{
    //
}


------------------------------------------------------------
FILE: Http/Controllers/OrderController.php
------------------------------------------------------------
<?php

namespace App\Http\Controllers;

use App\Models\Orders;
use App\Models\MasterProducts;
use App\Models\SupplierOffers;
use App\Models\OrderItem;
use App\Models\Projects;
use Illuminate\Support\Facades\DB;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Validator;

class OrderController extends Controller
{
    /**
     * Create a new order with multiple products.
     */
    public function createOrder(Request $request)
    {
        $v = Validator::make($request->all(), [
            'po_number'        => 'nullable|unique:orders,po_number|string|max:50',
            'project_id'       => 'required|exists:projects,id',
            'delivery_address' => 'required|string',
            'delivery_lat'     => 'required|numeric',
            'delivery_long'    => 'required|numeric',
            'delivery_date'    => 'required|date',
            'delivery_time'    => 'nullable|date_format:H:i',
            'delivery_method'  => 'required|in:Other,Tipper,Agitator,Pump,Ute',
            'load_size'        => 'nullable|string|max:50',
            'special_equipment'=> 'nullable|string|max:255',
            'items'            => 'required|array|min:1',
            'items.*.product_id'       => 'required|exists:master_products,id',
            'items.*.quantity'         => 'required|numeric|min:0.01',
            'items.*.custom_blend_mix' => 'nullable|string',
            'repeat_order'     => 'nullable|boolean',
            'special_notes'    => 'nullable|string|max:1000',
        ]);

        if ($v->fails()) {
            return response()->json(['error' => $v->errors()], 422);
        }

        $user = Auth::user();

        return DB::transaction(function () use ($request, $user) {
            // 1) Create order
            /** @var Orders $order */
            $order = Orders::create([
                'po_number'        => $request->po_number,
                'client_id'        => $user->id,
                'project_id'       => $request->project_id,
                'delivery_address' => $request->delivery_address,
                'delivery_lat'     => $request->delivery_lat,
                'delivery_long'    => $request->delivery_long,
                'delivery_date'    => $request->delivery_date,
                'delivery_time'    => $request->delivery_time,
                'delivery_method'  => $request->delivery_method,
                'load_size'        => $request->load_size,
                'special_equipment'=> $request->special_equipment,
                // monetary fields start at zero; you’ll roll them up later
                'subtotal'         => 0,
                'fuel_levy'        => 0,
                'other_charges'    => 0,
                'gst_tax'          => 0,
                'discount'         => 0,
                'total_price'      => 0,
                'supplier_cost'    => 0,
                'customer_cost'    => 0,
                // initial states per spec
                'payment_status'   => 'Pending',
                'order_status'     => 'In-Progress',
                'order_process'    => 'Automated',
                'generate_invoice' => 0,
                'repeat_order'     => $request->repeat_order ? $request->repeat_order : 0,
                'special_notes'    => $request->special_notes ?? null,
                // add 'workflow' column in your table if not present yet
            ]);

            $lat = (float) $order->delivery_lat;
            $lng = (float) $order->delivery_long;

            // 2) Preload candidate offers for all requested product_ids
            $productIds = collect($request->items)->pluck('product_id')->unique()->values();
            // dd($productIds);
            $offers = SupplierOffers::with(['supplier:id,delivery_zones'])
                ->whereIn('master_product_id', $productIds)   // adjust column name if different
                ->where('status', 'Approved')                     // only approved offers
                ->whereIn('availability_status', ['In Stock', 'Limited'])                       // optional filter if you have it
                ->get()
                ->groupBy('master_product_id');
            $anyMissingSupplier = false;
            // dd($offers);
            // 3) Create items with nearest in-zone supplier if available
            foreach ($request->items as $row) {
                $pid   = (int) $row['product_id'];
                $qty   = (float) $row['quantity'];
                $blend = $row['custom_blend_mix'] ?? null;

                [$chosenOffer, $distanceKm] = $this->pickNearestOfferInZone(
                    $offers->get($pid) ?? collect(), $lat, $lng
                );

                if ($chosenOffer) {
                    $order->items()->create([
                        'product_id'             => $pid,
                        'quantity'               => $qty,
                        'supplier_id'            => $chosenOffer->supplier_id,
                        'custom_blend_mix'       => $blend,
                        'supplier_unit_cost'     => (float) ($chosenOffer->unit_cost ?? $chosenOffer->price ?? 0),
                        'supplier_delivery_cost' => (float) ($chosenOffer->delivery_cost ?? 0),
                        'supplier_delivery_date' => $order->delivery_date,
                        'choosen_offer_id'      => $chosenOffer->id,
                        'supplier_confirms'      => 0,
                    ]);
                } else {
                    $anyMissingSupplier = true;

                    $order->items()->create([
                        'product_id'             => $pid,
                        'quantity'               => $qty,
                        'supplier_id'            => null,
                        'custom_blend_mix'       => $blend,
                        'supplier_unit_cost'     => 0,
                        'supplier_delivery_cost' => 0,
                        'supplier_delivery_date' => $order->delivery_date,
                        'supplier_confirms'      => 0,
                    ]);
                }
            }

            // 4) Update workflow + order_process if any item unassigned
            if ($anyMissingSupplier) {
                $order->workflow      = 'Supplier Missing';
                $order->order_process = 'Action Required';
                $order->save();
            } else {
                // all items assigned to a supplier
                $order->workflow      = 'Supplier Assigned';
                $order->order_process = 'Automated';
                $order->save();
                // $this->workflow($order);
            }

            // Optionally eager-load for response
            $order->load(['items.product','items.supplier']);

            return response()->json([
                'message' => 'Order created',
                'order'   => $order
            ], 201);
        });
    }

    // Helper function | Workflow 
    private function workflow(Orders $order)
    {
        $currentWorkflow = $order->workflow;

        switch ($currentWorkflow) {
            case 'Supplier Assigned':
                $allConfirmed = $order->items()->where('supplier_confirms', false)->count() === 0;
                if ($allConfirmed) {
                    // Calculate pricing
                    $subtotal = 0;
                    $supplierCost = 0;
                    $adminMarginPercentage = 0.50; // 50% admin margin
                    $deliveryCost = 0;
                    $fuelLevy = 0;
                    $itemCostWithMargin= 0;
                    $adminMarginAmount = 0;
                    
                    foreach ($order->items as $item) {
                        // Calculate item cost excluding delivery
                        $itemCost = ($item->supplier_unit_cost * $item->quantity) - $item->supplier_discount;
                        
                        // Add admin margin to item cost (50% on top of item cost)
                        $itemCostWithMargin = $itemCost + ($itemCost * $adminMarginPercentage);
                        
                        $subtotal += $itemCostWithMargin;
                        $supplierCost += $itemCost; // Supplier cost without admin margin
                        $deliveryCost += $item->supplier_delivery_cost;
                    }
                   
                    
                    // Calculate fuel levy (10% on delivery cost as per your example)
                    $fuelLevy = $deliveryCost + ($deliveryCost * 0.10);
                    //  dd($subtotal,$fuelLevy);
                    
                    // Calculate GST (10% on subtotal)
                    $gstTax = $subtotal * 0.10;
                    
                    // Calculate total price
                    $totalPrice = $subtotal + $gstTax + $fuelLevy - $order->discount + $order->other_charges;
                    
                    // Calculate actual admin margin amount (for tracking)
                    $adminMarginAmount = $subtotal * $adminMarginPercentage;

                    // Update order pricing fields
                    $order->subtotal = $subtotal;
                    $order->fuel_levy = $fuelLevy;
                    $order->gst_tax = $gstTax;
                    $order->total_price = $totalPrice;
                    $order->supplier_cost = $supplierCost + $deliveryCost; // Total supplier cost including delivery
                    $order->customer_cost = $totalPrice;
                    $order->admin_margin = $adminMarginAmount; // The actual margin amount
                    $order->workflow = 'Payment Requested';
                    $order->save();
                }
                break;
        }
    }


    /**
     * Pick nearest offer whose supplier has a delivery zone covering the point.
     * Zones format expected on users.delivery_zones: JSON array of
     * [{ "lat": <float>, "long": <float>, "radius": <km as number>, "address": "..." }, ...]
     * Returns [SupplierOffers|null, float distanceKm]
     */
    private function pickNearestOfferInZone($offersForProduct, float $lat, float $lng): array
    {
        // dd( $offersForProduct, $lat, $lng);
        $bestOffer = null;
        $bestDist  = PHP_FLOAT_MAX;

        foreach ($offersForProduct as $offer) {
            $supplier = $offer->supplier;
            if (!$supplier || empty($supplier->delivery_zones)) {
                continue;
            }

            $zones = is_string($supplier->delivery_zones)
                ? json_decode($supplier->delivery_zones, true)
                : $supplier->delivery_zones;
            // dd($zones);

            if (!is_array($zones)) {
                continue;
            }

            foreach ($zones as $z) {
                if (!isset($z['lat'], $z['long'], $z['radius'])) {
                    continue;
                }
                $distKm = $this->haversineKm($lat, $lng, (float)$z['lat'], (float)$z['long']);
                
                if ($distKm <= (float)$z['radius']) {
                    // dd($distKm, $bestDist);
                    // inside this zone
                    if ($distKm < $bestDist) {
                        $bestDist  = $distKm;
                        $bestOffer = $offer;
                    }
                }
            }
        }

        return [$bestOffer, $bestOffer ? $bestDist : INF];
    }

    private function haversineKm(float $lat1, float $lon1, float $lat2, float $lon2): float
    {
        $R = 6371.0088; // mean Earth radius in km
        $dLat = deg2rad($lat2 - $lat1);
        $dLon = deg2rad($lon2 - $lon1);
        $a = sin($dLat/2) * sin($dLat/2)
           + cos(deg2rad($lat1)) * cos(deg2rad($lat2))
           * sin($dLon/2) * sin($dLon/2);
        $c = 2 * atan2(sqrt($a), sqrt(1-$a));
        return $R * $c;
    }


    public function getClientProducts(Request $request)
    {
        // $user    = Auth::user();
        $perPage = (int) $request->integer('per_page', 10);
        $page    = (int) $request->integer('page', 1);

        // aggregate approved, available offers per product (scoped to this client's suppliers)
        $offersAgg = SupplierOffers::query()
            ->select('supplier_offers.master_product_id')
            ->selectRaw('MIN(supplier_offers.price) AS price_min')
            ->selectRaw('MAX(supplier_offers.price) AS price_max')
            ->join('users as suppliers', 'suppliers.id', '=', 'supplier_offers.supplier_id')
            // ->where('suppliers.client_id', $user->id)
            ->where('supplier_offers.status', 'Approved')
            ->whereIn('supplier_offers.availability_status', ['In Stock', 'Limited'])
            ->groupBy('supplier_offers.master_product_id');

        $query = MasterProducts::query()
            ->joinSub($offersAgg, 'oa', function ($join) {
                $join->on('oa.master_product_id', '=', 'master_products.id');
            })
            ->select('master_products.*', 'oa.price_min', 'oa.price_max');

        // search by product_name
        if ($search = trim((string) $request->get('search'))) {
            $query->where('master_products.product_name', 'like', "%{$search}%");
        }

        // filter by category_id
        if ($request->filled('category')) {
            $query->where('master_products.category', $request->get('category'));
        }

        // sort
        if ($request->get('sort') === 'price') {
            $query->orderBy('oa.price_min', 'asc');
        } else {
            $query->orderBy('master_products.product_name', 'asc');
        }

        $products = $query->with('category')->paginate($perPage, ['*'], 'page', $page);

        $products->getCollection()->transform(function ($p) {
            $p->price = ($p->price_min == $p->price_max)
                ? sprintf('$%.2f', $p->price_min)
                : sprintf('$%.2f - $%.2f', $p->price_min, $p->price_max);
            return $p;
        });

        return response()->json([
            'data' => $products->items(),
            'meta' => [
                'current_page' => $products->currentPage(),
                'per_page'     => $products->perPage(),
                'total'        => $products->total(),
                'last_page'    => $products->lastPage(),
            ],
        ]);
    }

    public function getClientProductDetails($id)
    {
        // dd($id);
        // $user = Auth::user();

        $product = MasterProducts::with('category')->find($id);
        if (!$product) {
            return response()->json(['error' => 'Product not found'], 404);
        }

        // fetch approved, available offers for this product (scoped to this client's suppliers)
        $offers = SupplierOffers::with(['supplier:id,company_name,delivery_zones'])
            ->where('master_product_id', $product->id)
            // ->whereHas('supplier', function ($q) use ($user) {
            //     $q->where('client_id', $user->id);
            // })
            ->where('status', 'Approved')
            ->whereIn('availability_status', ['In Stock', 'Limited'])
            ->orderBy('price', 'asc')
            ->get();

        return response()->json($product);
    }

    //Get my orders
    public function getMyOrders(Request $request)
    {
        $user = Auth::user();

        $details = filter_var($request->get('details', false), FILTER_VALIDATE_BOOLEAN);

        $perPage = (int) $request->get('per_page', 10);
        $search  = trim((string) $request->get('search', ''));
        $sort    = $request->get('sort', 'created_at');
        $dir     = strtolower($request->get('dir', 'desc')) === 'asc' ? 'asc' : 'desc';
        $delivery_date = $request->get('delivery_date');
        $project_id    = $request->get('project_id');
        $workflow      = $request->get('workflow');
        $repeat_order   = null;
        if($request->has('repeat_order')) {
            $repeat_order = $request->get('repeat_order');
            if($repeat_order === 'true' || $repeat_order === '1') {
                $repeat_order = true;
            } elseif($repeat_order === 'false' || $repeat_order === '0') {
                $repeat_order = false;
            } else {
                $repeat_order = null; // invalid value, ignore filter
            }
        } else {
            $repeat_order = null;
        }

        $query = Orders::with(['project','items.product','items.supplier'])
            ->where('client_id', $user->id);

        if ($search !== '')        $query->where('po_number', 'like', "%{$search}%");
        if ($delivery_date)        $query->whereDate('delivery_date', $delivery_date);
        if ($project_id)           $query->where('project_id', $project_id);
        if ($workflow)             $query->where('workflow', $workflow);
        if ($repeat_order !== null) $query->where('repeat_order', (bool)$repeat_order);
        // dd($repeat_order);
        $allowedSorts = ['po_number','delivery_date','created_at','updated_at'];
        if (!in_array($sort, $allowedSorts, true)) $sort = 'created_at';

        $orders = $query->orderBy($sort, $dir)->paginate($perPage);

        // enrich each order with order_info
        $enriched = collect($orders->items())->map(function (Orders $o) {
            $missing = $o->items->whereNull('supplier_id');
            if ($o->workflow === 'Supplier Missing') {
                $missingNames = $missing->map(fn($it) => optional($it->product)->product_name)
                                        ->filter()->unique()->values()->all();
                $o->order_info = 'Supplier missing for: ' . implode(', ', $missingNames);
            } elseif ($o->workflow === 'Supplier Assigned') {
                $o->order_info = 'Waiting for suppliers to confirm';
            } elseif ($o->workflow === 'Payment Requested') {
                $o->order_info = 'Awaiting your payment';
            } else {
                $o->order_info = null;
            }
            return $o;
        })->values()->all();

        $base = Orders::where('client_id', $user->id);
        $metrics = [
            'total_orders_count'      => (clone $base)->count(),
            'supplier_missing_count'  => (clone $base)->where('workflow', 'Supplier Missing')->count(),
            'supplier_assigned_count' => (clone $base)->where('workflow', 'Supplier Assigned')->count(),
            'awaiting_payment_count'  => (clone $base)->where('workflow', 'Payment Requested')->count(),
            'delivered_count'         => (clone $base)->where('workflow', 'Delivered')->count(),
        ];

        $response = [
            'data' => $enriched,
            'pagination' => [
                'per_page' => $orders->perPage(),
                'current_page' => $orders->currentPage(),
                'total_pages' => $orders->lastPage(),
                'total_items' => $orders->total(),
                'has_more_pages' => $orders->hasMorePages(),
            ],
            'metrics' => $metrics,
        ];

        if ($details) {
            $projects = Projects::where('added_by', $user->id)
                ->orderBy('created_at','desc')
                ->get(['id','name']);
            $response['projects'] = $projects;
        }

        return response()->json($response);
    }


    /**
     * Client view. If workflow = Supplier Missing, include eligible suppliers per missing item.
     */
    public function viewMyOrder(Orders $order)
    {
        abort_unless($order->client_id === Auth::id(), 403);

        $order->load(['project','items.product','items.supplier']);

        $missing = $order->items->whereNull('supplier_id');
            if ($order->workflow === 'Supplier Missing') {
                $missingNames = $missing->map(fn($it) => optional($it->product)->product_name)
                                        ->filter()->unique()->values()->all();
                $order->order_info = 'Supplier missing for: ' . implode(', ', $missingNames);
            } elseif ($order->workflow === 'Supplier Assigned') {
                $order->order_info = 'Waiting for suppliers to confirm';
            } elseif ($order->workflow === 'Payment Requested') {
                $order->order_info = 'Awaiting your payment';
            } else {
                $order->order_info = null;
            }

        $orderData = $order->only([
            'id','po_number','project_id','client_id','workflow','delivery_address',
            'delivery_date','delivery_time','delivery_method','repeat_order','subtotal','fuel_levy','other_charges','gst_tax','total_price','reason','created_at','updated_at'
        ]);
        
        $order->items->each(function (OrderItem $item) use ($order) {
            $item->supplier_unit_cost = ((float) $item->supplier_unit_cost/2) + (float) $item->supplier_unit_cost;
        });

        $orderData['project'] = optional($order->project)?->only(['id','name','site_contact_name','site_contact_phone','site_instructions']);
        $orderData['order_info'] = $order->order_info;
        return response()->json([
            'success' => true,
            'data' => [
                'order' => $orderData,
                'items' => $order->items,
            ],
        ]);
    }


    /**
     * Assign a supplier to a specific order item and advance workflow if all assigned.
     * Body: { "supplier_id": <int> }
     */
    public function assignSupplier(Request $request, OrderItem $item)
    {
        $v = Validator::make($request->all(), ['supplier_id' => 'required|exists:users,id']);
        if ($v->fails()) return response()->json(['error'=>$v->errors()], 422);

        $order = $item->order()->with('items')->first();
        abort_unless($order && $order->client_id === Auth::id(), 403);

        $supplierId = (int) $request->supplier_id;

        $chosenOffer = SupplierOffers::with('supplier:id,delivery_zones')
            ->where('supplier_id', $supplierId)
            ->where('master_product_id', $item->product_id)
            ->where('status', 'Approved')
            ->whereIn('availability_status', ['In Stock','Limited'])
            ->whereHas('supplier', fn($q) => $q->whereJsonLength('delivery_zones','>=',1))
            ->first();

        if (!$chosenOffer) {
            return response()->json(['error' => 'No valid offer with delivery zones for this product'], 422);
        }

        $item->update([
            'supplier_id'             => $chosenOffer->supplier_id,
            'choosen_offer_id'        => $chosenOffer->id,
            'supplier_unit_cost'      => (float) ($chosenOffer->unit_cost ?? $chosenOffer->price ?? 0),
            'supplier_delivery_cost'  => (float) ($chosenOffer->delivery_cost ?? 0),
            'supplier_delivery_date'  => $order->delivery_date,
            'supplier_confirms'       => false,
        ]);

        if ($order->items()->whereNull('supplier_id')->count() === 0) {
            $order->update(['workflow' => 'Supplier Assigned', 'order_process' => 'Automated']);
        }

        return response()->json([
            'success' => true,
            'message' => 'Supplier assigned',
            'order_workflow' => $order->workflow,
            'item' => $item->fresh(['product','supplier','chosenOffer']),
        ]);
    }



    /**
     * Mark or unmark an order as repeat order.
     */    
    public function markRepeatOrder(Orders $order, Request $request)
    {
        abort_unless($order->client_id === Auth::id(), 403);
        $order->repeat_order = true;
        $order->save();
        return response()->json([
            'success' => true,
            'message' => 'Order marked as repeat order',
            'order'   => $order->only(['id','repeat_order']),
        ]); 
    }

    
    
        

}




------------------------------------------------------------
FILE: Http/Controllers/ProjectController.php
------------------------------------------------------------
<?php

namespace App\Http\Controllers;

use App\Models\Projects as Project; // keep alias if your model is named Projects
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Validator; // added
use Illuminate\Validation\Rule;

class ProjectController extends Controller
{
    // GET /client/projects
    public function index(Request $request)
    {

        $projects= Project::where('added_by', Auth::id())->get();
        return response()->json(['data'=>$projects]);
        $user = Auth::user();
        abort_unless($user && $user->role === 'client', 403, 'Forbidden');

        $perPage = (int) $request->get('per_page', 10);
        $search  = trim((string) $request->get('search', ''));
        $sort    = $request->get('sort', 'created_at');
        $dir     = $request->get('dir', 'desc');

        $query = Project::with('added_by.company')
            ->where('added_by', $user->id);

        if ($search !== '') {
            $query->where('name', 'like', "%{$search}%");
        }

        $allowedSorts = ['name','created_at','updated_at'];
        if (!in_array($sort, $allowedSorts, true)) $sort = 'created_at';
        $dir = strtolower($dir) === 'asc' ? 'asc' : 'desc';

        return response()->json(
            $query->orderBy($sort, $dir)->paginate($perPage),
            200
        );
    }

    // GET /client/projects/{project}
    public function show($id)
{
    
    $project = Project::find($id);
    if (!$project) {
        return response()->json(['error' => 'Project not found'], 404);
    }
 
    
    $user = Auth::user();
    abort_unless($user && $user->role === 'client', 403, 'Forbidden');

    // compare against the FK column
    abort_unless((int) $project->added_by === (int) $user->id, 404, 'Project not found');
    

    $project->load('added_by.company');
    // dd($project);
    return response()->json($project, 200);
}

    // POST /client/projects
    public function store(Request $request)
    {
        $user = Auth::user();
        abort_unless($user && $user->role === 'client', 403, 'Forbidden');

        $validator = Validator::make($request->all(), [
            'name'               => ['required','string','max:255'],
            'site_contact_name'  => ['nullable','string','max:255'],
            'site_contact_phone' => ['nullable','string','max:50'],
            'site_instructions'  => ['nullable','string'],
        ]);

        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 400);
        }

        $data = $validator->validated();

        $project = Project::create([
            ...$data,
            'added_by' => $user->id, // lock to this client
        ]);

        return response()->json($project->load('added_by.company'), 201);
    }

    // PUT /client/projects/{project}
    public function update(Request $request, Project $project)
    {
        $user = Auth::user();
        abort_unless($user && $user->role === 'client', 403, 'Forbidden');
        abort_unless($project->added_by === $user->id, 404, 'Project not found');

        $validator = Validator::make($request->all(), [
            'name'               => ['sometimes','required','string','max:255'],
            'site_contact_name'  => ['nullable','string','max:255'],
            'site_contact_phone' => ['nullable','string','max:50'],
            'site_instructions'  => ['nullable','string'],
        ]);

        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 400);
        }

        $data = $validator->validated();

        // do NOT change added_by
        $project->update($data);

        return response()->json($project->fresh()->load('added_by.company'), 200);
    }

    // DELETE /client/projects/{project}
    public function destroy($id)
    {
        $project = Project::find($id);
        if (!$project) {
            return response()->json(['error' => 'Project not found'], 404);
        }
        
        $user = Auth::user();
        abort_unless($user && $user->role === 'client', 403, 'Forbidden');
        abort_unless($project->added_by === $user->id, 404, 'Project not found');

        $project->delete();
        return response()->json(['message' => 'Project deleted'], 200);
    }
}


------------------------------------------------------------
FILE: Http/Controllers/SupplierController.php
------------------------------------------------------------
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\Models\SupplierOffers;
use App\Models\MasterProducts;
use App\Models\User;
use Illuminate\Support\Facades\Validator;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Str;

class SupplierController extends Controller
{   

    /**
     * Add a product to the supplier's inventory.
     */

    public function deliveryZonesManagement(Request $request)
    {
        // Logic for managing delivery zones
        $validator = Validator::make($request->all(), [
            'zones' => 'sometimes|array',
            'zones.*.lat' => 'sometimes|numeric',
            'zones.*.long' => 'sometimes|numeric',
            'zones.*.radius' => 'sometimes|numeric',
            'zones.*.address' => 'sometimes|string|max:255',
        ]);
        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 400);
        }
        /** @var User $user */
        $user = Auth::user();
        abort_unless($user && $user->role === 'supplier', 403, 'Forbidden');
        if( !$request->zones || $request->zones === null || $request->zones === '' || count($request->zones) === 0){
            $user->delivery_zones = null;
            $user->save();
            return response()->json(['message' => 'Delivery zones cleared', 'delivery_zones' => []], 200);
        }
        $user->delivery_zones = json_encode($request->zones);
        $user->save();
        return response()->json(['message' => 'Delivery zones updated successfully', 'delivery_zones' => json_decode($user->delivery_zones,true)], 200);
    }

    public function getDeliveryZones()
    {
        $user = Auth::user();
        abort_unless($user && $user->role === 'supplier', 403, 'Forbidden');
        if( !$user->delivery_zones || $user->delivery_zones === null || $user->delivery_zones === ''){
            return response()->json(['delivery_zones' => []], 200);
        }
        return response()->json(['delivery_zones' => json_decode($user->delivery_zones,true)], 200);
    }


    /**
     * Get Master Product Inventory.
     */
    public function getMasterProductInventory(Request $request)
    {
        $perPage = (int) $request->get('per_page', 10);
        $page = (int) $request->get('page', 1); 
        $query = MasterProducts::with(['added_by', 'approved_by', 'category'])
            ->where('is_approved', true); // Only approved products

        //Apply Category filter
        if ($request->filled('category_id')) {
            $query->where('category', $request->get('category_id'));
        }
        // Apply search filter
        if ($request->filled('search')) {
            $search = $request->get('search');
            $query->where('product_name', 'like', "%{$search}%");
        }
        // Paginate after filters
        $products = $query->paginate($perPage, ['*'], 'page', $page);
        // dd($products->toArray());
        // Append supplier offers count
        $products->getCollection()->transform(function ($product) {
            $product->supplierOffersCount = SupplierOffers::where('master_product_id', $product->id)->count();
            $product->suppliers = SupplierOffers::with('supplier')->where('master_product_id', $product->id)->get();
            $product->suppliers->transform(function ($supplier) {
                $supplier->isMe = Auth::id() == $supplier->supplier_id;
                return $supplier;
            });
            return $product;
        });
        return response()->json($products, 200);
    }

    /**
     * Add a product to the supplier's inventory.
     */
    public function addProductToInventory(Request $request)
    {
        $validator = Validator::make($request->all(), [
            'master_product_id' => 'required|exists:master_products,id',
            'price' => 'required|numeric',
            'availability_status' => 'required|in:In Stock,Out of Stock,Limited',
        ]);

        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 400);
        }

        // Create supplier offer for the product
        $supplierOffer = SupplierOffers::updateOrCreate([
            'supplier_id' => Auth::id(), // Authenticated supplier
            'master_product_id' => $request->master_product_id,
            'price' => $request->price,
            'availability_status' => $request->availability_status,
            'status' => 'Pending', // Default status, awaiting approval if needed
        ]);

        return response()->json(['message' => 'Product added to inventory successfully', 'supplier_offer' => $supplierOffer], 201);
    }

    /**
     * Request a new product to be added to the master catalog.
     */
    public function requestNewProduct(Request $request)
    {
        $validator = Validator::make($request->all(), [
            'product_name' => 'required|string|max:255',
            'product_type' => 'required|string|max:255',
            'category_id' => 'nullable|exists:category,id', // Optional category
            'specifications' => 'nullable|string',
            'unit_of_measure' => 'nullable|string|max:100',
            'price' => 'required|numeric',
            'availability_status' => 'required|in:In Stock,Out of Stock,Limited',
        ]);
        
        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 400);
        }
      

        // Create a new product request (admin will approve or reject)
        $newProduct = MasterProducts::create([
            'product_name' => $request->product_name,
            'product_type' => $request->product_type,
            'category' => $request->category_id,
            'specifications' => $request->specifications,
            'unit_of_measure' => $request->unit_of_measure,
            'slug' => Str::slug($request->product_name) . '-' . Str::random(6),
            'is_approved' => false, // Pending approval by admin
            'added_by' => Auth::id(), // Supplier is adding the product
        ]);
        $supplierOffer = SupplierOffers::updateOrCreate([
            'supplier_id' => Auth::id(), // Authenticated supplier
            'master_product_id' => $newProduct->id,
            'price' => $request->price,
            'availability_status' => $request->availability_status,
            'status' => 'Pending', // Default status, awaiting approval if needed
        ]);

        return response()->json(['message' => 'Product request submitted successfully', 'new_product' => $newProduct], 201);
    }

    /**
     * View the supplier's products list.
     */
    public function getSupplierProducts(Request $request)
    {
        // Fetch supplier's products from SupplierOffers
        $supplierOffers = SupplierOffers::with(['masterProduct', 'masterProduct.category','supplier'])
            ->where('supplier_id', Auth::id())
            ->paginate(10); // Pagination if needed

        return response()->json($supplierOffers);
    }

    /**
     * Edit product pricing in the supplier's inventory.
     */
    public function updateProductPricing(Request $request, $offerId)
    {
        $validator = Validator::make($request->all(), [
            'price' => 'required|numeric',
            'availability_status' => 'required|in:In Stock,Out of Stock,Limited',
        ]);

        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 400);
        }

        // Find the existing supplier offer
        $supplierOffer = SupplierOffers::find($offerId);

        if (!$supplierOffer || $supplierOffer->supplier_id != Auth::id()) {
            return response()->json(['error' => 'Offer not found or you are not authorized to edit this offer'], 404);
        }

        // Update the product pricing and availability
        $supplierOffer->update([
            'price' => $request->price,
            'availability_status' => $request->availability_status,
        ]);

        return response()->json(['message' => 'Product pricing updated successfully', 'supplier_offer' => $supplierOffer], 200);
    }

    /**
     * Delete product from the supplier's inventory.
     */
    public function deleteProductFromInventory($offerId)
    {
        // Find the existing supplier offer
        $supplierOffer = SupplierOffers::find($offerId);
        if (!$supplierOffer || $supplierOffer->supplier_id != Auth::id()) {
            return response()->json(['error' => 'Offer not found or you are not authorized to delete this offer'], 404);
        }
        $supplierOffer->delete();
        return response()->json(['message' => 'Product removed from inventory successfully'], 200);
    }

    /**
     * Get Status of Supplier Offers.
     */
    public function getSupplierOfferStatus()
    {
        $offers = SupplierOffers::where('supplier_id', Auth::id())->get();
        return response()->json($offers, 200);
    }

}


------------------------------------------------------------
FILE: Http/Controllers/SupplierOrderController.php
------------------------------------------------------------
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\Models\Orders;
use App\Models\OrderItem;
use App\Models\MasterProducts;
use App\Models\SupplierOffers;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Validator;

class SupplierOrderController extends Controller
{
    // Helper function | Workflow 
    private function workflow(Orders $order)
    {
        $currentWorkflow = $order->workflow;

        switch ($currentWorkflow) {
            case 'Supplier Assigned':
                $allConfirmed = $order->items()->where('supplier_confirms', false)->count() === 0;
                if ($allConfirmed) {
                    // Calculate pricing
                    $subtotal = 0;
                    $supplierCost = 0;
                    $adminMarginPercentage = 0.50; // 50% admin margin
                    $deliveryCost = 0;
                    $fuelLevy = 0;
                    $itemCostWithMargin= 0;
                    $adminMarginAmount = 0;
                    
                    foreach ($order->items as $item) {
                        // Calculate item cost excluding delivery
                        $itemCost = ($item->supplier_unit_cost * $item->quantity) - $item->supplier_discount;
                        
                        // Add admin margin to item cost (50% on top of item cost)
                        $itemCostWithMargin = $itemCost + ($itemCost * $adminMarginPercentage);
                        
                        $subtotal += $itemCostWithMargin;
                        $supplierCost += $itemCost; // Supplier cost without admin margin
                        $deliveryCost += $item->supplier_delivery_cost;
                    }
                   
                    
                    // Calculate fuel levy (10% on delivery cost as per your example)
                    $fuelLevy = $deliveryCost + ($deliveryCost * 0.10);
                    //  dd($subtotal,$fuelLevy);
                    
                    // Calculate GST (10% on subtotal)
                    $gstTax = $subtotal * 0.10;
                    
                    // Calculate total price
                    $totalPrice = $subtotal + $gstTax + $fuelLevy - $order->discount + $order->other_charges;
                    
                    // Calculate actual admin margin amount (for tracking)
                    $adminMarginAmount = $subtotal * $adminMarginPercentage;

                    // Update order pricing fields
                    $order->subtotal = $subtotal;
                    $order->fuel_levy = $fuelLevy;
                    $order->gst_tax = $gstTax;
                    $order->total_price = $totalPrice;
                    $order->supplier_cost = $supplierCost + $deliveryCost; // Total supplier cost including delivery
                    $order->customer_cost = $totalPrice;
                    $order->admin_margin = $adminMarginAmount; // The actual margin amount
                    $order->workflow = 'Payment Requested';
                    $order->save();
                }
                break;
        }
    }


    // public function getSupplierOrders(Request $request)
    // {
    //     $user = Auth::user();

    //     // Pagination and filtering parameters
    //     $perPage = (int) $request->get('per_page', 10);
    //     $search = trim((string) $request->get('search', ''));
    //     $confirmed = $request->get('supplier_confirms');
    //     $deliveryDate = $request->get('supplier_delivery_date');
    //     $productId = $request->get('product_id');
    //     $details = $request->boolean('details', false);

    //     // Base query for supplier's order items - reusable for all metrics
    //     $baseQuery = function () use ($user, $search, $confirmed, $deliveryDate, $productId) {
    //         $query = OrderItem::where('supplier_id', $user->id);

    //         // Apply search filter (by product name)
    //         if (!empty($search)) {
    //             $query->whereHas('product', function ($q) use ($search) {
    //                 $q->where('product_name', 'like', '%' . $search . '%');
    //             });
    //         }

    //         // Apply confirmed filter
    //         if ($confirmed !== null) {
    //             $query->where('supplier_confirms', filter_var($confirmed, FILTER_VALIDATE_BOOLEAN));
    //         }

    //         // Apply delivery date filter
    //         if (!empty($deliveryDate)) {
    //             $query->whereDate('supplier_delivery_date', $deliveryDate);
    //         }

    //         // Apply product ID filter
    //         if (!empty($productId)) {
    //             $query->where('product_id', $productId);
    //         }

    //         return $query;
    //     };

    //     // Get metrics with applied filters
    //     $totalOrdersCount = $baseQuery()->count();
    //     $supplierConfirmedCount = $baseQuery()->where('supplier_confirms', true)->count();
    //     $awaitingPaymentCount = $baseQuery()->where('is_paid', false)->count();
    //     $deliveredCount = $baseQuery()->whereHas('order', function ($query) {
    //         $query->where('workflow', 'Delivered');
    //     })->count();

    //     // Get paginated results using the same base query
    //     $orderItemsQuery = $baseQuery()->with(['order', 'product', 'chosenOffer']);
    //     $orderItems = $orderItemsQuery->orderBy('created_at', 'desc')->paginate($perPage);

    //     // Prepare response data
    //     $data = [
    //         'data' => $orderItems->items(),
    //         'pagination' => [
    //             'current_page' => $orderItems->currentPage(),
    //             'per_page' => $orderItems->perPage(),
    //             'total' => $orderItems->total(),
    //             'last_page' => $orderItems->lastPage(),
    //         ],
    //         'metrics' => [
    //             'total_orders_count' => $totalOrdersCount,
    //             'supplier_confirmed_count' => $supplierConfirmedCount,
    //             'awaiting_payment_count' => $awaitingPaymentCount,
    //             'delivered_count' => $deliveredCount,
    //         ]
    //     ];

    //     // Add filters data if details=true
    //     if ($details) {
    //         // Get products that this supplier offers
    //         $supplierProducts = MasterProducts::whereHas('supplierOffers', function ($query) use ($user) {
    //             $query->where('supplier_id', $user->id);
    //         })
    //         ->select('id', 'product_name', 'photo')
    //         ->get()
    //         ->map(function ($product) {
    //             return [
    //                 'id' => $product->id,
    //                 'product_name' => $product->product_name,
    //                 'photo' => $product->photo,
    //             ];
    //         });

    //         $data['filters'] = [
    //             'products' => $supplierProducts
    //         ];
    //     }

    //     return response()->json([
    //         'success' => true,
    //         'data' => $data
    //     ]);
    // }
    public function getSupplierOrders(Request $request)
    {
        $user = Auth::user();

        // Pagination and filtering parameters
        $perPage = (int) $request->get('per_page', 10);
        $search = trim((string) $request->get('search', ''));
        $confirmed = $request->get('supplier_confirms');
        $deliveryDate = $request->get('supplier_delivery_date');
        $productId = $request->get('product_id');
        $details = $request->boolean('details', false);
        // dd($user);
        // Base query for orders that have items assigned to this supplier
        $baseQuery = function () use ($user, $search, $confirmed, $deliveryDate, $productId) {
            $query = Orders::whereHas('items', function ($q) use ($user, $search, $confirmed, $deliveryDate, $productId) {
                $q->where('supplier_id', $user->id);

                // Apply search filter (by product name)
                if (!empty($search)) {
                    $q->whereHas('product', function ($productQuery) use ($search) {
                        $productQuery->where('product_name', 'like', '%' . $search . '%');
                    });
                }

                // Apply confirmed filter
                if ($confirmed !== null) {
                    $q->where('supplier_confirms', filter_var($confirmed, FILTER_VALIDATE_BOOLEAN));
                }

                // Apply delivery date filter
                if (!empty($deliveryDate)) {
                    $q->whereDate('supplier_delivery_date', $deliveryDate);
                }

                // Apply product ID filter
                if (!empty($productId)) {
                    $q->where('product_id', $productId);
                }
            });

            return $query;
        };

        // Get metrics with applied filters
        $totalOrdersCount = $baseQuery()->count();
        
        $supplierConfirmedCount = Orders::whereHas('items', function ($q) use ($user, $search, $confirmed, $deliveryDate, $productId) {
            $q->where('supplier_id', $user->id)
            ->where('supplier_confirms', true);

            // Apply the same filters for consistency
            if (!empty($search)) {
                $q->whereHas('product', function ($productQuery) use ($search) {
                    $productQuery->where('product_name', 'like', '%' . $search . '%');
                });
            }
            if (!empty($deliveryDate)) {
                $q->whereDate('supplier_delivery_date', $deliveryDate);
            }
            if (!empty($productId)) {
                $q->where('product_id', $productId);
            }
        })->count();
        
        // $awaitingPaymentCount = Orders::whereHas('items', function ($q) use ($user, $search, $confirmed, $deliveryDate, $productId) {
        //     $q->where('supplier_id', $user->id)
        //     ->where('is_paid', false);
        $awaitingPaymentCount = Orders::where(function ($orderQuery) use ($user) {
    $orderQuery->whereNull('supplier_paid_ids')
               ->orWhereJsonDoesntContain('supplier_paid_ids', $user->id); // User ID not in paid list
})
->whereHas('items', function ($q) use ($user, $search, $confirmed, $deliveryDate, $productId) {
    $q->where('supplier_id', $user->id);

    // Optional filters
    if (!empty($search)) {
        $q->whereHas('product', function ($productQuery) use ($search) {
            $productQuery->where('product_name', 'like', '%' . $search . '%');
        });
    }

    if (!empty($deliveryDate)) {
        $q->whereDate('supplier_delivery_date', $deliveryDate);
    }

    if (!empty($productId)) {
        $q->where('product_id', $productId);
    }
})->count();


        
        $deliveredCount = $baseQuery()->where('workflow', 'Delivered')->count();

        // Get paginated results with supplier's items count and relationship
        $ordersQuery = $baseQuery()->with(['items' => function ($query) use ($user) {
            $query->where('supplier_id', $user->id)
                ->with(['product', 'chosenOffer']);
        }]);

        $orders = $ordersQuery->orderBy('created_at', 'desc')->paginate($perPage);

        // Transform the response to include items count for this supplier
        $transformedOrders = $orders->getCollection()->map(function ($order) use ($user) {
            $supplierItems = $order->items->where('supplier_id', $user->id);
            $totalAmount=0;
            foreach($supplierItems as $item){
                $itemCost = ($item->supplier_unit_cost * $item->quantity) - $item->supplier_discount + $item->supplier_delivery_cost;
                $totalAmount += $itemCost;
            }
            
            return [
                'id' => $order->id,
                'order_number' => $order->order_number,
                'workflow' => $order->workflow,
                'total_amount' => $totalAmount,
                'created_at' => $order->created_at,
                'updated_at' => $order->updated_at,
                'supplier_items_count' => $supplierItems->count(),
                'supplier_items' => $supplierItems->map(function ($item) {
                    return [
                        'id' => $item->id,
                        'product_id' => $item->product_id,
                        'quantity' => $item->quantity,
                        'supplier_unit_cost' => $item->supplier_unit_cost,
                        'supplier_delivery_cost' => $item->supplier_delivery_cost,
                        'supplier_discount' => $item->supplier_discount,
                        'supplier_delivery_date' => $item->supplier_delivery_date,
                        'supplier_confirms' => $item->supplier_confirms,
                        // 'is_paid' => $item->is_paid,
                        'supplier_notes' => $item->supplier_notes,
                        'product' => $item->product,
                        'chosen_offer' => $item->chosenOffer,
                    ];
                }),
                // Include other order fields you need
            ];
        });

        // Prepare response data
        $data = [
            'data' => $transformedOrders,
            'pagination' => [
                'current_page' => $orders->currentPage(),
                'per_page' => $orders->perPage(),
                'total' => $orders->total(),
                'last_page' => $orders->lastPage(),
            ],
            'metrics' => [
                'total_orders_count' => $totalOrdersCount,
                'supplier_confirmed_count' => $supplierConfirmedCount,
                'awaiting_payment_count' => $awaitingPaymentCount,
                'delivered_count' => $deliveredCount,
            ]
        ];

        // Add filters data if details=true
        if ($details) {
            // Get products that this supplier offers
            $supplierProducts = MasterProducts::whereHas('supplierOffers', function ($query) use ($user) {
                $query->where('supplier_id', $user->id);
            })
            ->select('id', 'product_name', 'photo')
            ->get()
            ->map(function ($product) {
                return [
                    'id' => $product->id,
                    'product_name' => $product->product_name,
                    'photo' => $product->photo,
                ];
            });

            $data['filters'] = [
                'products' => $supplierProducts
            ];
        }

        return response()->json([
            'success' => true,
            'data' => $data
        ]);
    }

    public function updateOrderPricing(Request $request, OrderItem $orderItem)
    {
        $v = Validator::make($request->all(), [
            'supplier_unit_cost' => 'sometimes|required|numeric|min:0',
            'supplier_discount' => 'sometimes|required|numeric|min:0',
            'supplier_delivery_date' => 'sometimes|required|date',
            'supplier_confirms' => 'sometimes|required|boolean',
            'supplier_delivery_cost' => 'sometimes|required|numeric|min:0',
            'supplier_notes' => 'sometimes|nullable|string|max:500'
        ]);

        if ($v->fails()) {
            return response()->json(['error' => $v->errors()], 422);
        }

        // Check if the authenticated user is the supplier for this order item
        $user = Auth::user();
        // dd($orderItem->order->workflow);
        if(!in_array($orderItem->order->workflow, ['Supplier Assigned', 'Requested', 'Payment Requested', 'On Hold', 'Delivered'])) {
            return response()->json([
                'message' => 'Cannot update order item now as the order is in '.$orderItem->order->workflow.' status'
            ], 403);
        }   
        if ($orderItem->supplier_id !== $user->id) {
            return response()->json([
                'message' => 'You are not authorized to update this order item'
            ], 403);
        }

        // Check if order item is already confirmed
        if ($orderItem->supplier_confirms && $request->has('supplier_confirms') && !$request->supplier_confirms) {
            return response()->json([
                'message' => 'Cannot unconfirm an already confirmed order item'
            ], 422);
        }

        try {
            DB::beginTransaction();

            // Update the order item with provided fields
            $updateData = [];
            
            if ($request->has('supplier_unit_cost')) {
                $updateData['supplier_unit_cost'] = $request->supplier_unit_cost;
            }
            
            if ($request->has('supplier_delivery_cost')) {
                $updateData['supplier_delivery_cost'] = $request->supplier_delivery_cost;
            }
            
            if ($request->has('supplier_discount')) {
                $updateData['supplier_discount'] = $request->supplier_discount;
            }
            
            if ($request->has('supplier_delivery_date')) {
                $updateData['supplier_delivery_date'] = $request->supplier_delivery_date;
            }
            
            if ($request->has('supplier_confirms')) {
                $updateData['supplier_confirms'] = $request->supplier_confirms;
            }
            
            if ($request->has('supplier_notes')) {
                $updateData['supplier_notes'] = $request->supplier_notes;
            }

            // Update the order item
            $orderItem->update($updateData);

            // If supplier confirmed the order, trigger workflow check
            if ($request->has('supplier_confirms') && $request->supplier_confirms) {
                $this->workflow($orderItem->order);
            }

            DB::commit();

            // Reload the order item with relationships
            $orderItem->load(['order', 'product', 'chosenOffer']);

            return response()->json([
                'success' => true,
                'message' => 'Order item updated successfully',
                'data' => $orderItem
            ]);

        } catch (\Exception $e) {
            DB::rollBack();
            return response()->json([
                'error' => 'Failed to update order item: ' . $e->getMessage()
            ], 500);
        }
    }

    public function viewOrderDetails(Orders $order)
    {
        $user = Auth::user();

        // Ensure the supplier has items in this order
        $supplierItems = $order->items()->where('supplier_id', $user->id)->with(['product', 'chosenOffer'])->get();

        if ($supplierItems->isEmpty()) {
            return response()->json([
                'error' => 'You do not have any items in this order'
            ], 403);
        }

        // Reload the order with only selected fields and relationships
        $order = Orders::where('id', $order->id)
            ->select([
                'id',
                'po_number', // Make sure this field exists in your table
                'project_id',
                'client_id',
                'workflow',
                'delivery_address',
                'delivery_date',
                'delivery_time',
                'delivery_window',
                'delivery_method',
                'load_size',
                'special_equipment',
                'special_notes',
                'created_at',
                'updated_at'
            ])
            ->with(['client:id,name,email', 'project:id,name,site_contact_name,site_contact_phone,site_instructions'])
            ->first();

        return response()->json([
            'success' => true,
            'data' => [
                'order' => $order,
                'supplier_items' => $supplierItems
            ]
        ]);
    }



    
}


------------------------------------------------------------
FILE: Http/Controllers/UserManagement.php
------------------------------------------------------------
<?php
namespace App\Http\Controllers;

use App\Models\User;
use App\Models\Company;
use App\Models\Category;
use Illuminate\Http\Request;
use Illuminate\Support\Str;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Facades\Validator;
use Illuminate\Support\Facades\Storage;

class UserManagement extends Controller
{
    // List Users with Multiple Filters and Pagination
    public function index(Request $request)
    {
        $query = User::query();

        // Filters
        if ($request->has('role') && in_array($request->role, ['admin', 'client', 'supplier'])) {
          
            $query->where('role', $request->role);
        }

        if ($request->has('isDeleted')) {
        // Ensure the value is treated as a boolean (either true or false)
        $isDeleted = filter_var($request->isDeleted, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE);

        // If valid, apply the filter
        if ($isDeleted !== null) {
            $query->where('isDeleted', $isDeleted);
        }
}

        if ($request->has('company_id') && is_numeric($request->company_id)) {
            $query->where('company_id', $request->company_id);
        }

        if ($request->has('contact_name')) {
            $query->where('contact_name', 'like', '%' . $request->contact_name . '%');
        }

        if ($request->has('location')) {
            $query->where('location', 'like', '%' . $request->location . '%');
        }

        if ($request->has('lat') && $request->has('long')) {
            $query->where('lat', $request->lat)->where('long', $request->long);
        }

        // Get the 'per_page' value from the request, default to 10 if not provided
        $perPage = $request->get('per_page', 10); // Default to 10 if no value is provided

        // Pagination
        $users = $query->paginate($perPage);

        return response()->json($users);
    }

    
    // Add User
    public function store(Request $request)
    {
        // Manual validation handling (same as in registerSupplier)
        $validator = Validator::make($request->all(), [
            'name' => 'required|string|max:255',
            'email' => 'required|email|unique:users,email',
            'password' => 'required|string|min:6',
            'role' => 'required|string|in:admin,client,supplier',
            'company_name' => 'nullable|string|max:255', // Make sure the company name is optional
            'contact_name' => 'nullable|string|max:255',
            'contact_number' => 'nullable|string|max:255',
            'location' => 'nullable|string|max:255',
            'lat' => 'nullable|numeric',
            'long' => 'nullable|numeric',
            'delivery_radius' => 'nullable|numeric',
            'shipping_address' => 'nullable|string|max:255',
            'billing_address' => 'nullable|string|max:255',
            'client_public_id' => 'nullable|string|unique:users,client_public_id',
            'profile_image' => 'nullable|image|mimes:jpg,png,jpeg,gif',
            'notes' => 'nullable|string|max:1000',
        ]);

        // Check if validation fails
        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 400);
        }

        // Handle Company ID if it's for client or supplier
        $company_id = null;
        if ($request->role !== 'admin' && $request->has('company_name')) {
            // Look for the company by name, or create it if not found
            $company = Company::firstOrCreate([
                'name' => Str::lower($request->company_name),  // Company name is case-insensitive
            ]);

            // Assign the found or created company ID
            $company_id = $company->id;
        }

        // Handle Profile Image
        $imageUrl = null;
        if ($request->hasFile('profile_image') && $request->file('profile_image')->isValid()) {
            // Store the file under 'profile_images' directory in the 'public' disk
            $path = $request->file('profile_image')->store('profile_images', 'public');
            $imageUrl = 'storage/' . $path; // Relative path to the image
        }

        // Create the User
        $user = User::create([
            'name' => $request->name,
            'email' => $request->email,
            'password' => Hash::make($request->password),
            'role' => $request->role,
            'company_id' => $company_id,  // Assign company_id (can be null or an existing company ID)
            'contact_name' => $request->contact_name,
            'contact_number' => $request->contact_number,
            'location' => $request->location,
            'lat' => $request->lat,
            'long' => $request->long,
            'delivery_radius' => $request->delivery_radius,
            'shipping_address' => $request->shipping_address,
            'billing_address' => $request->billing_address,
            'client_public_id' => $request->client_public_id ?? 'MC-' . rand(100, 999),
            'profile_image' => $imageUrl,
            'isDeleted' => false,
            'notes' => $request->notes,
        ]);

        // Return the created user along with a success message and profile image URL
        return response()->json([
            'message' => 'User registered successfully.',
            'user' => $user,
            'role' => $user->role,
            'profile_image_url' => $imageUrl, // Return the image URL in response
        ], 201);
    }

    // Show User Details
    public function show($id)
    {
        $user = User::with('company')->find($id);
        if (!$user) {
            return response()->json(['error' => 'User not found'], 404);
        }
        return response()->json($user);
    }

    // Update User
    public function update(Request $request, $id)
    {
        // Find the user by ID
        $user = User::find($id);
        if (!$user) {
            return response()->json(['error' => 'User not found'], 404);
        }

        // Validate the request
        $validator = Validator::make($request->all(), [
            'name' => 'string|max:255',
            'email' => 'email|unique:users,email,' . $id,
            'password' => 'nullable|string|min:6',
            'role' => 'string|in:admin,client,supplier',
            'contact_name' => 'nullable|string|max:255',
            'contact_number' => 'nullable|string|max:255',
            'location' => 'nullable|string|max:255',
            'lat' => 'nullable|numeric',
            'long' => 'nullable|numeric',
            'delivery_radius' => 'nullable|numeric',
            'shipping_address' => 'nullable|string|max:255',
            'billing_address' => 'nullable|string|max:255',
            'profile_image' => 'nullable|image|mimes:jpg,png,jpeg,gif,webp',
            'notes' => 'nullable|string|max:1000',
        ]);

        // Check if validation fails
        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 400);
        }

        // Handle Profile Image
        $profileImagePath = $user->profile_image; // Existing profile image path

        if ($request->hasFile('profile_image')) {
            // Check if there's an old image and delete it before uploading the new one
            if ($profileImagePath) {
                $oldImagePath = str_replace('storage/', '', $profileImagePath); // Get the relative path
                $oldImagePath = 'storage/app/public/' . $oldImagePath;
                if (Storage::exists($oldImagePath)) {
                    Storage::delete($oldImagePath); // Delete the old image
                }
            }

            // Store the new profile image
            $profileImagePath = 'storage/'.$request->file('profile_image')->store('profile_images', 'public');
        }

        // Update the User with the new data
        $user->update([
            'name' => $request->name ?? $user->name,
            'email' => $request->email ?? $user->email,
            'password' => $request->password ? Hash::make($request->password) : $user->password,
            'role' => $request->role ?? $user->role,
            'contact_name' => $request->contact_name ?? $user->contact_name,
            'contact_number' => $request->contact_number ?? $user->contact_number,
            'location' => $request->location ?? $user->location,
            'lat' => $request->lat ?? $user->lat,
            'long' => $request->long ?? $user->long,
            'delivery_radius' => $request->delivery_radius ?? $user->delivery_radius,
            'shipping_address' => $request->shipping_address ?? $user->shipping_address,
            'billing_address' => $request->billing_address ?? $user->billing_address,
            'profile_image' => $profileImagePath ? $profileImagePath : $user->profile_image, // Store the relative path
            'notes' => $request->notes ?? $user->notes,
        ]);

        // Return the updated user information as a JSON response
        return response()->json($user->load('company'));
    }

    // Soft Delete User (Mark isDeleted as true)
    public function destroy($id)
    {
        $user = User::find($id);
        if (!$user) {
            return response()->json(['error' => 'User not found'], 404);
        }

        // Mark the user as deleted
        if($user->isDeleted){
            $user->update(['isDeleted' => false]);
            return response()->json(['message' => 'User restored successfully']);
        }
        $user->update(['isDeleted' => true]);

        return response()->json(['message' => 'User marked as deleted successfully']);
    }

    // Check if Company Exists
    public function checkCompany(Request $request)
    {
        $companyName = Str::lower($request->company_name);
        $company = Company::where('name', $companyName)->first();

        if ($company) {
            return response()->json(['exists' => true, 'company_id' => $company->id]);
        } else {
            return response()->json(['exists' => false]);
        }
    }


    public function addCategory(Request $request)
    {

        $validator = Validator::make($request->all(), [
            'name' => 'required|string|max:120|unique:category,name',
        ]);

        // Check if validation fails
        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 400);
        }

        $category = Category::create([
            'name' => $request->name,
        ]);
        return response()->json(['message' => 'Category added successfully', 'category' => $category], 201);
    }
    public function listCategories(Request $request)
    {
        // Default pagination parameters
        $perPage = $request->get('per_page', 10);  // Default 10 items per page
        $page = $request->get('page', 1);
        // Fetch categories with pagination
        $categories = Category::paginate($perPage);
        return response()->json($categories, 200);
    }

    public function deleteCategory($id)
    {
        $category = Category::find($id);
        if (!$category) {
            return response()->json(['error' => 'Category not found'], 404);
        }
        $category->delete();
        return response()->json(['message' => 'Category deleted successfully'], 200);
    }

    public function updateCategory(Request $request, $id)
    {
        $category = Category::find($id);
        if (!$category) {
            return response()->json(['error' => 'Category not found'], 404);
        }

        $data = $request->validate([
            'name' => 'required|string|max:120|unique:category,name,' . $id,
        ]);

        $category->update([
            'name' => $data['name'],
        ]);

        return response()->json(['message' => 'Category updated successfully', 'category' => $category], 200);
    }

    public function getCategory($id)
    {
      
        $category = Category::find($id);
        if (!$category) {
            return response()->json(['error' => 'Category not found'], 404);
        }
        return response()->json($category, 200);
    }

    public function getCompanies()
    {
        $companies = Company::all();
        return response()->json($companies);
    }

    public function getSuppliersWithDeliveryZones(Request $request)
    {
        $perPage = (int) $request->get('per_page', 10);
        $search = $request->get('search');

        $suppliers = User::where('role', 'supplier')
            ->whereNotNull('delivery_zones')
            ->where('delivery_zones', '!=', '[]')
            ->when($search, function ($query) use ($search) {
                return $query->where('name', 'like', '%' . $search . '%');
            })
            ->select('id', 'name', 'email', 'profile_image', 'delivery_zones')
            ->paginate($perPage);

        // Decode JSON for each supplier in paginated result
        $suppliers->getCollection()->transform(function ($supplier) {
            $supplier->delivery_zones = json_decode($supplier->delivery_zones, true);
            return $supplier;
        });

        return response()->json($suppliers);
    }

}


------------------------------------------------------------
FILE: Http/Middleware/AuthMiddleware.php
------------------------------------------------------------
<?php
// app/Http/Middleware/AuthMiddleware.php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Auth;

class AuthMiddleware
{
    public function handle(Request $request, Closure $next): Response
    {
        $path = $request->path();
        $isAuthenticated = Auth::check();
        
        Log::info('AuthMiddleware Debug', [
            'path' => $path,
            'authenticated' => $isAuthenticated,
            'user_id' => $isAuthenticated ? Auth::id() : null,
            'session_id' => session()->getId(),
            'cookie_received' => $request->cookie(config('session.cookie'))
        ]);

        // Public routes that don't require authentication
        $publicRoutes = ['login', 'register', 'login-submit', 'register-submit', 'logout', '', 'debug-auth', 'debug-sessions', 'reset-sessions', 'debug-session-full'];
        
        // If not authenticated and trying to access protected route
        if (!$isAuthenticated && !in_array($path, $publicRoutes)) {
            Log::warning('Redirecting to login - not authenticated', [
                'session_match' => $request->cookie(config('session.cookie')) === session()->getId()
            ]);
            return redirect()->route('login')->withErrors(['message' => 'Please log in to access this page.']);
        }

        Log::info('Allowing request to proceed');
        return $next($request);
    }
}

------------------------------------------------------------
FILE: Http/Middleware/IsAdmin.php
------------------------------------------------------------
<?php
namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Illuminate\Http\Response;

class isAdmin
{
    /**
     * Handle an incoming request.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \Closure  $next
     * @return \Illuminate\Http\Response
     */
    public function handle(Request $request, Closure $next)
    {
        // Ensure the user is authenticated before checking role
        $user = auth()->user();
      
        if (!$user) {
            // Return an unauthorized response if the user is not authenticated
            return response()->json(['message' => 'Unauthorized'], 401);  // Explicitly returning JsonResponse, but it's fine in this context
        }

        // Check if the authenticated user is an admin
        if ($user->role !== 'admin') {
            // Return a forbidden response if the user is not an admin
            return response()->json(['message' => 'Forbidden. Admin access only.'], 403);  // Explicitly returning JsonResponse
        }

        // Allow the request to proceed to the next middleware or controller
        return $next($request);  // This is a valid return, it doesn't return a JsonResponse
    }
}


------------------------------------------------------------
FILE: Http/Middleware/IsClient.php
------------------------------------------------------------
<?php
namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Illuminate\Http\Response;
use Illuminate\Support\Facades\Auth;
class isClient
{
    /**
     * Handle an incoming request.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \Closure  $next
     * @return \Illuminate\Http\Response
     */
    public function handle(Request $request, Closure $next)
    {
        // Ensure the user is authenticated before checking role
        $user = Auth::user();
      
        if (!$user) {
            // Return an unauthorized response if the user is not authenticated
            return response()->json(['message' => 'Unauthorized'], 401);  
        }

        // Check if the authenticated user is an client
        if (Auth::user()->role !== 'client') {
            // Return a forbidden response if the user is not an client
            return response()->json(['message' => 'Forbidden. Client access only.'], 403);  // Explicitly returning JsonResponse
        }

        // Allow the request to proceed to the next middleware or controller
        return $next($request);  // This is a valid return, it doesn't return a JsonResponse
    }
}


------------------------------------------------------------
FILE: Http/Middleware/IsSupplier.php
------------------------------------------------------------
<?php
namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;

class isSupplier
{
    /**
     * Handle an incoming request.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \Closure  $next
     * @return \Illuminate\Http\Response
     */
    public function handle(Request $request, Closure $next)
    {
        // Ensure the user is authenticated before checking role
        $user = Auth::user();
      
        if (!$user) {
            // Return an unauthorized response if the user is not authenticated
            return response()->json(['message' => 'Unauthorized'], 401);  
        }

        // Check if the authenticated user is an supplier
        if (Auth::user()->role !== 'supplier') {
            // Return a forbidden response if the user is not an supplier
            return response()->json(['message' => 'Forbidden. Supplier access only.'], 403);  // Explicitly returning JsonResponse
        }

        // Allow the request to proceed to the next middleware or controller
        return $next($request);  // This is a valid return, it doesn't return a JsonResponse
    }
}


------------------------------------------------------------
FILE: Models/Category.php
------------------------------------------------------------
<?php
namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Category extends Model
{
    use HasFactory;

    protected $table = 'category';

    protected $fillable = ['name'];


    public function products()
    {
        return $this->hasMany(MasterProducts::class, 'category');
    }
}


------------------------------------------------------------
FILE: Models/Company.php
------------------------------------------------------------
<?php
namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Company extends Model
{
    use HasFactory;

    protected $table = 'companies';

    protected $fillable = ['name'];

    public function users()
    {
        return $this->hasMany(User::class);
    }
}


------------------------------------------------------------
FILE: Models/MasterProducts.php
------------------------------------------------------------
<?php
namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class MasterProducts extends Model
{
    protected $table = 'master_products';
    protected $fillable = ['product_name', 'product_type', 'specifications', 'unit_of_measure', 'tech_doc', 'photo','is_approved','added_by','approved_by', 'slug', 'category'];

    public function supplierOffers()
    {
        return $this->hasMany(SupplierOffers::class, 'master_product_id');
    }

    public function category()
    {
        return $this->belongsTo(Category::class, 'category')->select('id', 'name');
    }

    public function added_by()
    {
        return $this->belongsTo(User::class, 'added_by')->select('id', 'name', 'email','profile_image');
    }

    // Relationship with the user who approved the product
    public function approved_by()
    {
        return $this->belongsTo(User::class, 'approved_by')->select('id', 'name', 'email','profile_image');
    }
}


------------------------------------------------------------
FILE: Models/OrderItem.php
------------------------------------------------------------
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\{BelongsTo};

class OrderItem extends Model
{
    protected $table = 'order_items';

    protected $fillable = [
        'order_id',
        'product_id',
        'quantity',
        'supplier_id',
        'custom_blend_mix',
        'supplier_unit_cost',
        'supplier_delivery_cost',
        'supplier_discount',
        'supplier_delivery_date',
        'choosen_offer_id',
        'suppier_notes',
        'supplier_confirms',
        'is_paid',
    ];

    protected $casts = [
        'quantity'               => 'decimal:2',
        'supplier_unit_cost'     => 'decimal:2',
        'supplier_delivery_cost' => 'decimal:2',
        'supplier_discount'      => 'decimal:2',
        'supplier_confirms'      => 'boolean',
        'is_paid'                => 'boolean',
        'supplier_delivery_date' => 'datetime',

    ];

    // Relations
    public function order(): BelongsTo
    {
        return $this->belongsTo(Orders::class, 'order_id');
    }

    public function product(): BelongsTo
    {
        return $this->belongsTo(MasterProducts::class, 'product_id');
    }

    public function supplier(): BelongsTo
    {
        return $this->belongsTo(User::class, 'supplier_id');
    }

    public function chosenOffer(): BelongsTo
    {
        return $this->belongsTo(SupplierOffers::class, 'choosen_offer_id');
    }
}


------------------------------------------------------------
FILE: Models/Orders.php
------------------------------------------------------------
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\{BelongsTo, HasMany, HasManyThrough};

class Orders extends Model
{
    protected $table = 'orders';

    protected $fillable = [
        'po_number',
        'client_id',
        'project_id',
        'delivery_address',
        'delivery_lat',
        'delivery_long',
        'delivery_date',
        'delivery_time',
        'delivery_window',
        'delivery_method',
        'load_size',
        'special_equipment',
        'subtotal',
        'fuel_levy',
        'other_charges',
        'gst_tax',
        'discount',
        'total_price',
        'supplier_cost',
        'customer_cost',
        'payment_status',
        'order_status',
        'workflow',
        'reason',
        'repeat_order',
        'generate_invoice',
        'order_process',
        'special_notes',
        'supplier_paid_ids',
    ];

    protected $casts = [
        'delivery_date'     => 'datetime',
        'delivery_time'     => 'datetime:H:i:s',
        'delivery_lat'      => 'float',
        'delivery_long'     => 'float',
        'subtotal'          => 'decimal:2',
        'fuel_levy'         => 'decimal:2',
        'other_charges'     => 'decimal:2',
        'gst_tax'           => 'decimal:2',
        'discount'          => 'decimal:2',
        'total_price'       => 'decimal:2',
        'supplier_cost'     => 'decimal:2',
        'customer_cost'     => 'decimal:2',
        'admin_margin'      => 'decimal:2',
        'repeat_order'      => 'boolean',
        'generate_invoice'  => 'boolean',
    ];

    // Enums as constants (optional helpers)
    public const PAYMENT_STATUS = ['Pending','Paid','Partially Paid','Partial Refunded','Refunded','Requested'];
    public const ORDER_STATUS   = ['In-Progress','Completed','Cancelled'];
    public const DELIVERY_WINDOW = ['Morning','Afternoon','Evening'];
    public const DELIVERY_METHOD = ['Other','Tipper','Agitator','Pump','Ute'];
    public const ORDER_PROCESS   = ['Automated','Action Required'];
    public const WORKFLOW        = ['Requested','Supplier Missing','Supplier Assigned','Payment Requested','On Hold','Delivered'];

    // Relations
    public function client(): BelongsTo
    {
        return $this->belongsTo(User::class, 'client_id');
    }

    public function project(): BelongsTo
    {
        return $this->belongsTo(Projects::class, 'project_id');
    }

    public function items(): HasMany
    {
        return $this->hasMany(OrderItem::class, 'order_id');
    }

    // Convenience: unique suppliers on this order
    public function suppliers(): HasManyThrough
    {
        return $this->hasManyThrough(
            User::class,
            OrderItem::class,
            'order_id',   // OrderItem foreign key...
            'id',         // User local key
            'id',         // Order local key
            'supplier_id' // OrderItem supplier key
        )->whereNotNull('order_items.supplier_id')->distinct();
    }

    // Scopes
    public function scopeForClient($q, int $clientId) { return $q->where('client_id', $clientId); }
    public function scopeStatus($q, string $status)   { return $q->where('order_status', $status); }
}


------------------------------------------------------------
FILE: Models/Projects.php
------------------------------------------------------------
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;


class Projects extends Model
{
    use HasFactory;

    // Define the table associated with the model
    protected $table = 'projects';

    // Define the fields that are mass assignable
    protected $fillable = [
        'name',
        'site_contact_name',
        'site_contact_phone',
        'site_instructions',
        'added_by',
    ];

    // Define the relationship to the User model
    public function added_by()
    {
        return $this->belongsTo(User::class, 'added_by')->select('id','name','email','profile_image');  // 'added_by' is the foreign key
    }
}


------------------------------------------------------------
FILE: Models/SupplierOffers.php
------------------------------------------------------------
<?php
namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class SupplierOffers extends Model
{
    protected $table = 'supplier_offers';
    protected $fillable = ['supplier_id', 'master_product_id', 'price', 'availability_status', 'status'];

    public function masterProduct()
    {
        return $this->belongsTo(MasterProducts::class);
    }

    public function supplier()
    {
        return $this->belongsTo(User::class, 'supplier_id')
            ->select('id', 'name', 'email', 'profile_image', 'delivery_zones')
            ->withCasts(['delivery_zones' => 'array']);
    }
}


------------------------------------------------------------
FILE: Models/User.php
------------------------------------------------------------
<?php

namespace App\Models;

use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Laravel\Sanctum\HasApiTokens; 


class User extends Authenticatable
{
    use HasFactory, Notifiable, HasApiTokens;

    protected $fillable = [
        'name',
        'email',
        'password',
        'role',
        'company_id',
        'contact_name',
        'contact_number',
        'location',
        'lat',
        'long',
        'delivery_radius',
        'shipping_address',
        'billing_address',
        'client_public_id',
        'profile_image',
        'isDeleted',
        'notes',
        'delivery_zones',
    ];

    protected $hidden = ['password', 'remember_token'];
    protected $casts = [
        'isDeleted' => 'boolean',
        'lat' => 'float',
        'long' => 'float',
    ];

    public function company()
    {
        return $this->belongsTo(Company::class);
    }

    public function projects()
    {
        return $this->hasMany(Projects::class, 'added_by');  // 'added_by' is the foreign key
    }

    public function supplierOffers()
    {
        return $this->hasMany(SupplierOffers::class, 'supplier_id'); // 'supplier_id' is the foreign key in SupplierOffer
    }
}


------------------------------------------------------------
FILE: Providers/AppServiceProvider.php
------------------------------------------------------------
<?php

namespace App\Providers;

use Illuminate\Support\ServiceProvider;

class AppServiceProvider extends ServiceProvider
{
    /**
     * Register any application services.
     */
    public function register(): void
    {
        //
    }

    /**
     * Bootstrap any application services.
     */
    public function boot(): void
    {
        //
    }
}

