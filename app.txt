LARAVEL VIEWS CONVERSION
Generated: 2025-11-04 05:39:21
Project: C:\material-connect
================================================================================


------------------------------------------------------------
FILE: Http/Controllers/Admin/DashboardController.php
------------------------------------------------------------
<?php

namespace App\Http\Controllers\Admin;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;
use Illuminate\Support\Str;
use App\Models\Orders;
use App\Models\OrderItem;
use App\Models\User;
use App\Models\MasterProducts;
use DateTimeZone;
use DateTime;
use Carbon\Carbon;

class DashboardController extends Controller
{
    public function summary(Request $r)
    {
        $from = $r->date('from') ?? now()->startOfMonth();
        $to   = $r->date('to')   ?? now();
        $gran = $r->get('granularity', 'day');
        $tz   = $r->get('tz', 'Australia/Sydney');

        // Calculate previous period for comparison
        $periodDays = $from->diffInDays($to);
        $prevFrom = (clone $from)->subDays($periodDays + 1);
        $prevTo = (clone $from)->subDay();

        // Base scope for current period - FIXED: Use created_at
        $orders = Orders::query()
            ->when($r->client_id, fn($q, $v) => $q->where('client_id', $v))
            ->when($r->project_id, fn($q, $v) => $q->where('project_id', $v))
            ->when($r->workflow, fn($q, $v) => $q->where('workflow', $v))
            ->when($r->payment_status, fn($q, $v) => $q->where('payment_status', $v))
            ->when($r->delivery_method, fn($q, $v) => $q->where('delivery_method', $v))
            ->whereBetween('created_at', [$from, $to]); // FIXED

        // Base scope for previous period (for comparison) - FIXED: Use created_at
        $prevOrders = Orders::query()
            ->when($r->client_id, fn($q, $v) => $q->where('client_id', $v))
            ->when($r->project_id, fn($q, $v) => $q->where('project_id', $v))
            ->when($r->workflow, fn($q, $v) => $q->where('workflow', $v))
            ->when($r->payment_status, fn($q, $v) => $q->where('payment_status', $v))
            ->when($r->delivery_method, fn($q, $v) => $q->where('delivery_method', $v))
            ->whereBetween('created_at', [$prevFrom, $prevTo]); // FIXED

        // KPIs - Current Period
        $ordersTotal = (int) (clone $orders)->count();
        $revenue = (float) (clone $orders)->whereIn('workflow',['Payment Requested','Delivered'])->sum('total_price');
        $awaitingPayment = (int) (clone $orders)->whereIn('payment_status', ['Pending', 'Requested'])->count();
        $supplierMissing = (int) (clone $orders)->where('workflow', 'Supplier Missing')->count();
        $completedOrders = (int) (clone $orders)->where('workflow', 'Delivered')->count();
        $avgOrderValue = $ordersTotal > 0 ? round($revenue / $ordersTotal, 2) : 0;
        $activeClients = (int) (clone $orders)->distinct('client_id')->count('client_id');
        
        // Get active suppliers from order items
        $orderIds = (clone $orders)->pluck('id');
        $activeSuppliers = OrderItem::whereIn('order_id', $orderIds)
            ->whereNotNull('supplier_id')
            ->distinct('supplier_id')
            ->count('supplier_id');

        // KPIs - Previous Period
        $ordersTotalPrev = (int) (clone $prevOrders)->count();
        $revenuePrev = (float) (clone $prevOrders)->sum('total_price');
        $completedOrdersPrev = (int) (clone $prevOrders)->where('workflow', 'Delivered')->count();
        $activeClientsPrev = (int) (clone $prevOrders)->distinct('client_id')->count('client_id');

        // Calculate percentage changes
        $ordersChange = $this->calculatePercentageChange($ordersTotal, $ordersTotalPrev);
        $revenueChange = $this->calculatePercentageChange($revenue, $revenuePrev);
        $completedChange = $this->calculatePercentageChange($completedOrders, $completedOrdersPrev);
        $clientsChange = $this->calculatePercentageChange($activeClients, $activeClientsPrev);

        // Total counts (not period-specific)
        $totalClients = User::where('role', 'client')->count();
        $totalSuppliers = User::where('role', 'supplier')->whereIn('status', ['approved', 'active'])->count();
        $pendingSuppliers = User::where('role', 'supplier')->where('status', 'pending')->count();

        // Performance metrics
        $cancelledOrders = (int) (clone $orders)->where('order_status', 'Cancelled')->count();
        $cancellationRate = $ordersTotal > 0 ? round(($cancelledOrders / $ordersTotal) * 100, 2) : 0;

        // Repeat client rate - FIXED: Use created_at
        $clientsWithMultipleOrders = Orders::query()
            ->whereBetween('created_at', [$from, $to]) // FIXED
            ->selectRaw('client_id, COUNT(*) as order_count')
            ->groupBy('client_id')
            ->having('order_count', '>', 1)
            ->count();
        $repeatClientRate = $activeClients > 0 ? round(($clientsWithMultipleOrders / $activeClients) * 100, 2) : 0;

        $kpis = [
            // Primary metrics
            'orders_total' => $ordersTotal,
            'orders_total_prev' => $ordersTotalPrev,
            'orders_change' => $ordersChange,
            
            'revenue' => $revenue,
            'revenue_prev' => $revenuePrev,
            'revenue_change' => $revenueChange,
            
            'avg_order_value' => $avgOrderValue,
            
            'completed_orders' => $completedOrders,
            'completed_orders_prev' => $completedOrdersPrev,
            'completed_change' => $completedChange,
            
            // Activity metrics
            'active_clients' => $activeClients,
            'active_clients_prev' => $activeClientsPrev,
            'active_clients_change' => $clientsChange,
            
            'active_suppliers' => $activeSuppliers,
            
            // Alerts & Actions
            'awaiting_payment' => $awaitingPayment,
            'supplier_missing' => $supplierMissing,
            'pending_supplier_approvals' => $pendingSuppliers,
            
            // Performance
            'cancellation_rate' => $cancellationRate,
            'repeat_client_rate' => $repeatClientRate,
            
            // System totals
            'total_clients' => $totalClients,
            'total_suppliers' => $totalSuppliers,
        ];

        // Which charts to build
        $want = collect(explode(',', $r->get('charts', 'date,supplier,product,price_bucket,status')))
            ->map(fn($x) => trim($x))->filter()->values();

        $charts = [];

        // 1) Date revenue & order count - FIXED: Use created_at in date formatting
        if ($want->contains('date')) {
            $bucket = match ($gran) {
                'week'  => "DATE_FORMAT(CONVERT_TZ(created_at, '+00:00', '{$this->offset($tz)}'), '%x-%v')", // FIXED
                'month' => "DATE_FORMAT(CONVERT_TZ(created_at, '+00:00', '{$this->offset($tz)}'), '%Y-%m')", // FIXED
                default => "DATE(CONVERT_TZ(created_at, '+00:00', '{$this->offset($tz)}'))", // FIXED
            };

            $rows = (clone $orders)
                ->selectRaw("$bucket AS bucket, COUNT(*) AS orders, SUM(total_price) AS revenue")
                ->groupBy('bucket')->orderBy('bucket')->get();

            $charts[] = [
                'id'       => 'time_revenue',
                'title'    => 'Revenue & Orders Over Time',
                'group_by' => 'date',
                'labels'   => $rows->pluck('bucket')->values(),
                'series'   => [
                    ['name' => 'Revenue', 'data' => $rows->pluck('revenue')->map(fn($v) => (float)$v)->values()],
                    ['name' => 'Orders', 'data' => $rows->pluck('orders')->map(fn($v) => (int)$v)->values()],
                ],
            ];
        }

        // 2) Order status distribution
        if ($want->contains('status')) {
            $statusDist = (clone $orders)
                ->selectRaw('workflow, COUNT(*) AS count')
                ->groupBy('workflow')
                ->orderByDesc('count')
                ->get();

            $charts[] = [
                'id'       => 'order_status',
                'title'    => 'Order Status Distribution',
                'group_by' => 'status',
                'type'     => 'donut',
                'labels'   => $statusDist->pluck('workflow')->values(),
                'series'   => $statusDist->pluck('count')->map(fn($v) => (int)$v)->values(),
            ];
        }

        // 3) Supplier revenue - FIXED: Use created_at
        if ($want->contains('supplier')) {
            // Get orders that have at least one supplier assigned
            $supplierRevenue = OrderItem::query()
            ->join('orders', 'orders.id', '=', 'order_items.order_id')
            ->whereBetween('orders.created_at', [$from, $to])
            ->whereIn('orders.workflow', ['Payment Requested', 'Delivered'])
            ->whereNotNull('order_items.supplier_id')
            ->when($r->supplier_id, fn($q, $v) => $q->where('order_items.supplier_id', $v))
            ->selectRaw('
                order_items.supplier_id AS supplier_id,
                SUM(
                    (COALESCE(order_items.supplier_unit_cost,0) * COALESCE(order_items.quantity,0))
                    + COALESCE(order_items.supplier_delivery_cost,0)
                    - COALESCE(order_items.supplier_discount,0)
                ) AS revenue
            ')
            ->groupBy('order_items.supplier_id')
            ->orderByDesc('revenue')
            ->limit(10)
            ->get()
            ->map(fn($r) => [
                'supplier_id' => (int) $r->supplier_id,
                'revenue'     => (float) $r->revenue,
            ])
            ->values();

            $supplierIds = $supplierRevenue->pluck('supplier_id');
            $supplierNames = User::whereIn('id', $supplierIds)->pluck('name', 'id');

            $charts[] = [
                'id'       => 'supplier_revenue',
                'title'    => 'Top Suppliers by Revenue',
                'group_by' => 'supplier',
                'labels'   => $supplierRevenue->map(fn($r) => $supplierNames[$r['supplier_id']] ?? '#'.$r['supplier_id'])->values(),
                'series'   => [[
                    'name' => 'Revenue',
                    'data' => $supplierRevenue->pluck('revenue')->map(fn($v) => round((float)$v, 2))->values(),
                ]],
            ];
        }

        // 4) Product mix - FIXED: Use created_at
        if ($want->contains('product')) {
            $productRevenue = OrderItem::query()
                ->join('orders', 'orders.id', '=', 'order_items.order_id')
                ->join('master_products', 'master_products.id', '=', 'order_items.product_id')
                ->whereBetween('orders.created_at', [$from, $to]) // FIXED
                ->when($r->product_id, fn($q, $v) => $q->where('order_items.product_id', $v))
                ->selectRaw('
                    order_items.product_id,
                    master_products.product_name,
                    COUNT(DISTINCT orders.id) AS order_count,
                    SUM(orders.total_price) / COUNT(DISTINCT orders.id) AS avg_revenue
                ')
                ->groupBy('order_items.product_id', 'master_products.product_name')
                ->orderByDesc('order_count')
                ->limit(10)
                ->get();

            $charts[] = [
                'id'       => 'product_revenue',
                'title'    => 'Top Products by Order Count',
                'group_by' => 'product',
                'labels'   => $productRevenue->pluck('product_name')->values(),
                'series'   => [[
                    'name' => 'Orders',
                    'data' => $productRevenue->pluck('order_count')->map(fn($v) => (int)$v)->values(),
                ]],
            ];
        }

        // 5) Price buckets
        if ($want->contains('price_bucket')) {
            $b = $this->parseBuckets($r->get('buckets', '0-500,500-1000,1000-2000,2000-5000,5000+'));
            $dist = $this->bucketizePrices($orders, $b);
            $charts[] = [
                'id'       => 'price_dist',
                'title'    => 'Order Value Distribution',
                'group_by' => 'price_bucket',
                'type'     => 'bar',
                'labels'   => array_keys($dist),
                'series'   => [['name' => 'Orders', 'data' => array_values($dist)]],
            ];
        }

        // TABLES

        // Top clients by spend
        $topClients = Orders::query()
            ->join('users as u', 'orders.client_id', '=', 'u.id')
            ->whereBetween('orders.created_at', [$from, $to]) // FIX: Specify orders.created_at
            ->selectRaw('
                orders.client_id,
                u.name AS client_name,
                u.email AS client_email,
                COUNT(orders.id) AS order_count,
                SUM(orders.total_price) AS total_spend
            ')
            ->groupBy('orders.client_id', 'u.name', 'u.email')
            ->orderByDesc('total_spend')
            ->limit(10)
            ->get()
            ->map(fn($r) => [
                'client_id' => $r->client_id,
                'client_name' => $r->client_name,
                'client_email' => $r->client_email,
                'order_count' => (int) $r->order_count,
                'total_spend' => (float) $r->total_spend,
            ])
            ->values();

        // Top suppliers by order count and revenue share - FIXED: Use created_at
        $topSuppliers = OrderItem::query()
        ->join('orders', 'orders.id', '=', 'order_items.order_id')
        ->join('users', 'users.id', '=', 'order_items.supplier_id')
        ->whereBetween('orders.created_at', [$from, $to])
        ->whereIn('orders.workflow', ['Payment Requested', 'Delivered']) // confirm exact values
        ->whereNotNull('order_items.supplier_id')
        ->selectRaw('
            order_items.supplier_id,
            users.name AS supplier_name,
            users.email AS supplier_email,
            COUNT(DISTINCT orders.id) AS order_count,
            SUM(
                (COALESCE(order_items.supplier_unit_cost,0) * COALESCE(order_items.quantity,0))
                + COALESCE(order_items.supplier_delivery_cost,0)
                - COALESCE(order_items.supplier_discount,0)
            ) AS total_revenue
        ')
        ->groupBy('order_items.supplier_id', 'users.name', 'users.email')
        ->orderByDesc('order_count')
        ->limit(10)
        ->get()
        ->map(fn($r) => [
            'supplier_id'    => $r->supplier_id,
            'supplier_name'  => $r->supplier_name,
            'supplier_email' => $r->supplier_email,
            'order_count'    => (int) $r->order_count,
            'revenue'        => (float) $r->total_revenue,
        ])
        ->values();

        // Recent activity feed (last 7 days, up to 15 items)
        $recentActivity = Orders::query()
            ->with(['client:id,name', 'project:id,name'])
            ->whereBetween('created_at', [now()->subDays(7), now()])
            ->orderBy('created_at', 'desc')
            ->limit(15)
            ->get()
            ->map(fn($order) => [
                'id' => $order->id,
                'type' => 'order_created',
                'order_id' => $order->id,
                'po_number' => $order->po_number,
                'client_name' => $order->client->name ?? 'Unknown Client',
                'project_name' => $order->project->name ?? 'N/A',
                'amount' => (float) $order->total_price,
                'workflow' => $order->workflow,
                'timestamp' => $order->created_at->toIso8601String(),
                'time_ago' => $order->created_at->diffForHumans(),
            ])
            ->values();

        // Prepare response filters
        $respFilters = [
            'from'            => $from instanceof Carbon ? $from->toDateString() : (string) $from,
            'to'              => $to instanceof Carbon ? $to->toDateString() : (string) $to,
            'granularity'     => $gran,
            'group_by'        => null,
            'metric'          => 'revenue',
            'client_id'       => $r->client_id,
            'project_id'      => $r->project_id,
            'supplier_id'     => $r->supplier_id,
            'product_id'      => $r->product_id,
            'workflow'        => $r->workflow,
            'payment_status'  => $r->payment_status,
            'delivery_method' => $r->delivery_method,
            'tz'              => $tz,
            'currency'        => 'AUD',
            'charts'          => $want->all(),
        ];

        // System alerts
        $alerts = [];
        if ($awaitingPayment > 0) {
            $alerts[] = [
                'type' => 'warning',
                'priority' => 'high',
                'message' => "{$awaitingPayment} order(s) awaiting payment",
                'action_url' => '/admin/orders?payment_status=Pending',
            ];
        }
        if ($supplierMissing > 0) {
            $alerts[] = [
                'type' => 'error',
                'priority' => 'high',
                'message' => "{$supplierMissing} order(s) missing supplier assignment",
                'action_url' => '/admin/orders?workflow=Supplier+Missing',
            ];
        }
        if ($pendingSuppliers > 0) {
            $alerts[] = [
                'type' => 'info',
                'priority' => 'medium',
                'message' => "{$pendingSuppliers} supplier(s) pending approval",
                'action_url' => '/admin/suppliers?status=pending',
            ];
        }

        return response()->json([
            'filters' => $respFilters,
            'kpis'    => $kpis,
            'charts'  => $charts,
            'tables'  => [
                'top_clients_by_spend' => $topClients,
                'top_suppliers_by_revenue' => $topSuppliers,
                'recent_activity' => $recentActivity,
            ],
            'alerts' => $alerts,
            'metadata' => [
                'generated_at' => now()->toIso8601String(),
                'data_freshness' => 'real-time',
                'total_records_analyzed' => $ordersTotal,
                'period_days' => $periodDays,
            ],
        ]);
    }

    /**
     * Calculate percentage change between current and previous values
     */
    protected function calculatePercentageChange($current, $previous): float
    {
        if ($previous == 0) {
            return $current > 0 ? 100.0 : 0.0;
        }
        return round((($current - $previous) / $previous) * 100, 2);
    }

    protected function parseBuckets(string $spec): array
    {
        $out = [];
        foreach (explode(',', $spec) as $raw) {
            $t = trim($raw);
            if ($t === '') continue;

            if (Str::endsWith($t, '+')) {
                $min = (float) rtrim($t, '+');
                $out[] = ['label' => "{$min}+", 'min' => $min, 'max' => null];
                continue;
            }

            if (preg_match('/^\s*([0-9]*\.?[0-9]+)\s*-\s*([0-9]*\.?[0-9]+)\s*$/', $t, $m)) {
                $min = (float) $m[1];
                $max = (float) $m[2];
                if ($max < $min) [$min, $max] = [$max, $min];
                $label = $min == (int)$min && $max == (int)$max ? "{$min}-{$max}" : "{$min}-{$max}";
                $out[] = ['label' => $label, 'min' => $min, 'max' => $max];
            }
        }
        usort($out, fn($a, $b) => ($a['min'] <=> $b['min']) ?: (($a['max'] ?? INF) <=> ($b['max'] ?? INF)));
        return $out;
    }

    protected function buildPriceBucketCase(array $buckets, string $column = 'total_price'): string
    {
        $cases = [];
        foreach ($buckets as $b) {
            $min = $b['min'];
            $max = $b['max'];
            $label = addslashes($b['label']);
            if (is_null($max)) {
                $cases[] = "WHEN {$column} >= {$min} THEN '{$label}'";
            } else {
                $cases[] = "WHEN {$column} >= {$min} AND {$column} < {$max} THEN '{$label}'";
            }
        }
        $cases[] = "ELSE 'Other'";
        return 'CASE ' . implode(' ', $cases) . ' END';
    }

    protected function bucketizePrices(\Illuminate\Database\Eloquent\Builder $orders, array $buckets): array
    {
        if (empty($buckets)) return [];

        $caseSql = $this->buildPriceBucketCase($buckets, 'total_price');

        $rows = (clone $orders)
            ->selectRaw("{$caseSql} AS bucket, COUNT(*) AS cnt")
            ->groupBy('bucket')
            ->pluck('cnt', 'bucket');

        $ordered = [];
        foreach ($buckets as $b) {
            $label = $b['label'];
            $ordered[$label] = (int) ($rows[$label] ?? 0);
        }
        if (isset($rows['Other'])) $ordered['Other'] = (int)$rows['Other'];

        return $ordered;
    }

    protected function offset(string $tz): string
    {
        try {
            $zone = new DateTimeZone($tz);
        } catch (\Exception $e) {
            $zone = new DateTimeZone('UTC');
        }
        $now = new DateTime('now', $zone);
        $offset = $zone->getOffset($now) / 3600;
        $sign = $offset >= 0 ? '+' : '-';
        $hours = str_pad(abs((int)$offset), 2, '0', STR_PAD_LEFT);
        $minutes = str_pad(abs(($offset * 60) % 60), 2, '0', STR_PAD_LEFT);
        return "{$sign}{$hours}:{$minutes}";
    }
}


------------------------------------------------------------
FILE: Http/Controllers/Admin/MasterProductsController.php
------------------------------------------------------------
<?php

namespace App\Http\Controllers\Admin;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Validator;
use Illuminate\Support\Facades\Storage;
use App\Models\MasterProducts;
use App\Models\SupplierOffers;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Str;

class MasterProductsController extends Controller
{
    /**
     * List all master products.
     */
    public function index(Request $request)
    {
        $perPage = (int) $request->get('per_page', 10);
        $page = (int) $request->get('page', 1);

        $query = MasterProducts::with(['added_by', 'approved_by', 'category']);

        // Apply filters
        if ($request->filled('search')) {
            $search = $request->get('search');
            $query->where('product_name', 'like', "%{$search}%");
        }

        if ($request->filled('category')) {
            $query->where('category', $request->get('category'));
        }

        if ($request->filled('is_approved')) {
            $query->where('is_approved', $request->get('is_approved'));
        }

        // Paginate after filters
        $products = $query->paginate($perPage, ['*'], 'page', $page);

        // Append supplier offers count
        $products->getCollection()->transform(function ($product) {
            $product->supplierOffersCount = SupplierOffers::where('master_product_id', $product->id)->count();
            return $product;
        });

        return response()->json($products, 200);
    }


    /**
     * Show a specific master product.
     */
    public function show($id)
    {
        $product = MasterProducts::with(['added_by', 'approved_by', 'category'])->find($id);
        $product->supplierOffers = SupplierOffers::with('supplier')->where('master_product_id', $product->id)->get();

        if (!$product) {
            return response()->json(['error' => 'Product not found'], 404);
        }

        return response()->json($product, 200);
    }

    /**
     * Create a new master product.
     */
    public function store(Request $request)
    {
        $validator = Validator::make($request->all(), [
            'product_name' => 'required|string|max:255|unique:master_products,product_name',
            'product_type' => 'required|string|max:255',
            'specifications' => 'nullable|string',
            'unit_of_measure' => 'nullable|string|max:100',
            'tech_doc' => 'nullable|file|mimes:pdf,docx,xlsx',
            'photo' => 'nullable|image|mimes:jpeg,png,jpg,gif|max:2048',
            'is_approved' => 'boolean',
            'category' => 'nullable|string|max:255|exists:category,id'
        ]);

        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 400);
        }

        $techDocPath = null;
        if ($request->hasFile('tech_doc') && $request->file('tech_doc')->isValid()) {
            $techDocPath = $request->file('tech_doc')->store('tech_docs', 'public');
        }

        $photoPath = null;
        if ($request->hasFile('photo') && $request->file('photo')->isValid()) {
            $photoPath = $request->file('photo')->store('product_photos', 'public');
        }

        $approverId = null;
        if ($request->is_approved) {
            $approverId = Auth::id();
        }

        $product = MasterProducts::create([
            'product_name' => $request->product_name,
            'product_type' => $request->product_type,
            'specifications' => $request->specifications,
            'unit_of_measure' => $request->unit_of_measure,
            'tech_doc' => $techDocPath,
            'photo' => $photoPath,
            'added_by' => Auth::id(),
            'is_approved' => $request->is_approved ?? false,
            'approved_by' => $approverId,
            'slug' => Str::slug($request->product_name) . '-' . Str::random(6),
            'category' => $request->category,
        ]);

        return response()->json(['message' => 'Product created successfully', 'product' => $product], 201);
    }

    /**
     * Update a master product.
     */
    public function update(Request $request, $id)
    {
        $product = MasterProducts::find($id);

        if (!$product) {
            return response()->json(['error' => 'Product not found'], 404);
        }

        $validator = Validator::make($request->all(), [
            'product_name' => 'sometimes|required|string|max:255',
            'product_type' => 'sometimes|required|string|max:255',
            'specifications' => 'nullable|string',
            'unit_of_measure' => 'nullable|string|max:100',
            'tech_doc' => 'nullable|file|mimes:pdf,docx,xlsx',
            'photo' => 'nullable|image|mimes:jpeg,png,jpg,gif|max:2048',
            'is_approved' => 'boolean',
            'category' => 'nullable|string|max:255|exists:category,id'
        ]);

        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 400);
        }

        if ($request->hasFile('tech_doc') && $request->file('tech_doc')->isValid()) {
            if ($product->tech_doc) {
                Storage::delete('public/' . $product->tech_doc);
            }
            $product->tech_doc = $request->file('tech_doc')->store('tech_docs', 'public');
        }

        if ($request->hasFile('photo') && $request->file('photo')->isValid()) {
            if ($product->photo) {
                Storage::delete('public/' . $product->photo);
            }
            $product->photo = $request->file('photo')->store('product_photos', 'public');
        }

        if ($request->has('is_approved')) {
            if ($request->is_approved && !$product->is_approved) {
                $product->approved_by = Auth::id();
            } elseif (!$request->is_approved) {
                $product->approved_by = null;
            }
            $product->is_approved = $request->is_approved;
        }

        $product->update([
            'product_name' => $request->product_name ?? $product->product_name,
            'product_type' => $request->product_type ?? $product->product_type,
            'specifications' => $request->specifications ?? $product->specifications,
            'unit_of_measure' => $request->unit_of_measure ?? $product->unit_of_measure,
            'slug' => $request->product_name ? Str::slug($request->product_name) . '-' . Str::random(6) : $product->slug,
            'is_approved' => $product->is_approved,
            'approved_by' => $product->approved_by,
            'category' => $request->category ?? $product->category,
            'tech_doc' => $product->tech_doc,
            'photo' => $product->photo,
        ]);

        return response()->json(['message' => 'Product updated successfully', 'product' => $product], 200);
    }

    /**
     * Delete a master product.
     */
    public function destroy($id)
    {
        $product = MasterProducts::find($id);

        if (!$product) {
            return response()->json(['error' => 'Product not found'], 404);
        }

        if ($product->tech_doc) {
            Storage::delete('public/' . $product->tech_doc);
        }

        if ($product->photo) {
            Storage::delete('public/' . $product->photo);
        }

        $product->delete();

        return response()->json(['message' => 'Product deleted successfully'], 200);
    }

    public function approveRejectMasterProduct($id)
    {
        $product = MasterProducts::find($id);

        if (!$product) {
            return response()->json(['error' => 'Product not found'], 404);
        }

        if($product->is_approved) {
            // If already approved, reject it
            $product->is_approved = false;
            $product->approved_by = null;
        } else {
            // If not approved, approve it
            $product->is_approved = true;
            $product->approved_by = Auth::id();
        }
        $product->save();

        return response()->json(['message' => 'Product approval status updated', 'is_approved' => $product->is_approved], 200);
        
    }

    public function approveRejectSupplierOffer(Request $request , $id)
    {
        $offer = SupplierOffers::find($id);

        if (!$offer) {
            return response()->json(['error' => 'Supplier offer not found'], 404);
        }

        $validator = Validator::make($request->all(), [
            'status' => 'required|in:Approved,Rejected,Pending',
        ]);
        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 400);
        }
        $offer->status = $request->status;
        $offer->save();

        return response()->json(['message' => 'Supplier offer approval status updated', 'status' => $offer->status], 200);
        
    }
}


------------------------------------------------------------
FILE: Http/Controllers/Admin/OrderAdminController.php
------------------------------------------------------------
<?php

namespace App\Http\Controllers\Admin;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;
use App\Models\Orders; // Adjust if your model is named Order
use App\Models\Projects;
use App\Models\OrderItem;
use App\Services\OrderPricingService;
use App\Models\SupplierOffers;
use App\Models\User; // assuming clients are users with role=client
use Illuminate\Validation\Rule;
use Illuminate\Support\Facades\Validator;
// use Pest\Configuration\Project;

class OrderAdminController extends Controller
{
    //


    public function index(Request $request)
    {
        $perPage   = (int) $request->get('per_page', 10);
        $search    = trim((string) $request->get('search', ''));
        $clientId  = $request->get('client_id');
        $projectId = $request->get('project_id');
        $supplierId= $request->get('supplier_id');
        $workflow  = $request->get('workflow');
        $payment   = $request->get('payment_status');
        $ddFrom    = $request->get('delivery_date_from');
        $ddTo      = $request->get('delivery_date_to');
        $method    = $request->get('delivery_method');
        $repeat    = $request->get('repeat_order') ?? null;
        $hasMissing= $request->get('has_missing_supplier');
        $confirms  = $request->get('supplier_confirms'); // "true"/"false" or null
        $minTotal  = $request->get('min_total');
        $maxTotal  = $request->get('max_total');
        $sort      = $request->get('sort', 'created_at');
        $dir       = strtolower($request->get('dir', 'desc')) === 'asc' ? 'asc' : 'desc';
        $details   = filter_var($request->get('details', false), FILTER_VALIDATE_BOOLEAN);

        if (!is_null($confirms)) {
            $confirms = $confirms === "true";
        }

        // Allowed sort columns (updated)
        $sortMap = [
            'po_number'      => 'po_number',
            'delivery_date'  => 'delivery_date',
            'created_at'     => 'created_at',
            'updated_at'     => 'updated_at',
            'total_price'    => 'total_price',          // use this instead of customer_cost/total
            'profit_amount'  => 'profit_amount',        // actual profit amount column
            'profit_before_tax'    => 'profit_before_tax',
            'profit_margin_percent'=> 'profit_margin_percent',
            'items_count'    => DB::raw('items_count'),
        ];
        if (!array_key_exists($sort, $sortMap)) {
            $sort = 'created_at';
        }

        // Base query
        $query = Orders::query()
            ->with([
                'client:id,name',
                'project:id,name',
                'items:id,order_id,supplier_id,quantity,supplier_confirms'
            ])
            ->withCount([
                'items as items_count',
                'items as unassigned_items_count' => function ($q) {
                    $q->whereNull('supplier_id');
                },
            ])
            ->withCount(['items as suppliers_count' => function ($q) {
                $q->whereNotNull('supplier_id')->select(DB::raw('COUNT(DISTINCT supplier_id)'));
            }]);

        // Text search
        if ($search !== '') {
            $query->where('po_number', 'like', "%{$search}%");
        }
        if ($clientId) {
            $query->where('client_id', $clientId);
        }
        if ($projectId) {
            $query->where('project_id', $projectId);
        }
        if ($workflow) {
            $query->where('workflow', $workflow);
        }
        if ($payment) {
            $query->where('payment_status', $payment);
        }
        if ($method) {
            $query->where('delivery_method', $method);
        }
        if ($ddFrom) {
            $query->whereDate('delivery_date', '>=', $ddFrom);
        }
        if ($ddTo) {
            $query->whereDate('delivery_date', '<=', $ddTo);
        }
        if (isset($repeat) && $repeat !== '') {
            $query->where('repeat_order', filter_var($repeat, FILTER_VALIDATE_BOOLEAN) ? 1 : 0);
        }
        if ($supplierId) {
            $query->whereHas('items', function ($q) use ($supplierId) {
                $q->where('supplier_id', $supplierId);
            });
        }
        if ($hasMissing) {
            $query->whereHas('items', function ($q) {
                $q->whereNull('supplier_id');
            });
        }
        if (!is_null($confirms)) {
            $query->whereHas('items', function ($q) use ($confirms) {
                $q->where('supplier_confirms', $confirms);
            });
        }

        // Totals filter now uses total_price only
        if ($minTotal !== null) {
            $query->where('total_price', '>=', $minTotal);
        }
        if ($maxTotal !== null) {
            $query->where('total_price', '<=', $maxTotal);
        }

        // Sorting
        if ($sort === 'items_count') {
            $query->orderBy('items_count', $dir);
        } else {
            $query->orderBy($sortMap[$sort], $dir);
        }

        $paginator = $query->paginate($perPage);

        // Transform rows
        $data = $paginator->getCollection()->map(function (Orders $o) {
            $total  = (float)($o->total_price ?? 0);
            $profit = (float)($o->profit_amount ?? $o->profit_amount ?? 0);

            $orderInfo = null;
            if ($o->workflow === 'Supplier Missing' && $o->unassigned_items_count > 0) {
                $orderInfo = 'Supplier missing for ' . $o->unassigned_items_count . ' items';
            } elseif ($o->workflow === 'Supplier Assigned') {
                $orderInfo = 'Waiting for suppliers to confirm';
            } elseif ($o->workflow === 'Payment Requested') {
                $orderInfo = 'Awaiting client payment';
            }
          
            //claude
            return [
                'id'                       => $o->id,
                'po_number'                => $o->po_number,
                'client'                   => optional($o->client)->name,
                'project'                  => optional($o->project)->name,
                'delivery_date'            => $o->delivery_date,
                'delivery_time'            => $o->delivery_time,
                'delivery_method'          => $o->delivery_method,
                'workflow'                 => $o->workflow,
                'payment_status'           => $o->payment_status,
                'order_process'            => $o->order_process,
                'items_count'              => $o->items_count,
                'unassigned_items_count'   => $o->unassigned_items_count,
                'suppliers_count'          => $o->suppliers_count ?? 0,
                
                // NEW: Supplier costs
                'supplier_item_cost'       => round((float)($o->supplier_item_cost ?? 0), 2),
                'supplier_delivery_cost'   => round((float)($o->supplier_delivery_cost ?? 0), 2),
                'supplier_total'           => round((float)($o->supplier_item_cost ?? 0) + (float)($o->supplier_delivery_cost ?? 0), 2),
                
                // NEW: Customer costs
                'customer_item_cost'       => round((float)($o->customer_item_cost ?? 0), 2),
                'customer_delivery_cost'   => round((float)($o->customer_delivery_cost ?? 0), 2),
                
                'total_price'              => round($total, 2),
                'profit_amount'            => round($profit, 2),
                'profit_margin_percent'    => round((float)($o->profit_margin_percent ?? 0), 4),
                
                // NEW: Other charges
                'gst_tax'                  => round((float)($o->gst_tax ?? 0), 2),
                'discount'                 => round((float)($o->discount ?? 0), 2),
                'other_charges'            => round((float)($o->other_charges ?? 0), 2),
                
                'order_info'               => $orderInfo,
                'repeat_order'             => $o->repeat_order,
                'created_at'               => $o->created_at,
                'updated_at'               => $o->updated_at,
            ];
        });

        // Metrics
        $base = Orders::query();
        $metrics = [
            'total_orders_count'     => (clone $base)->count(),
            'supplier_missing_count' => (clone $base)->where('workflow', 'Supplier Missing')->count(),
            'supplier_assigned_count'=> (clone $base)->where('workflow', 'Supplier Assigned')->count(),
            'awaiting_payment_count' => (clone $base)->where('workflow', 'Payment Requested')->count(),
            'delivered_count'        => (clone $base)->where('workflow', 'Delivered')->count(),
        ];

        $response = [
            'data' => $data,
            'pagination' => [
                'per_page'       => $paginator->perPage(),
                'current_page'   => $paginator->currentPage(),
                'total_pages'    => $paginator->lastPage(),
                'total_items'    => $paginator->total(),
                'has_more_pages' => $paginator->hasMorePages(),
            ],
            'metrics' => $metrics,
        ];

        if ($details) {
            $response['filters'] = [
                'clients'          => User::query()->where('role', 'client')->select('id','name','profile_image')->orderBy('name')->get(),
                'suppliers'        => User::where('role','supplier')->select('id','name','profile_image')->orderBy('name')->get(),
                'projects'         => Projects::query()->select('id','name')->orderBy('name')->get(),
                'workflows'        => ['Requested','Supplier Missing','Supplier Assigned','Payment Requested','On Hold','Delivered'],
                'payment_statuses' => ['Pending','Requested','Paid','Partially Paid','Partial Refunded','Refunded'],
                'delivery_methods' => ['Other','Tipper','Agitator','Pump','Ute'],
            ];
        }

        return response()->json($response);
    }



    public function show(Orders $order)
    {
        
        $order->load(['client:id,name', 'project:id,name', 'items.product:id,product_name']);
     
        $deliveryLat = $order->delivery_lat ?? null;   // adjust if different
        $deliveryLng = $order->delivery_long ?? null;
        // dd($order->project->id);
        $filters['projects'] = Projects::where('added_by', $order->client_id)->where('id', '!=', $order->project->id)->get();
        

        $payload = [
            //Order Details For Display (Not Changeable)
            'id' => $order->id,
            'po_number' => $order->po_number,
            'client' => optional($order->client)->name,
            'project' => optional($order->project)->name,
            'delivery_address' => $order->delivery_address,
            'delivery_lat'=>$order->delivery_lat,
            'delivery_long'=> $order->delivery_long,
            'delivery_date' => $order->delivery_date,
            'delivery_time' => $order->delivery_time,
            'delivery_window'=> $order->delivery_window,
            'delivery_mehtod' => $order->delivery_mehtod,
            'load_size'=> $order->load_size,
            'special_equipment'=> $order->special_equipment,
            'repeat_order'=> (int) $order->repeat_order,
            'order_process'=> $order->order_process,
                //status
            'workflow' => $order->workflow,
            'payment_status' => $order->payment_status,
            'order_status' => $order->order_status,

            'gst_tax'=> round((float)$order->gst_tax),
            'discount'=>round((float)$order->discount),
            'other_charges'=>round((float)$order->other_charges),
            'total_price'=>round((float)$order->total_price),
            'customer_item_cost'=>round((float)$order->customer_item_cost),
            'customer_delivery_cost'=>round((float)$order->customer_delivery_cost),
            'supplier_item_cost'=>round((float)$order->supplier_item_cost),
            'supplier_delivery_cost'=>round((float)$order->supplier_delivery_cost),
            'profit_margin_percent'=>round((float)$order->profit_margin_percent),
            'profit_amount'=>round((float)$order->profit_amount),
            'items' => [],
            'filters'=>$filters
        ];

        // If not Supplier Missing, return items without eligibility calc
        if ($order->workflow !== 'Supplier Missing') {
            
            foreach ($order->items as $it) {
            //    dd($it->is_quoted);
                $payload['items'][] = [
                    'id' => $it->id,
                    'product_id' => $it->product_id,
                    'product_name' => optional($it->product)->product_name,
                    'quantity' => $it->quantity,
                    'supplier' => $it->supplier,
                    'choosen_offer_id' => $it->choosen_offer_id ?? null,
                    'supplier_confirms' => $it->supplier_confirms,
                    'supplier_unit_cost' => $it->supplier_unit_cost,
                    'delivery_cost' => $it->delivery_cost,
                    'supplier_discount' => $it->supplier_discount,
                    'delivery_type'=>$it->delivery_type,
                    'is_quoted'         => (int) $it->is_quoted,
                    'is_paid' => (int) $it->is_paid,
                    'quoted_price'=>$it->quoted_price,
                    'eligible_suppliers' => [],
                ];
            }
            return response()->json(['data' => $payload]);
        }

        $canComputeDistance = is_numeric($deliveryLat) && is_numeric($deliveryLng);

        // preload offers for all products on this order
        $masterIds = $order->items->pluck('product_id')->filter()->unique()->values();

        $offersByProduct = SupplierOffers::query()
            ->whereIn('master_product_id', $masterIds)
            ->with(['supplier:id,name,role,delivery_zones'])
            ->get()
            ->groupBy('master_product_id');
     
        foreach ($order->items as $it) {
            // already assigned → just echo item info
            if (!is_null($it->supplier_id)) {
                // dd($it);
                $payload['items'][] = [
                    'id' => $it->id,
                    'product_id' => $it->product_id,
                    'product_name' => optional($it->product)->product_name,
                    'quantity' => $it->quantity,
                    'supplier' => $it->supplier()->select('id','name','profile_image','delivery_zones')->first(),
                    'choosen_offer_id' => $it->choosen_offer_id ?? null,
                    'supplier_confirms' => $it->supplier_confirms,
                    'supplier_unit_cost' => $it->supplier_unit_cost,
                    'delivery_cost' => $it->delivery_cost,
                    'supplier_discount' => $it->supplier_discount,
                    'delivery_type'=>$it->delivery_type,
                    'is_quoted'         => (int) $it->is_quoted,
                    'is_paid' => (int) $it->is_paid,
                    'quoted_price'=>$it->quoted_price,
                    'eligible_suppliers' => [],
                ];
                continue;
            }

            // unassigned → build eligible_suppliers
            $eligible = [];
            $productOffers = $offersByProduct->get($it->product_id, collect());

            foreach ($productOffers as $offer) {
                $supplier = $offer->supplier; // users table row
                if (!$supplier) continue;
                if (strtolower((string)$supplier->role) !== 'supplier') continue;

                if (empty($supplier->delivery_zones)) continue; // must not be null/empty
                $zones = is_array($supplier->delivery_zones)
                    ? $supplier->delivery_zones
                    : $this->decodeZones($supplier->delivery_zones);
                if (empty($zones)) continue;

                $distance = null;
                // dd($canComputeDistance);
                // $canComputeDistance = true;
                if ($canComputeDistance) {
                    // dd($zones, $deliveryLat, $deliveryLng);
                    $distance = $this->nearestZoneDistanceKm($zones, (float)$deliveryLat, (float)$deliveryLng);
                }

                $eligible[] = [
                    'supplier_id' => (int) $supplier->id,
                    'name'=> (string) $supplier->name,
                    'offer_id'    => (int) $offer->id,
                    'distance'    => is_null($distance) ? null : round($distance, 3),
                ];
            }

            usort($eligible, function ($a, $b) {
                if ($a['distance'] === null && $b['distance'] === null) return 0;
                if ($a['distance'] === null) return 1;
                if ($b['distance'] === null) return -1;
                return $a['distance'] <=> $b['distance'];
            });

            $payload['items'][] = [
                'id' => $it->id,
                'product_id' => $it->product_id,
                'product_name' => optional($it->product)->product_name,
                'quantity' => $it->quantity,
                'supplier_id' => $it->supplier_id,
                'eligible_suppliers' => $eligible,
            ];
        }

        return response()->json(['data' => $payload]);
    }

    public function assignSupplier(Request $request)
    {
        $v = Validator::make($request->all(), [
            'order_id' => ['required','integer','min:1'],
            'item_id'  => ['required','integer','min:1'],
            'supplier' => ['required','integer','min:1'],     // supplier_id
            'offer_id' => ['sometimes','integer','min:1'],    // optional
        ]);
        if ($v->fails()) return response()->json(['error' => $v->errors()], 422);

        $orderId    = (int) $request->order_id;
        $itemId     = (int) $request->item_id;
        $supplierId = (int) $request->supplier;
        $offerId    = $request->filled('offer_id') ? (int) $request->offer_id : null;

        return DB::transaction(function () use ($orderId, $itemId, $supplierId, $offerId) {

            /** @var Orders $order */
            $order = Orders::with('items')->lockForUpdate()->findOrFail($orderId);

            /** @var OrderItem $item */
            $item = $order->items()->whereKey($itemId)->lockForUpdate()->firstOrFail();
            if (!$item->product_id) {
                return response()->json(['error' => ['item' => ['Item has no product_id.']]], 422);
            }

            // supplier must exist and be role=supplier
            $supplier = User::find($supplierId);
            if (!$supplier || strtolower((string)$supplier->role) !== 'supplier') {
                return response()->json(['error' => ['supplier' => ['Invalid supplier.']]], 422);
            }

            // pick matching offer by supplier+product (or the explicit one)
            $offerQ = SupplierOffers::query()
                ->where('supplier_id', $supplierId)
                ->where('master_product_id', $item->product_id)
                ->where('status','Approved')
                ->whereIn('availability_status',['In Stock','Limited']);
            if ($offerId) $offerQ->whereKey($offerId);

            $offer = $offerQ->orderBy('price')->first();
            if (!$offer) {
                return response()->json(['error' => ['offer' => ['No offer for this supplier and product.']]], 422);
            }

            $unitCost         = (float)($offer->price ?? $offer->price ?? 0);
            // $supplierDiscount = (float)($offer->supplier_discount ?? $offer->discount ?? 0);

            // assign. delivery fields stay null. no confirms flag.
            $item->forceFill([
                'supplier_id'            => $supplierId,
                'choosen_offer_id'       => $offer->id,
                'supplier_unit_cost'     => round($unitCost, 2),
                'supplier_discount'      => 0.00,
                'supplier_delivery_cost' => 0.00,
                'delivery_type'          => null,
                'delivery_cost'          => 0.00,
            ])->saveOrFail();

            // if all items now have a supplier -> set workflow
            $unassignedCount = $order->items()->whereNull('supplier_id')->count();
            if ($unassignedCount === 0 && $order->workflow !== 'Supplier Assigned') {
                $order->workflow = 'Supplier Assigned';
                $order->save();
            }

            // recalc customer totals
            $order->load('items');
            OrderPricingService::recalcCustomer($order, null, null, true);

            return response()->json([
                'message' => 'Supplier assigned.',
                'order' => [
                    'id'                     => $order->id,
                    'workflow'               => $order->workflow,
                    'total_price'            => $order->total_price,
                    'profit_amount'          => $order->profit_amount,
                    'profit_margin_percent'  => $order->profit_margin_percent,
                ],
                'item' => [
                    'id'                     => $item->id,
                    'product_id'             => $item->product_id,
                    'supplier_id'            => $item->supplier_id,
                    'choosen_offer_id'       => $item->choosen_offer_id,
                    'supplier_unit_cost'     => $item->supplier_unit_cost,
                    'supplier_discount'      => $item->supplier_discount,
                    'supplier_delivery_cost' => $item->supplier_delivery_cost, // null
                    'delivery_type'          => $item->delivery_type,          // null
                    'delivery_cost'          => $item->delivery_cost,          // null
                ],
                'offer' => [
                    'id'                => $offer->id,
                    'supplier_id'       => $offer->supplier_id,
                    'master_product_id' => $offer->master_product_id,
                ],
            ]);
        });
    }


    public function adminUpdate(Request $request, Orders $order)
    {
        // only admins hit this via middleware
        $v = Validator::make($request->all(), [
            'discount'        => ['sometimes','required','numeric','min:0'],
            'is_paid'         => ['sometimes','required','boleean'],
            'item_id'         => ['sometimes','required','numeric','min:1'],  
        ]);

        if ($v->fails()) {
            return response()->json(['error' => $v->errors()], 422);
        }
        //for discount
        

        $dirty = [];

        //for discount
        if ($request->has('discount')) {
            $dirty['discount'] = (float)$request->discount;
            // Apply updates
            $order->update($dirty);

            // Refresh minimal payload
            $order->load(['project:id,name','items:id,order_id,product_id,supplier_id,supplier_delivery_date']);
            // Recalculate customer-facing totals only
            OrderPricingService::recalcCustomer($order, null, null, true);

            return response()->json([
                'success' => true,
                'message' => 'Order updated by admin',
                'order'   => $order,
            ]);
        }

        if ($request->has('item_id') && $request->has('is_paid')) {
            $item = OrderItem::find((int)$request->item_id);
            if (!$item) {
                return response()->json(['error' => 'Item not found'], 404);
            }

            $isPaid = filter_var($request->is_paid, FILTER_VALIDATE_BOOLEAN);

            $item->is_paid = $isPaid ? 1 : 0;
            $item->supplier_status = $isPaid ? 'Paid' : 'Unpaid';
            $item->save();

            return response()->json([
                'success' => true,
                'message' => $isPaid
                    ? 'Item marked as paid and supplier status set to Paid'
                    : 'Item marked as unpaid and supplier status set to Unpaid',
                'item' => $item,
            ]);
        }
        
    }


    /** Decode users.delivery_zones JSON to [['lat'=>..,'lng'=>..,'radius_km'=>?...],...] */
    private function decodeZones($json): array
    {
        try {
            $raw = is_array($json) ? $json : json_decode($json, true, 512, JSON_THROW_ON_ERROR);
        } catch (\Throwable $e) {
            return [];
        }
        $zones = [];
        foreach ((array)$raw as $z) {
            $lat = $z['lat'] ?? $z['latitude'] ?? null;
            $lng = $z['lng'] ?? $z['longitude'] ?? null;
            $rkm = $z['radius_km'] ?? $z['radius'] ?? null;
            if (is_numeric($lat) && is_numeric($lng)) {
                $zones[] = ['lat'=>(float)$lat,'lng'=>(float)$lng,'radius_km'=>is_numeric($rkm)?(float)$rkm:null];
            }
        }
        return $zones;
    }

    /** Nearest zone’s center distance in km */
    private function nearestZoneDistanceKm(array $zones, float $lat, float $lng): ?float
    {
        // dd($zones, $lat , $lng);
        $min = null;
        foreach ($zones as $z) {
            $d = $this->haversineKm($lat, $lng, $z['lat'], $z['long']);
            if ($min === null || $d < $min) $min = $d;
        }
        return $min;
    }

    /** Haversine distance in km */
    private function haversineKm(float $lat1, float $lon1, float $lat2, float $lon2): float
    {
        $R = 6371;
        $dLat = deg2rad($lat2 - $lat1);
        $dLon = deg2rad($lon2 - $lon1);
        $a = sin($dLat/2)**2 + cos(deg2rad($lat1))*cos(deg2rad($lat2))*sin($dLon/2)**2;
        return 2 * $R * atan2(sqrt($a), sqrt(1 - $a));
    }



    public function setItemQuotedPrice(Request $request, int $orderId, int $itemId)
    {
       
        $data = $request->validate([
            'quoted_price' => 'nullable|numeric|min:0', // null clears quote
        ]);

        $check = Orders::where('id',$orderId)->where('payment_status','pending')->first();

        if(!$check)
        {
            return response()->json([
                'error'=>"Can not update it's pricing now",
            ], 409);
        }

        return DB::transaction(function () use ($orderId, $itemId, $data) {
            // Lock the item row and guarantee it belongs to the order
            /** @var OrderItem $item */
            $item = OrderItem::where('order_id', $orderId)
                ->lockForUpdate()
                ->findOrFail($itemId);

            // Important: do not coerce null to 0.00
            $quoted = array_key_exists('quoted_price', $data) ? $data['quoted_price'] : null;

            // Assign and save
            $item->forceFill([
                'quoted_price' => $quoted,                 // stays null if clearing
                'is_quoted'    => is_null($quoted) ? 0 : 1,
            ]);

            $item->saveOrFail();

            // Recalculate customer-facing totals only
            $order = Orders::with('items')->findOrFail($orderId);
            OrderPricingService::recalcCustomer($order, null, null, true);

            return response()->json([
                'message' => 'Quoted price saved. Customer totals recalculated.',
                'order' => [
                    'id'                     => $order->id,
                    'customer_item_cost'     => $order->customer_item_cost,
                    'customer_delivery_cost' => $order->customer_delivery_cost,
                    'gst_tax'                => $order->gst_tax,
                    'total_price'            => $order->total_price,
                    'profit_amount'          => $order->profit_amount,
                    'profit_margin_percent'  => $order->profit_margin_percent,
                ],
                'item' => [
                    'id'           => $item->id,
                    'is_quoted'    => (int)$item->is_quoted,
                    'quoted_price' => $item->quoted_price, // null if cleared
                ],
            ]);
        });
    }
}


------------------------------------------------------------
FILE: Http/Controllers/AdminController.php
------------------------------------------------------------
<?php
//To be deleted
namespace App\Http\Controllers;

use App\Models\User;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;



class AdminController extends Controller
{
    public function clients()
    {
        // dd('here');
        $clients = User::where('role', 'client')->get();
        $totalClients = $clients->count();
        $activeClients = $clients->where('status', 'Active')->count();
        $inactiveClients = $clients->where('status', 'In-Active')->count();
        $joinedThisMonth = $clients->where('created_at', '>=', now()->startOfMonth())->count();
        return view('clients.index', compact('clients','totalClients','activeClients','inactiveClients','joinedThisMonth'));
    }

    public function addClient(Request $request)
    {
        $data = $request->validate([
            'name'           => 'required|string|max:120',
            'email'          => 'required|email|max:120|unique:users,email',
            'password'       => 'required|string|min:8|confirmed',
            'company_name'   => 'nullable|string|max:120',
            'contact_name'   => 'nullable|string|max:100',
            'contact_number' => 'nullable|string|max:20',
            'shipping_address' => 'nullable|string|max:255',
            'delivery_address' => 'nullable|string|max:255',
        ]);


        $user = User::create([
            'name'           => $data['name'],
            'email'          => $data['email'],
            'password'       => Hash::make($data['password']),   // <-- hashed here
            'role'           => 'client',
            'company_name'   => $data['company_name'] ?? null,
            'contact_name'   => $data['contact_name'] ?? null,
            'contact_number' => $data['contact_number'] ?? null,
            'shipping_address' => $data['shipping_address'] ?? null,
            'delivery_address' => $data['delivery_address'] ?? null,
            'status'         => 'Active', // Default status
        ]);


        return redirect()->route('clients')->with('success', 'Client added successfully');
    }


    
}


------------------------------------------------------------
FILE: Http/Controllers/ApiAuthController.php
------------------------------------------------------------
<?php
namespace App\Http\Controllers;

use App\Models\User;
use App\Models\Company;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Str;
use Illuminate\Support\Facades\Validator;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Storage;
use Laravel\Sanctum\HasApiTokens;

class ApiAuthController extends Controller
{
    // Register Client
    public function registerClient(Request $request)
    {
        $validator = Validator::make($request->all(), [
            'name' => 'required|string|max:255',
            'email' => 'required|email|unique:users,email',
            'password' => 'required|string|min:6',
            'contact_name' => 'required|string|max:255',
            'contact_number' => 'required|string|max:255',
            'shipping_address' => 'required|string|max:255',
            'billing_address' => 'required|string|max:255',
            'profile_image' => 'nullable|image|max:2048', // Optional profile image
            'company_name' => 'nullable|string|max:255',
            'lat' => 'nullable|numeric',
            'long' => 'nullable|numeric',
        ]);

        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 400);
        }

        $imageUrl = null;
        // Handle profile image
        if ($request->hasFile('profile_image') && $request->file('profile_image')->isValid()) {
            // Store the file under 'profile_images' directory in the 'public' disk
            $path = $request->file('profile_image')->store('profile_images', 'public');
            $imageUrl = 'storage/' . $path; // Relative path to the image
        } 

        // Check if company exists, or create new
        $company = Company::firstOrCreate([
            'name' => Str::lower($request->company_name),
        ]);

        // Generate unique client ID
        do {
            $clientPublicId = 'MC-' . rand(100, 999);
        } while (User::where('client_public_id', $clientPublicId)->exists());

        // Register client
        $user = User::create([
            'name' => $request->name,
            'email' => $request->email,
            'password' => Hash::make($request->password),
            'role' => 'client',
            'company_id' => $company->id,
            'contact_name' => $request->contact_name,
            'contact_number' => $request->contact_number,
            'shipping_address' => $request->shipping_address,
            'billing_address' => $request->billing_address,
            'client_public_id' => $clientPublicId,
            'isDeleted' => false,
            'profile_image' => $imageUrl, // Store the relative path
            'lat' => $request->lat,
            'long' => $request->long,
        ]);

        // Create Sanctum Token for the user
        $token = $user->createToken('ClientApp')->plainTextToken;


        return response()->json([
            'message' => 'Client registered successfully.',
            'token' => $token,
            'user' => $user,
            'role' => $user->role,
            'profile_image_url' => $imageUrl, // Return the image URL in response
        ], 201);
    }


    // Register Supplier
    public function registerSupplier(Request $request)
    {
        $validator = Validator::make($request->all(), [
            'name' => 'required|string|max:255',
            'email' => 'required|email|unique:users,email',
            'password' => 'required|string|min:6',
            'contact_name' => 'required|string|max:255',
            'contact_number' => 'required|string|max:255',
            'location' => 'nullable|string|max:255',
            'company_name' => 'required|string|max:255',
            'profile_image' => 'nullable|image|max:2048', // Optional profile image
        ]);

        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 400);
        }

        // Check if company exists, or create new
        $company = Company::firstOrCreate([
            'name' => Str::lower($request->company_name), // Assuming the company name is based on contact name
        ]);

        $imageUrl = null;
        // Handle profile image
        if ($request->hasFile('profile_image') && $request->file('profile_image')->isValid()) {
            // Store the file under 'profile_images' directory in the 'public' disk
            $path = $request->file('profile_image')->store('profile_images', 'public');
            $imageUrl = 'storage/' . $path; // Relative path to the image
        }

        // Register supplier (auto-role assignment)
        $user = User::create([
            'name' => $request->name,
            'email' => $request->email,
            'password' => Hash::make($request->password),
            'role' => 'supplier', // Set role as supplier for registration
            'company_id' => $company->id,
            'contact_name' => $request->contact_name,
            'contact_number' => $request->contact_number,
            'location' => $request->location,
            'isDeleted' => false,
            'profile_image' => $imageUrl,
        ]);

        // Create Sanctum Token for the user
        $token = $user->createToken('SupplierApp')->plainTextToken;

        return response()->json([
            'message' => 'Supplier registered successfully.',
            'token' => $token,
            'user' => $user,
            'role' => $user->role,
            'profile_image_url' => $imageUrl, // Return the image URL in response
        ], 201);
    }
    
    // Login Function
    public function login(Request $request)
    {
        $validator = Validator::make($request->all(), [
            'email' => 'required|email',
            'password' => 'required|string|min:6',
        ]);

        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 400);
        }

        if (!User::where('email', $request->email)->exists()) {
            return response()->json(['error' => 'Email not registered.'], 404);
        }

        // Check credentials
        if (Auth::attempt(['email' => $request->email, 'password' => $request->password])) {
            $user = Auth::user();

            // Create a new token for the user
            $token = $user->createToken('UserApp')->plainTextToken;

            return response()->json([
                'message' => 'Login successful.',
                'token' => $token,
                'user' => $user,
                'role' => $user->role,
            ], 200);
        }

        return response()->json(['error' => 'Password is wrong'], 401);
    }


    public function checkAuth(Request $request)
    {
        // Check if the user is authenticated using Sanctum or session authentication
        if (Auth::check()) {
            // The user is authenticated
            $user = Auth::user()->load('company'); // Get the authenticated user
            if($user->role === 'supplier' && $user->delivery_zones && $user->delivery_zones !== 'null' && $user->delivery_zones !== null ) {
                $user->delivery_zones = $user->delivery_zones;
            }
    
            // Return the user details along with the role
            return response()->json([
                'message' => 'User is authenticated',
                'user' => $user,
                'role' => $user->role,
            ], 200); // 200 OK status code
        } else {
            // The user is not authenticated
            return response()->json([
                'message' => 'User is not authenticated',
            ], 401); // Unauthorized status code
        }
    }


    public function logout(Request $request)
    {
        $user = Auth::user();
        if ($request->boolean('all')) {
            $user->tokens()->delete();                 // revoke all tokens
        } else {
            $user->currentAccessToken()?->delete();    // revoke current token
        }
        return response()->json(['message' => 'Logged out'], 200);
    }

    /**
     * Update profile (no password). Handles client and supplier fields.
     * Accepts:
     *  - Common: name, email, contact_name, contact_number, profile_image
     *  - Client: shipping_address, billing_address, lat, long, company_name
     *  - Supplier: location, delivery_radius, company_name
     */
    public function updateProfile(Request $request)
    {
        $user = Auth::user();

        $validator = Validator::make($request->all(), [
            'name'            => 'sometimes|string|max:255',
            'email'           => 'sometimes|email|unique:users,email,' . $user->id,
            'contact_name'    => 'sometimes|nullable|string|max:255',
            'contact_number'  => 'sometimes|nullable|string|max:255',
            'profile_image'   => 'sometimes|file|image|max:4096',

            // client fields
            'shipping_address'=> 'sometimes|nullable|string|max:255',
            'billing_address' => 'sometimes|nullable|string|max:255',
            'lat'             => 'sometimes|nullable|numeric',
            'long'            => 'sometimes|nullable|numeric',

            // supplier fields
            'location'        => 'sometimes|nullable|string|max:255',
            'delivery_radius' => 'sometimes|nullable|numeric',

            // both roles may set or change company
            'company_name'    => 'sometimes|nullable|string|max:255',
        ]);

        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 422);
        }

        // company
        $companyId = $user->company_id;
        if ($request->filled('company_name')) {
            $company = Company::firstOrCreate(['name' => Str::lower($request->company_name)]);
            $companyId = $company->id;
        }

        // profile image
        $profileImagePath = $user->profile_image;
        if ($request->hasFile('profile_image') && $request->file('profile_image')->isValid()) {
            if ($profileImagePath) {
                $old = str_replace('storage/', '', $profileImagePath);
                Storage::disk('public')->delete($old);
            }
            $stored = $request->file('profile_image')->store('profile_images', 'public');
            $profileImagePath = 'storage/' . $stored;
        }

        // payload
        $data = [
            'name'            => $request->input('name', $user->name),
            'email'           => $request->input('email', $user->email),
            'contact_name'    => $request->input('contact_name', $user->contact_name),
            'contact_number'  => $request->input('contact_number', $user->contact_number),
            'profile_image'   => $profileImagePath,
            'company_id'      => $companyId,
        ];

        if ($user->role === 'client') {
            $data += [
                'shipping_address'=> $request->input('shipping_address', $user->shipping_address),
                'billing_address' => $request->input('billing_address', $user->billing_address),
                'lat'             => $request->input('lat', $user->lat),
                'long'            => $request->input('long', $user->long),
            ];
        }

        if ($user->role === 'supplier') {
            $data += [
                'location'        => $request->input('location', $user->location),
                'delivery_radius' => $request->input('delivery_radius', $user->delivery_radius),
            ];
        }

        $user->update($data);

        return response()->json([
            'message' => 'Profile updated',
            'user'    => $user->fresh((['company'])),
        ], 200);
    }

    /**
     * Change password.
     * Required: current_password, new_password, new_password_confirmation
     */
    public function changePassword(Request $request)
    {
        $validator = Validator::make($request->all(), [
            'current_password'        => 'required|string',
            'new_password'            => 'required|string|min:6|confirmed',
            // field name must be new_password_confirmation
        ], [
            'new_password.confirmed' => 'New password confirmation does not match.',
        ]);

        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 422);
        }

        $user = Auth::user();

        if (!Hash::check($request->current_password, $user->password)) {
            return response()->json(['error' => ['current_password' => ['Current password is incorrect.']]], 400);
        }

        $user->password = Hash::make($request->new_password);
        $user->save();

        // Optional: rotate token on password change
        $request->user()->tokens()->delete();
        $newToken = $user->createToken('UserApp')->plainTextToken;

        return response()->json([
            'message' => 'Password updated',
            'token'   => $newToken,
        ], 200);
    }
}


------------------------------------------------------------
FILE: Http/Controllers/AuthController.php
------------------------------------------------------------
<?php
//To be deleted
namespace App\Http\Controllers;

use App\Models\User;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Facades\Log;

class AuthController extends Controller
{
    public function registerAdmin(Request $request)
    {
        
        $data = $request->validate([
            'name'     => 'required|string|max:120',
            'email'    => 'required|email|max:120|unique:users,email',
            'password' => 'required|string|min:8|confirmed',
        ]);

        $user = User::create([
            'name'     => $data['name'],
            'email'    => $data['email'],
            'password' => Hash::make($data['password']),   // <-- hashed here
            'role'     => 'admin',
        ]);

        Auth::login($user);

        return response()->json(['message' => 'Admin registered successfully'], 201);

        // return redirect()->route('dashboard')->with('success', 'Admin registered successfully');
    }


    // Register (client only)
    public function register(Request $request)
    {
        $data = $request->validate([
            'name'           => 'required|string|max:120',
            'email'          => 'required|email|max:120|unique:users,email',
            'password'       => 'required|string|min:8|confirmed',
            'company_name'   => 'nullable|string|max:120',
            'contact_name'   => 'nullable|string|max:100',
            'contact_number' => 'nullable|string|max:20',
            'shipping_address' => 'nullable|string|max:255',
            'delivery_address' => 'nullable|string|max:255',
        ]);
        // dd($data);

        $user = User::create([
            'name'           => $data['name'],
            'email'          => $data['email'],
            'password'       => Hash::make($data['password']),   // <-- hashed here
            'role'           => 'client',
            'company_name'   => $data['company_name'] ?? null,
            'contact_name'   => $data['contact_name'] ?? null,
            'contact_number' => $data['contact_number'] ?? null,
            'shipping_address' => $data['shipping_address'] ?? null,
            'delivery_address' => $data['delivery_address'] ?? null,
            'status'         => 'Active', // Default status
        ]);

        Auth::login($user);
        // dd($user);
        return redirect()->route('dashboard')->with('success', 'Registered successfully');
    }

    // Login
  public function login(Request $request){
        $credentials = $request->validate([
            'email' => 'required|email',
            'password' => 'required',
        ]);

        if (Auth::attempt($credentials)) {
            $request->session()->regenerate();
            

            
            return redirect()->intended('/dashboard');
        }

        return back()->withErrors([
            'email' => 'Invalid credentials.',
        ]);
    }


    // Logout
    public function logout(Request $request)
    {
        Auth::logout();
        $request->session()->invalidate();
        $request->session()->regenerateToken();
        return redirect('/');
    }

    //dashboard
    public function dashboard()
    {
        
        return view('dashboard');
    }
}


------------------------------------------------------------
FILE: Http/Controllers/Controller.php
------------------------------------------------------------
<?php

namespace App\Http\Controllers;

abstract class Controller
{
    //
}


------------------------------------------------------------
FILE: Http/Controllers/OrderController.php
------------------------------------------------------------
<?php

namespace App\Http\Controllers;

use App\Models\Orders;
use App\Models\MasterProducts;
use App\Models\SupplierOffers;
use App\Models\OrderItem;
use App\Models\Projects;
use Illuminate\Support\Facades\DB;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Validator;

class OrderController extends Controller
{
    /**
     * Create a new order with multiple products.
     */
    public function createOrder(Request $request)
    {
        $v = Validator::make($request->all(), [
            'po_number'        => 'nullable|unique:orders,po_number|string|max:50',
            'project_id'       => 'required|exists:projects,id',
            'delivery_address' => 'required|string',
            'delivery_lat'     => 'required|numeric',
            'delivery_long'    => 'required|numeric',
            'delivery_date'    => 'required|date',
            'delivery_time'    => 'nullable|date_format:H:i',
            'delivery_method'  => 'required|in:Other,Tipper,Agitator,Pump,Ute',
            'load_size'        => 'nullable|string|max:50',
            'special_equipment'=> 'nullable|string|max:255',
            'items'            => 'required|array|min:1',
            'items.*.product_id'       => 'required|exists:master_products,id',
            'items.*.quantity'         => 'required|numeric|min:0.01',
            'items.*.custom_blend_mix' => 'nullable|string',
            'repeat_order'     => 'nullable|boolean',
            'special_notes'    => 'nullable|string|max:1000',
        ]);

        if ($v->fails()) {
            return response()->json(['error' => $v->errors()], 422);
        }

        $user = Auth::user();

        return DB::transaction(function () use ($request, $user) {
            // 1) Create order
            /** @var Orders $order */
            $order = Orders::create([
                'po_number'        => $request->po_number,
                'client_id'        => $user->id,
                'project_id'       => $request->project_id,
                'delivery_address' => $request->delivery_address,
                'delivery_lat'     => $request->delivery_lat,
                'delivery_long'    => $request->delivery_long,
                'delivery_date'    => $request->delivery_date,
                'delivery_time'    => $request->delivery_time,
                'delivery_method'  => $request->delivery_method,
                'load_size'        => $request->load_size,
                'special_equipment'=> $request->special_equipment,
                // monetary fields start at zero; you’ll roll them up later
                'other_charges'    => 0,
                'gst_tax'          => 0,
                'discount'         => 0,
                'total_price'      => 0,
                'supplier_item_cost'    => 0,
                'customer_item_cost'    => 0,
                'customer_delivery_cost'    => 0,
                'supplier_delivery_cost'    => 0,
                // initial states per spec
                'payment_status'   => 'Pending',
                'order_status'     => 'In-Progress',
                'order_process'    => 'Automated',
                'generate_invoice' => 0,
                'repeat_order'     => $request->repeat_order ? $request->repeat_order : 0,
                'special_notes'    => $request->special_notes ?? null,
                // add 'workflow' column in your table if not present yet
            ]);

            $lat = (float) $order->delivery_lat;
            $lng = (float) $order->delivery_long;

            // 2) Preload candidate offers for all requested product_ids
            $productIds = collect($request->items)->pluck('product_id')->unique()->values();
            // dd($productIds);
            $offers = SupplierOffers::with(['supplier:id,delivery_zones'])
                ->whereIn('master_product_id', $productIds)   // adjust column name if different
                ->where('status', 'Approved')                     // only approved offers
                ->whereIn('availability_status', ['In Stock', 'Limited'])                       // optional filter if you have it
                ->get()
                ->groupBy('master_product_id');
            $anyMissingSupplier = false;
            // dd($offers);
            // 3) Create items with nearest in-zone supplier if available
            foreach ($request->items as $row) {
                $pid   = (int) $row['product_id'];
                $qty   = (float) $row['quantity'];
                $blend = $row['custom_blend_mix'] ?? null;

                [$chosenOffer, $distanceKm] = $this->pickNearestOfferInZone(
                    $offers->get($pid) ?? collect(), $lat, $lng
                );

                if ($chosenOffer) {
                    $order->items()->create([
                        'product_id'             => $pid,
                        'quantity'               => $qty,
                        'supplier_id'            => $chosenOffer->supplier_id,
                        'custom_blend_mix'       => $blend,
                        'supplier_unit_cost'     => (float) ($chosenOffer->unit_cost ?? $chosenOffer->price ?? 0),
                        'supplier_delivery_cost' => (float) ($chosenOffer->delivery_cost ?? 0),
                        'supplier_delivery_date' => $order->delivery_date,
                        'choosen_offer_id'      => $chosenOffer->id,
                        'supplier_confirms'      => 0,
                    ]);
                } else {
                    $anyMissingSupplier = true;

                    $order->items()->create([
                        'product_id'             => $pid,
                        'quantity'               => $qty,
                        'supplier_id'            => null,
                        'custom_blend_mix'       => $blend,
                        'supplier_unit_cost'     => 0,
                        'supplier_delivery_cost' => 0,
                        'supplier_delivery_date' => $order->delivery_date,
                        'supplier_confirms'      => 0,
                    ]);
                }
            }

            // 4) Update workflow + order_process if any item unassigned
            if ($anyMissingSupplier) {
                $order->workflow      = 'Supplier Missing';
                $order->order_process = 'Action Required';
                $order->save();
            } else {
                // all items assigned to a supplier
                $order->workflow      = 'Supplier Assigned';
                $order->order_process = 'Automated';
                $order->save();
                // $this->workflow($order);
            }

            // Optionally eager-load for response
            $order->load(['items.product','items.supplier']);

            return response()->json([
                'message' => 'Order created',
                'order'   => $order
            ], 201);
        });
    }

    // Helper function | Workflow 
    private function workflow(Orders $order)
    {
        $currentWorkflow = $order->workflow;

        switch ($currentWorkflow) {
            case 'Supplier Assigned':
                $allConfirmed = $order->items()->where('supplier_confirms', false)->count() === 0;
                if ($allConfirmed) {
                    // Calculate pricing
                    $subtotal = 0;
                    $supplierCost = 0;
                    $adminMarginPercentage = 0.50; // 50% admin margin
                    $deliveryCost = 0;
                    $fuelLevy = 0;
                    $itemCostWithMargin= 0;
                    $adminMarginAmount = 0;
                    
                    foreach ($order->items as $item) {
                        // Calculate item cost excluding delivery
                        $itemCost = ($item->supplier_unit_cost * $item->quantity) - $item->supplier_discount;
                        
                        // Add admin margin to item cost (50% on top of item cost)
                        $itemCostWithMargin = $itemCost + ($itemCost * $adminMarginPercentage);
                        
                        $subtotal += $itemCostWithMargin;
                        $supplierCost += $itemCost; // Supplier cost without admin margin
                        $deliveryCost += $item->supplier_delivery_cost;
                    }
                   
                    
                    // Calculate fuel levy (10% on delivery cost as per your example)
                    $fuelLevy = $deliveryCost + ($deliveryCost * 0.10);
                    //  dd($subtotal,$fuelLevy);
                    
                    // Calculate GST (10% on subtotal)
                    $gstTax = $subtotal * 0.10;
                    
                    // Calculate total price
                    $totalPrice = $subtotal + $gstTax + $fuelLevy - $order->discount + $order->other_charges;
                    
                    // Calculate actual admin margin amount (for tracking)
                    $adminMarginAmount = $subtotal * $adminMarginPercentage;

                    // Update order pricing fields
                    $order->subtotal = $subtotal;
                    $order->fuel_levy = $fuelLevy;
                    $order->gst_tax = $gstTax;
                    $order->total_price = $totalPrice;
                    $order->supplier_cost = $supplierCost + $deliveryCost; // Total supplier cost including delivery
                    $order->customer_cost = $totalPrice;
                    $order->admin_margin = $adminMarginAmount; // The actual margin amount
                    $order->workflow = 'Payment Requested';
                    $order->save();
                }
                break;
        }
    }


    /**
     * Pick nearest offer whose supplier has a delivery zone covering the point.
     * Zones format expected on users.delivery_zones: JSON array of
     * [{ "lat": <float>, "long": <float>, "radius": <km as number>, "address": "..." }, ...]
     * Returns [SupplierOffers|null, float distanceKm]
     */
    private function pickNearestOfferInZone($offersForProduct, float $lat, float $lng): array
    {
        // dd( $offersForProduct, $lat, $lng);
        $bestOffer = null;
        $bestDist  = PHP_FLOAT_MAX;

        foreach ($offersForProduct as $offer) {
            $supplier = $offer->supplier;
            if (!$supplier || empty($supplier->delivery_zones)) {
                continue;
            }

            $zones = is_string($supplier->delivery_zones)
                ? json_decode($supplier->delivery_zones, true)
                : $supplier->delivery_zones;
            // dd($zones);

            if (!is_array($zones)) {
                continue;
            }

            foreach ($zones as $z) {
                if (!isset($z['lat'], $z['long'], $z['radius'])) {
                    continue;
                }
                $distKm = $this->haversineKm($lat, $lng, (float)$z['lat'], (float)$z['long']);
                
                if ($distKm <= (float)$z['radius']) {
                    // dd($distKm, $bestDist);
                    // inside this zone
                    if ($distKm < $bestDist) {
                        $bestDist  = $distKm;
                        $bestOffer = $offer;
                    }
                }
            }
        }

        return [$bestOffer, $bestOffer ? $bestDist : INF];
    }

    private function haversineKm(float $lat1, float $lon1, float $lat2, float $lon2): float
    {
        $R = 6371.0088; // mean Earth radius in km
        $dLat = deg2rad($lat2 - $lat1);
        $dLon = deg2rad($lon2 - $lon1);
        $a = sin($dLat/2) * sin($dLat/2)
           + cos(deg2rad($lat1)) * cos(deg2rad($lat2))
           * sin($dLon/2) * sin($dLon/2);
        $c = 2 * atan2(sqrt($a), sqrt(1-$a));
        return $R * $c;
    }


    public function getClientProducts(Request $request)
    {
        // $user    = Auth::user();
        $perPage = (int) $request->integer('per_page', 10);
        $page    = (int) $request->integer('page', 1);

        // aggregate approved, available offers per product (scoped to this client's suppliers)
        $offersAgg = SupplierOffers::query()
            ->select('supplier_offers.master_product_id')
            ->selectRaw('MIN(supplier_offers.price) AS price_min')
            ->selectRaw('MAX(supplier_offers.price) AS price_max')
            ->join('users as suppliers', 'suppliers.id', '=', 'supplier_offers.supplier_id')
            // ->where('suppliers.client_id', $user->id)
            ->where('supplier_offers.status', 'Approved')
            ->whereIn('supplier_offers.availability_status', ['In Stock', 'Limited'])
            ->groupBy('supplier_offers.master_product_id');

        $query = MasterProducts::query()
            ->joinSub($offersAgg, 'oa', function ($join) {
                $join->on('oa.master_product_id', '=', 'master_products.id');
            })
            ->select('master_products.*', 'oa.price_min', 'oa.price_max');

        // search by product_name
        if ($search = trim((string) $request->get('search'))) {
            $query->where('master_products.product_name', 'like', "%{$search}%");
        }

        // filter by category_id
        if ($request->filled('category')) {
            $query->where('master_products.category', $request->get('category'));
        }

        // sort
        if ($request->get('sort') === 'price') {
            $query->orderBy('oa.price_min', 'asc');
        } else {
            $query->orderBy('master_products.product_name', 'asc');
        }

        $products = $query->with('category')->paginate($perPage, ['*'], 'page', $page);

        $products->getCollection()->transform(function ($p) {
            $p->price = ($p->price_min == $p->price_max)
                ? sprintf('$%.2f', $p->price_min)
                : sprintf('$%.2f - $%.2f', $p->price_min, $p->price_max);
            return $p;
        });

        return response()->json([
            'data' => $products->items(),
            'meta' => [
                'current_page' => $products->currentPage(),
                'per_page'     => $products->perPage(),
                'total'        => $products->total(),
                'last_page'    => $products->lastPage(),
            ],
        ]);
    }

    public function getClientProductDetails($id)
    {
        // dd($id);
        // $user = Auth::user();

        $product = MasterProducts::with('category')->find($id);
        if (!$product) {
            return response()->json(['error' => 'Product not found'], 404);
        }

        // fetch approved, available offers for this product (scoped to this client's suppliers)
        $offers = SupplierOffers::with(['supplier:id,company_name,delivery_zones'])
            ->where('master_product_id', $product->id)
            // ->whereHas('supplier', function ($q) use ($user) {
            //     $q->where('client_id', $user->id);
            // })
            ->where('status', 'Approved')
            ->whereIn('availability_status', ['In Stock', 'Limited'])
            ->orderBy('price', 'asc')
            ->get();

        return response()->json($product);
    }

    //Get my orders
    public function getMyOrders(Request $request)
    {
        $user = Auth::user();

        $details = filter_var($request->get('details', false), FILTER_VALIDATE_BOOLEAN);

        $perPage = (int) $request->get('per_page', 10);
        $search  = trim((string) $request->get('search', ''));
        $sort    = $request->get('sort', 'created_at');
        $dir     = strtolower($request->get('dir', 'desc')) === 'asc' ? 'asc' : 'desc';
        $delivery_date = $request->get('delivery_date');
        $project_id    = $request->get('project_id');
        $workflow      = $request->get('workflow');
        $repeat_order   = null;
        if($request->has('repeat_order')) {
            $repeat_order = $request->get('repeat_order');
            if($repeat_order === 'true' || $repeat_order === '1') {
                $repeat_order = true;
            } elseif($repeat_order === 'false' || $repeat_order === '0') {
                $repeat_order = false;
            } else {
                $repeat_order = null; // invalid value, ignore filter
            }
        } else {
            $repeat_order = null;
        }

        $query = Orders::with(['project','items.product','items.supplier'])
            ->where('client_id', $user->id);

        if ($search !== '')        $query->where('po_number', 'like', "%{$search}%");
        if ($delivery_date)        $query->whereDate('delivery_date', $delivery_date);
        if ($project_id)           $query->where('project_id', $project_id);
        if ($workflow)             $query->where('workflow', $workflow);
        if ($repeat_order !== null) $query->where('repeat_order', (bool)$repeat_order);
        // dd($repeat_order);
        $allowedSorts = ['po_number','delivery_date','created_at','updated_at'];
        if (!in_array($sort, $allowedSorts, true)) $sort = 'created_at';

        $orders = $query->orderBy($sort, $dir)->paginate($perPage);

        // enrich each order with order_info
        $enriched = collect($orders->items())->map(function (Orders $o) {
            $missing = $o->items->whereNull('supplier_id');
            if ($o->workflow === 'Supplier Missing') {
                $missingNames = $missing->map(fn($it) => optional($it->product)->product_name)
                                        ->filter()->unique()->values()->all();
                $o->order_info = 'Supplier missing for: ' . implode(', ', $missingNames);
            } elseif ($o->workflow === 'Supplier Assigned') {
                $o->order_info = 'Waiting for suppliers to confirm';
            } elseif ($o->workflow === 'Payment Requested') {
                $o->order_info = 'Awaiting your payment';
            } else {
                $o->order_info = null;
            }
            return $o;
        })->values()->all();

        $base = Orders::where('client_id', $user->id);
        $metrics = [
            'total_orders_count'      => (clone $base)->count(),
            'supplier_missing_count'  => (clone $base)->where('workflow', 'Supplier Missing')->count(),
            'supplier_assigned_count' => (clone $base)->where('workflow', 'Supplier Assigned')->count(),
            'awaiting_payment_count'  => (clone $base)->where('workflow', 'Payment Requested')->count(),
            'delivered_count'         => (clone $base)->where('workflow', 'Delivered')->count(),
        ];

        $response = [
            'data' => $enriched,
            'pagination' => [
                'per_page' => $orders->perPage(),
                'current_page' => $orders->currentPage(),
                'total_pages' => $orders->lastPage(),
                'total_items' => $orders->total(),
                'has_more_pages' => $orders->hasMorePages(),
            ],
            'metrics' => $metrics,
        ];

        if ($details) {
            $projects = Projects::where('added_by', $user->id)
                ->orderBy('created_at','desc')
                ->get(['id','name']);
            $response['projects'] = $projects;
        }

        return response()->json($response);
    }


    /**
     * Client view. If workflow = Supplier Missing, include eligible suppliers per missing item.
     */
    public function viewMyOrder(Orders $order)
    {
        abort_unless($order->client_id === Auth::id(), 403);

        $order->load(['project','items.product','items.supplier']);

        $missing = $order->items->whereNull('supplier_id');
            if ($order->workflow === 'Supplier Missing') {
                $missingNames = $missing->map(fn($it) => optional($it->product)->product_name)
                                        ->filter()->unique()->values()->all();
                $order->order_info = 'Supplier missing for: ' . implode(', ', $missingNames);
            } elseif ($order->workflow === 'Supplier Assigned') {
                $order->order_info = 'Waiting for suppliers to confirm';
            } elseif ($order->workflow === 'Payment Requested') {
                $order->order_info = 'Awaiting your payment';
            } else {
                $order->order_info = null;
            }

        $orderData = $order->only([
            'id','po_number','project_id','client_id','workflow','delivery_address',
            'delivery_date','delivery_time','delivery_method','repeat_order','subtotal','fuel_levy','other_charges','gst_tax','total_price','reason','created_at','updated_at'
        ]);
        
        $order->items->each(function (OrderItem $item) use ($order) {
            $item->supplier_unit_cost = ((float) $item->supplier_unit_cost/2) + (float) $item->supplier_unit_cost;
        });

        $orderData['project'] = optional($order->project)?->only(['id','name','site_contact_name','site_contact_phone','site_instructions']);
        $orderData['order_info'] = $order->order_info;
        return response()->json([
            'success' => true,
            'data' => [
                'order' => $orderData,
                'items' => $order->items,
            ],
        ]);
    }


    /**
     * Assign a supplier to a specific order item and advance workflow if all assigned.
     * Body: { "supplier_id": <int> }
     */
    public function assignSupplier(Request $request, OrderItem $item)
    {
        $v = Validator::make($request->all(), ['supplier_id' => 'required|exists:users,id']);
        if ($v->fails()) return response()->json(['error'=>$v->errors()], 422);

        $order = $item->order()->with('items')->first();
        abort_unless($order && $order->client_id === Auth::id(), 403);

        $supplierId = (int) $request->supplier_id;

        $chosenOffer = SupplierOffers::with('supplier:id,delivery_zones')
            ->where('supplier_id', $supplierId)
            ->where('master_product_id', $item->product_id)
            ->where('status', 'Approved')
            ->whereIn('availability_status', ['In Stock','Limited'])
            ->whereHas('supplier', fn($q) => $q->whereJsonLength('delivery_zones','>=',1))
            ->first();

        if (!$chosenOffer) {
            return response()->json(['error' => 'No valid offer with delivery zones for this product'], 422);
        }

        $item->update([
            'supplier_id'             => $chosenOffer->supplier_id,
            'choosen_offer_id'        => $chosenOffer->id,
            'supplier_unit_cost'      => (float) ($chosenOffer->unit_cost ?? $chosenOffer->price ?? 0),
            'supplier_delivery_cost'  => (float) ($chosenOffer->delivery_cost ?? 0),
            'supplier_delivery_date'  => $order->delivery_date,
            'supplier_confirms'       => false,
        ]);

        if ($order->items()->whereNull('supplier_id')->count() === 0) {
            $order->update(['workflow' => 'Supplier Assigned', 'order_process' => 'Automated']);
        }

        return response()->json([
            'success' => true,
            'message' => 'Supplier assigned',
            'order_workflow' => $order->workflow,
            'item' => $item->fresh(['product','supplier','chosenOffer']),
        ]);
    }



    /**
     * Mark or unmark an order as repeat order.
     */    
    public function markRepeatOrder(Orders $order, Request $request)
    {
        abort_unless($order->client_id === Auth::id(), 403);
        $order->repeat_order = true;
        $order->save();
        return response()->json([
            'success' => true,
            'message' => 'Order marked as repeat order',
            'order'   => $order->only(['id','repeat_order']),
        ]); 
    }

    
    
        

}




------------------------------------------------------------
FILE: Http/Controllers/PaymentController.php
------------------------------------------------------------
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Stripe\Stripe;
use Stripe\PaymentIntent;
use App\Models\Orders;

class PaymentController extends Controller
{
    // Constructor to initialize Stripe key
    public function __construct()
    {
        // Set your Stripe secret key
        Stripe::setApiKey(env('STRIPE_SECRET'));
    }

    /**
     * Create a Stripe Payment Intent
     */
    public function createPaymentIntent(Request $request, $orderId)
    {
        // Retrieve order details from the database
        $order = Orders::findOrFail($orderId);

        // Calculate the total amount (in cents)
        $amount = $order->total_price * 100; // Assume total_price is in dollars

        try {
            // Create a PaymentIntent with the order amount
            $paymentIntent = PaymentIntent::create([
                'amount' => $amount,
                'currency' => 'aud',
                'metadata' => ['order_id' => $orderId],
            ]);

            // Return the client secret for frontend to use
            return response()->json([
                'client_secret' => $paymentIntent->client_secret,
                'order_id' => $orderId,
                'payment_status' => $order->payment_status
            ]);
        } catch (\Exception $e) {
            // Handle error and return a message
            return response()->json(['error' => $e->getMessage()], 500);
        }
    }

    /**
     * Update the payment status after successful payment
     */
    public function updatePaymentStatus(Request $request)
    {
        // The payment status from Stripe callback
        $paymentIntentId = $request->payment_intent_id;
        $status = $request->payment_status;
        $orderId = $request->order_id;

        // Find the order by ID
        $order = Orders::findOrFail($orderId);

        // Update the payment status in the database
        if ($status == 'succeeded') {
            $order->payment_status = 'Paid';
        } else {
            $order->payment_status = 'Failed';
        }

        $order->save();

        return response()->json(['message' => 'Payment status updated successfully']);
    }
}

------------------------------------------------------------
FILE: Http/Controllers/ProjectController.php
------------------------------------------------------------
<?php

namespace App\Http\Controllers;

use App\Models\Projects as Project; // keep alias if your model is named Projects
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Validator; // added
use Illuminate\Validation\Rule;

class ProjectController extends Controller
{
    // GET /client/projects
    public function index(Request $request)
    {

        $projects= Project::where('added_by', Auth::id())->get();
        return response()->json(['data'=>$projects]);
        $user = Auth::user();
        abort_unless($user && $user->role === 'client', 403, 'Forbidden');

        $perPage = (int) $request->get('per_page', 10);
        $search  = trim((string) $request->get('search', ''));
        $sort    = $request->get('sort', 'created_at');
        $dir     = $request->get('dir', 'desc');

        $query = Project::with('added_by.company')
            ->where('added_by', $user->id);

        if ($search !== '') {
            $query->where('name', 'like', "%{$search}%");
        }

        $allowedSorts = ['name','created_at','updated_at'];
        if (!in_array($sort, $allowedSorts, true)) $sort = 'created_at';
        $dir = strtolower($dir) === 'asc' ? 'asc' : 'desc';

        return response()->json(
            $query->orderBy($sort, $dir)->paginate($perPage),
            200
        );
    }

    // GET /client/projects/{project}
    public function show($id)
{
    
    $project = Project::find($id);
    if (!$project) {
        return response()->json(['error' => 'Project not found'], 404);
    }
 
    
    $user = Auth::user();
    abort_unless($user && $user->role === 'client', 403, 'Forbidden');

    // compare against the FK column
    abort_unless((int) $project->added_by === (int) $user->id, 404, 'Project not found');
    

    $project->load('added_by.company');
    // dd($project);
    return response()->json($project, 200);
}

    // POST /client/projects
    public function store(Request $request)
    {
        $user = Auth::user();
        abort_unless($user && $user->role === 'client', 403, 'Forbidden');

        $validator = Validator::make($request->all(), [
            'name'               => ['required','string','max:255'],
            'site_contact_name'  => ['nullable','string','max:255'],
            'site_contact_phone' => ['nullable','string','max:50'],
            'site_instructions'  => ['nullable','string'],
        ]);

        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 400);
        }

        $data = $validator->validated();

        $project = Project::create([
            ...$data,
            'added_by' => $user->id, // lock to this client
        ]);

        return response()->json($project->load('added_by.company'), 201);
    }

    // PUT /client/projects/{project}
    public function update(Request $request, Project $project)
    {
        $user = Auth::user();
        abort_unless($user && $user->role === 'client', 403, 'Forbidden');
        abort_unless($project->added_by === $user->id, 404, 'Project not found');

        $validator = Validator::make($request->all(), [
            'name'               => ['sometimes','required','string','max:255'],
            'site_contact_name'  => ['nullable','string','max:255'],
            'site_contact_phone' => ['nullable','string','max:50'],
            'site_instructions'  => ['nullable','string'],
        ]);

        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 400);
        }

        $data = $validator->validated();

        // do NOT change added_by
        $project->update($data);

        return response()->json($project->fresh()->load('added_by.company'), 200);
    }

    // DELETE /client/projects/{project}
    public function destroy($id)
    {
        $project = Project::find($id);
        if (!$project) {
            return response()->json(['error' => 'Project not found'], 404);
        }
        
        $user = Auth::user();
        abort_unless($user && $user->role === 'client', 403, 'Forbidden');
        abort_unless($project->added_by === $user->id, 404, 'Project not found');

        $project->delete();
        return response()->json(['message' => 'Project deleted'], 200);
    }
}


------------------------------------------------------------
FILE: Http/Controllers/SupplierController.php
------------------------------------------------------------
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\Models\SupplierOffers;
use App\Models\MasterProducts;
use App\Models\User;
use Illuminate\Support\Facades\Validator;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Str;

class SupplierController extends Controller
{   

    /**
     * Add a product to the supplier's inventory.
     */

    public function deliveryZonesManagement(Request $request)
    {
        // Logic for managing delivery zones
        $validator = Validator::make($request->all(), [
            'zones' => 'sometimes|array',
            'zones.*.lat' => 'sometimes|numeric',
            'zones.*.long' => 'sometimes|numeric',
            'zones.*.radius' => 'sometimes|numeric',
            'zones.*.address' => 'sometimes|string|max:255',
        ]);
        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 400);
        }
        /** @var User $user */
        $user = Auth::user();
        abort_unless($user && $user->role === 'supplier', 403, 'Forbidden');
        if( !$request->zones || $request->zones === null || $request->zones === '' || count($request->zones) === 0){
            $user->delivery_zones = null;
            $user->save();
            return response()->json(['message' => 'Delivery zones cleared', 'delivery_zones' => []], 200);
        }
        $user->delivery_zones = json_encode($request->zones);
        $user->save();
        return response()->json(['message' => 'Delivery zones updated successfully', 'delivery_zones' => $user->delivery_zones], 200);
    }

    public function getDeliveryZones()
    {
        $user = Auth::user();
        abort_unless($user && $user->role === 'supplier', 403, 'Forbidden');
        if( !$user->delivery_zones || $user->delivery_zones === null || $user->delivery_zones === ''){
            return response()->json(['delivery_zones' => []], 200);
        }
        return response()->json(['delivery_zones' => $user->delivery_zones,true], 200);
    }


    /**
     * Get Master Product Inventory.
     */
    public function getMasterProductInventory(Request $request)
    {
        $perPage = (int) $request->get('per_page', 10);
        $page = (int) $request->get('page', 1); 
        $query = MasterProducts::with(['added_by', 'approved_by', 'category'])
            ->where('is_approved', true); // Only approved products

        //Apply Category filter
        if ($request->filled('category_id')) {
            $query->where('category', $request->get('category_id'));
        }
        // Apply search filter
        if ($request->filled('search')) {
            $search = $request->get('search');
            $query->where('product_name', 'like', "%{$search}%");
        }
        // Paginate after filters
        $products = $query->paginate($perPage, ['*'], 'page', $page);
        // dd($products->toArray());
        // Append supplier offers count
        $products->getCollection()->transform(function ($product) {
            $product->supplierOffersCount = SupplierOffers::where('master_product_id', $product->id)->count();
            $product->suppliers = SupplierOffers::with('supplier')->where('master_product_id', $product->id)->get();
            $product->suppliers->transform(function ($supplier) {
                $supplier->isMe = Auth::id() == $supplier->supplier_id;
                return $supplier;
            });
            return $product;
        });
        return response()->json($products, 200);
    }

    /**
     * Add a product to the supplier's inventory.
     */
    public function addProductToInventory(Request $request)
    {
        $validator = Validator::make($request->all(), [
            'master_product_id' => 'required|exists:master_products,id',
            'price' => 'required|numeric',
            'availability_status' => 'required|in:In Stock,Out of Stock,Limited',
        ]);

        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 400);
        }

        // Create supplier offer for the product
        $supplierOffer = SupplierOffers::updateOrCreate([
            'supplier_id' => Auth::id(), // Authenticated supplier
            'master_product_id' => $request->master_product_id,
            'price' => $request->price,
            'availability_status' => $request->availability_status,
            'status' => 'Pending', // Default status, awaiting approval if needed
        ]);

        return response()->json(['message' => 'Product added to inventory successfully', 'supplier_offer' => $supplierOffer], 201);
    }

    /**
     * Request a new product to be added to the master catalog.
     */
    public function requestNewProduct(Request $request)
    {
        $validator = Validator::make($request->all(), [
            'product_name' => 'required|string|max:255',
            'product_type' => 'required|string|max:255',
            'category_id' => 'nullable|exists:category,id', // Optional category
            'specifications' => 'nullable|string',
            'unit_of_measure' => 'nullable|string|max:100',
            'price' => 'required|numeric',
            'availability_status' => 'required|in:In Stock,Out of Stock,Limited',
        ]);
        
        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 400);
        }
      

        // Create a new product request (admin will approve or reject)
        $newProduct = MasterProducts::create([
            'product_name' => $request->product_name,
            'product_type' => $request->product_type,
            'category' => $request->category_id,
            'specifications' => $request->specifications,
            'unit_of_measure' => $request->unit_of_measure,
            'slug' => Str::slug($request->product_name) . '-' . Str::random(6),
            'is_approved' => false, // Pending approval by admin
            'added_by' => Auth::id(), // Supplier is adding the product
        ]);
        $supplierOffer = SupplierOffers::updateOrCreate([
            'supplier_id' => Auth::id(), // Authenticated supplier
            'master_product_id' => $newProduct->id,
            'price' => $request->price,
            'availability_status' => $request->availability_status,
            'status' => 'Pending', // Default status, awaiting approval if needed
        ]);

        return response()->json(['message' => 'Product request submitted successfully', 'new_product' => $newProduct], 201);
    }

    /**
     * View the supplier's products list.
     */
    public function getSupplierProducts(Request $request)
    {
        // Fetch supplier's products from SupplierOffers
        $supplierOffers = SupplierOffers::with(['masterProduct', 'masterProduct.category','supplier'])
            ->where('supplier_id', Auth::id())
            ->paginate(10); // Pagination if needed

        return response()->json($supplierOffers);
    }

    /**
     * Edit product pricing in the supplier's inventory.
     */
    public function updateProductPricing(Request $request, $offerId)
    {
        $validator = Validator::make($request->all(), [
            'price' => 'required|numeric',
            'availability_status' => 'required|in:In Stock,Out of Stock,Limited',
        ]);

        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 400);
        }

        // Find the existing supplier offer
        $supplierOffer = SupplierOffers::find($offerId);

        if (!$supplierOffer || $supplierOffer->supplier_id != Auth::id()) {
            return response()->json(['error' => 'Offer not found or you are not authorized to edit this offer'], 404);
        }

        // Update the product pricing and availability
        $supplierOffer->update([
            'price' => $request->price,
            'availability_status' => $request->availability_status,
        ]);

        return response()->json(['message' => 'Product pricing updated successfully', 'supplier_offer' => $supplierOffer], 200);
    }

    /**
     * Delete product from the supplier's inventory.
     */
    public function deleteProductFromInventory($offerId)
    {
        // Find the existing supplier offer
        $supplierOffer = SupplierOffers::find($offerId);
        if (!$supplierOffer || $supplierOffer->supplier_id != Auth::id()) {
            return response()->json(['error' => 'Offer not found or you are not authorized to delete this offer'], 404);
        }
        $supplierOffer->delete();
        return response()->json(['message' => 'Product removed from inventory successfully'], 200);
    }

    /**
     * Get Status of Supplier Offers.
     */
    public function getSupplierOfferStatus()
    {
        $offers = SupplierOffers::where('supplier_id', Auth::id())->get();
        return response()->json($offers, 200);
    }

}


------------------------------------------------------------
FILE: Http/Controllers/SupplierOrderController.php
------------------------------------------------------------
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\Models\Orders;
use App\Models\OrderItem;
use App\Models\MasterProducts;
use App\Models\SupplierOffers;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Validator;

class SupplierOrderController extends Controller
{
    // Helper function | Workflow 
    private function workflow(Orders $order)
    {
        $currentWorkflow = $order->workflow;

        switch ($currentWorkflow) {
            case 'Supplier Assigned':
                $allConfirmed = $order->items()->where('supplier_confirms', false)->count() === 0;
                if (!$allConfirmed) {
                    break;
                }

                // Constants
                $ADMIN_MARGIN    = 0.50;
                $DELIVERY_MARGIN = 0.10;
                $FLEET_MARGIN    = 0.15;
                $GST_RATE        = 0.05;

                // Accumulators
                $customer_item_cost     = 0.0;
                $customer_delivery_cost = 0.0;
                $supplier_item_cost     = 0.0;
                $supplier_delivery_cost = 0.0;

                foreach ($order->items as $item) {
                    // Supplier material cost
                    $base_material_cost = ($item->supplier_unit_cost * $item->quantity) - $item->supplier_discount;
                    if ($base_material_cost < 0) { $base_material_cost = 0; }
                    $supplier_item_cost += $base_material_cost;

                    // Customer item cost with admin margin or quoted override
                    if ((int)$item->is_quoted === 1 && $item->quoted_price !== null) {
                        $customer_item_cost += (float)$item->quoted_price;
                    } else {
                        $customer_item_cost += $base_material_cost * (1 + $ADMIN_MARGIN);
                    }

                    // Delivery handling
                    $dtype = (string)$item->delivery_type;
                    if ($dtype === 'Supplier' || $dtype === 'ThirdParty') {
                        $customer_delivery_cost += $item->delivery_cost * (1 + $DELIVERY_MARGIN);
                        $supplier_delivery_cost += $item->delivery_cost;
                    } elseif ($dtype === 'Fleet') {
                        $customer_delivery_cost += $item->delivery_cost * (1 + $FLEET_MARGIN);
                        $supplier_delivery_cost += $item->delivery_cost;
                    } elseif ($dtype === 'Included' || $dtype === 'None' || $dtype === '' || $dtype === null) {
                        // No delivery cost
                    } else {
                        // Unknown type: supplier bears base delivery
                        $supplier_delivery_cost += (float)$item->delivery_cost;
                    }
                }

                // GST on customer-facing costs
                $gst_tax = ($customer_item_cost + $customer_delivery_cost) * $GST_RATE;

                // Totals
                $discount      = (float)($order->discount ?? 0);
                $other_charges = (float)($order->other_charges ?? 0);

                $total_price = $customer_item_cost
                            + $customer_delivery_cost
                            + $gst_tax
                            - $discount
                            + $other_charges;

                // Profit metrics
                $supplier_total    = $supplier_item_cost + $supplier_delivery_cost;
                $profit_before_tax = $total_price - $supplier_total - $gst_tax;
                $profit_margin_percent = $supplier_total > 0 ? ($profit_before_tax / $supplier_total) : 0.0;

                // Save to order
                $order->customer_item_cost     = round($customer_item_cost, 2);
                $order->customer_delivery_cost = round($customer_delivery_cost, 2);
                $order->supplier_item_cost     = round($supplier_item_cost, 2);
                $order->supplier_delivery_cost = round($supplier_delivery_cost, 2);
                $order->gst_tax                = round($gst_tax, 2);
                $order->total_price            = round($total_price, 2);

                // Actual profit amount (not percentage)
                $order->profit_amount          = round($profit_before_tax, 2);
                $order->profit_margin_percent  = round($profit_margin_percent,2);

                $order->workflow = 'Payment Requested';
                // dd($customer_item_cost, $customer_delivery_cost, $supplier_item_cost, $supplier_delivery_cost, $profit_margin_percent, $profit_before_tax);
                $order->save();

                break;
        }
    }


    // public function getSupplierOrders(Request $request)
    // {
    //     $user = Auth::user();

    //     // Pagination and filtering parameters
    //     $perPage = (int) $request->get('per_page', 10);
    //     $search = trim((string) $request->get('search', ''));
    //     $confirmed = $request->get('supplier_confirms');
    //     $deliveryDate = $request->get('supplier_delivery_date');
    //     $productId = $request->get('product_id');
    //     $details = $request->boolean('details', false);

    //     // Base query for supplier's order items - reusable for all metrics
    //     $baseQuery = function () use ($user, $search, $confirmed, $deliveryDate, $productId) {
    //         $query = OrderItem::where('supplier_id', $user->id);

    //         // Apply search filter (by product name)
    //         if (!empty($search)) {
    //             $query->whereHas('product', function ($q) use ($search) {
    //                 $q->where('product_name', 'like', '%' . $search . '%');
    //             });
    //         }

    //         // Apply confirmed filter
    //         if ($confirmed !== null) {
    //             $query->where('supplier_confirms', filter_var($confirmed, FILTER_VALIDATE_BOOLEAN));
    //         }

    //         // Apply delivery date filter
    //         if (!empty($deliveryDate)) {
    //             $query->whereDate('supplier_delivery_date', $deliveryDate);
    //         }

    //         // Apply product ID filter
    //         if (!empty($productId)) {
    //             $query->where('product_id', $productId);
    //         }

    //         return $query;
    //     };

    //     // Get metrics with applied filters
    //     $totalOrdersCount = $baseQuery()->count();
    //     $supplierConfirmedCount = $baseQuery()->where('supplier_confirms', true)->count();
    //     $awaitingPaymentCount = $baseQuery()->where('is_paid', false)->count();
    //     $deliveredCount = $baseQuery()->whereHas('order', function ($query) {
    //         $query->where('workflow', 'Delivered');
    //     })->count();

    //     // Get paginated results using the same base query
    //     $orderItemsQuery = $baseQuery()->with(['order', 'product', 'chosenOffer']);
    //     $orderItems = $orderItemsQuery->orderBy('created_at', 'desc')->paginate($perPage);

    //     // Prepare response data
    //     $data = [
    //         'data' => $orderItems->items(),
    //         'pagination' => [
    //             'current_page' => $orderItems->currentPage(),
    //             'per_page' => $orderItems->perPage(),
    //             'total' => $orderItems->total(),
    //             'last_page' => $orderItems->lastPage(),
    //         ],
    //         'metrics' => [
    //             'total_orders_count' => $totalOrdersCount,
    //             'supplier_confirmed_count' => $supplierConfirmedCount,
    //             'awaiting_payment_count' => $awaitingPaymentCount,
    //             'delivered_count' => $deliveredCount,
    //         ]
    //     ];

    //     // Add filters data if details=true
    //     if ($details) {
    //         // Get products that this supplier offers
    //         $supplierProducts = MasterProducts::whereHas('supplierOffers', function ($query) use ($user) {
    //             $query->where('supplier_id', $user->id);
    //         })
    //         ->select('id', 'product_name', 'photo')
    //         ->get()
    //         ->map(function ($product) {
    //             return [
    //                 'id' => $product->id,
    //                 'product_name' => $product->product_name,
    //                 'photo' => $product->photo,
    //             ];
    //         });

    //         $data['filters'] = [
    //             'products' => $supplierProducts
    //         ];
    //     }

    //     return response()->json([
    //         'success' => true,
    //         'data' => $data
    //     ]);
    // }
    public function getSupplierOrders(Request $request)
    {
        $user = Auth::user();

        // Pagination and filtering parameters
        $perPage = (int) $request->get('per_page', 10);
        $search = trim((string) $request->get('search', ''));
        $confirmed = $request->get('supplier_confirms');
        $deliveryDate = $request->get('supplier_delivery_date');
        $productId = $request->get('product_id');
        $details = $request->boolean('details', false);
        // dd($user);
        // Base query for orders that have items assigned to this supplier
        $baseQuery = function () use ($user, $search, $confirmed, $deliveryDate, $productId) {
            $query = Orders::whereHas('items', function ($q) use ($user, $search, $confirmed, $deliveryDate, $productId) {
                $q->where('supplier_id', $user->id);

                // Apply search filter (by product name)
                if (!empty($search)) {
                    $q->whereHas('product', function ($productQuery) use ($search) {
                        $productQuery->where('product_name', 'like', '%' . $search . '%');
                    });
                }

                // Apply confirmed filter
                if ($confirmed !== null) {
                    $q->where('supplier_confirms', filter_var($confirmed, FILTER_VALIDATE_BOOLEAN));
                }

                // Apply delivery date filter
                if (!empty($deliveryDate)) {
                    $q->whereDate('supplier_delivery_date', $deliveryDate);
                }

                // Apply product ID filter
                if (!empty($productId)) {
                    $q->where('product_id', $productId);
                }
            });

            return $query;
        };

        // Get metrics with applied filters
        $totalOrdersCount = $baseQuery()->count();
        
        $supplierConfirmedCount = Orders::whereHas('items', function ($q) use ($user, $search, $confirmed, $deliveryDate, $productId) {
            $q->where('supplier_id', $user->id)
            ->where('supplier_confirms', true);

            // Apply the same filters for consistency
            if (!empty($search)) {
                $q->whereHas('product', function ($productQuery) use ($search) {
                    $productQuery->where('product_name', 'like', '%' . $search . '%');
                });
            }
            if (!empty($deliveryDate)) {
                $q->whereDate('supplier_delivery_date', $deliveryDate);
            }
            if (!empty($productId)) {
                $q->where('product_id', $productId);
            }
        })->count();
        
        // $awaitingPaymentCount = Orders::whereHas('items', function ($q) use ($user, $search, $confirmed, $deliveryDate, $productId) {
        //     $q->where('supplier_id', $user->id)
        //     ->where('is_paid', false);
        $awaitingPaymentCount = Orders::where(function ($orderQuery) use ($user) {
        $orderQuery->whereNull('supplier_paid_ids')
                ->orWhereJsonDoesntContain('supplier_paid_ids', $user->id); // User ID not in paid list
        })
        ->whereHas('items', function ($q) use ($user, $search, $confirmed, $deliveryDate, $productId) {
            $q->where('supplier_id', $user->id);

            // Optional filters
            if (!empty($search)) {
                $q->whereHas('product', function ($productQuery) use ($search) {
                    $productQuery->where('product_name', 'like', '%' . $search . '%');
                });
            }

            if (!empty($deliveryDate)) {
                $q->whereDate('supplier_delivery_date', $deliveryDate);
            }

            if (!empty($productId)) {
                $q->where('product_id', $productId);
            }
        })->count();


        
        $deliveredCount = $baseQuery()->where('workflow', 'Delivered')->count();

        // Get paginated results with supplier's items count and relationship
        $ordersQuery = $baseQuery()->with(['items' => function ($query) use ($user) {
            $query->where('supplier_id', $user->id)
                ->with(['product', 'chosenOffer']);
        }]);

        $orders = $ordersQuery->orderBy('created_at', 'desc')->paginate($perPage);

        // Transform the response to include items count for this supplier
        $transformedOrders = $orders->getCollection()->map(function ($order) use ($user) {
            $supplierItems = $order->items->where('supplier_id', $user->id);
            $totalAmount = 0;
            foreach ($supplierItems as $item) {
                $itemCost = ($item->supplier_unit_cost * $item->quantity) - $item->supplier_discount + $item->supplier_delivery_cost;
                $totalAmount += $itemCost;
            }

            return [
                'id' => $order->id,
                'po_number' => $order->po_number,          // was 'order_number'
                'order_status' => $order->order_status,    // show status to suppliers
                // 'workflow' => $order->workflow,         // remove from supplier view
                'total_amount' => $totalAmount,
                'created_at' => $order->created_at,
                'updated_at' => $order->updated_at,
                'supplier_items_count' => $supplierItems->count(),
                'supplier_items' => $supplierItems->map(function ($item) {
                    return [
                        'id' => $item->id,
                        'product_id' => $item->product_id,
                        'quantity' => $item->quantity,
                        'supplier_unit_cost' => $item->supplier_unit_cost,
                        // 'supplier_delivery_cost' => $item->supplier_delivery_cost,
                        'delivery_cost' => $item->delivery_cost ?? null,  // keep if present in model
                        'delivery_type' => $item->delivery_type ?? null,  // keep if present in model
                        'supplier_discount' => $item->supplier_discount,
                        'supplier_delivery_date' => $item->supplier_delivery_date,
                        'supplier_confirms' => $item->supplier_confirms,
                        'supplier_notes' => $item->supplier_notes ?? null,
                        'product' => $item->product,
                        'chosen_offer' => $item->chosenOffer,
                    ];
                }),
            ];
        });

        // Prepare response data
        $data = [
            'data' => $transformedOrders,
            'pagination' => [
                'current_page' => $orders->currentPage(),
                'per_page' => $orders->perPage(),
                'total' => $orders->total(),
                'last_page' => $orders->lastPage(),
            ],
            'metrics' => [
                'total_orders_count' => $totalOrdersCount,
                'supplier_confirmed_count' => $supplierConfirmedCount,
                'awaiting_payment_count' => $awaitingPaymentCount,
                'delivered_count' => $deliveredCount,
            ]
        ];

        // Add filters data if details=true
        if ($details) {
            // Get products that this supplier offers
            $supplierProducts = MasterProducts::whereHas('supplierOffers', function ($query) use ($user) {
                $query->where('supplier_id', $user->id);
            })
            ->select('id', 'product_name', 'photo')
            ->get()
            ->map(function ($product) {
                return [
                    'id' => $product->id,
                    'product_name' => $product->product_name,
                    'photo' => $product->photo,
                ];
            });

            $data['filters'] = [
                'products' => $supplierProducts
            ];
        }

        return response()->json([
            'success' => true,
            'data' => $data
        ]);
    }

    public function updateOrderPricing(Request $request, OrderItem $orderItem)
    {
        $v = Validator::make($request->all(), [
            'supplier_unit_cost' => 'sometimes|required|numeric|min:0',
            'supplier_discount' => 'sometimes|required|numeric|min:0',
            'supplier_delivery_date' => 'sometimes|required|date',
            'supplier_confirms' => 'sometimes|required|boolean',
            'delivery_cost' => 'sometimes|required|numeric|min:0',
            'delivery_type'=> 'required|in:Included,Supplier,ThirdParty,Fleet,None ',
            'supplier_notes' => 'sometimes|nullable|string|max:500'
        ]);

        if ($v->fails()) {
            return response()->json(['error' => $v->errors()], 422);
        }

        // Check if the authenticated user is the supplier for this order item
        $user = Auth::user();

        if(!in_array($orderItem->order->workflow, ['Supplier Assigned', 'Requested'])) {  //, 'Payment Requested', 'On Hold', 'Delivered'
            return response()->json([
                'message' => 'Cannot update order item now as the order is in '.$orderItem->order->workflow.' status'
            ], 403);
        }   
        if ($orderItem->supplier_id !== $user->id) {
            return response()->json([
                'message' => 'You are not authorized to update this order item'
            ], 403);
        }
// dd($orderItem->supplier_confirms);
        // Check if order item is already confirmed
        if ($orderItem->supplier_confirms && $request->has('supplier_confirms') && !$request->supplier_confirms) {
            return response()->json([
                'message' => 'Cannot unconfirm an already confirmed order item'
            ], 422);
        }

        try {
            DB::beginTransaction();

            // Update the order item with provided fields
            $updateData = [];
            
            if ($request->has('supplier_unit_cost')) {
                $updateData['supplier_unit_cost'] = $request->supplier_unit_cost;
            }
            
            if ($request->has('delivery_cost')) {
                $updateData['delivery_cost'] = $request->delivery_cost;
            }
            
            if ($request->has('supplier_discount')) {
                $updateData['supplier_discount'] = $request->supplier_discount;
            }

            if ($request->has('delivery_type')) {
                $updateData['delivery_type'] = $request->delivery_type;
            }
            
            if ($request->has('supplier_delivery_date')) {
                $updateData['supplier_delivery_date'] = $request->supplier_delivery_date;
            }
            
            if ($request->has('supplier_confirms')) {
                $updateData['supplier_confirms'] = $request->supplier_confirms;
            }
            
            if ($request->has('supplier_notes')) {
                $updateData['supplier_notes'] = $request->supplier_notes;
            }

            // Update the order item
            $orderItem->update($updateData);

            // If supplier confirmed the order, trigger workflow check
            if ($request->has('supplier_confirms') && $request->supplier_confirms) {
                $this->workflow($orderItem->order);
            }

            DB::commit();

            // Reload the order item with relationships
            $orderItem->load(['order', 'product', 'chosenOffer']);

            return response()->json([
                'success' => true,
                'message' => 'Order item updated successfully',
                'data' => $orderItem
            ]);

        } catch (\Exception $e) {
            DB::rollBack();
            return response()->json([
                'error' => 'Failed to update order item: ' . $e->getMessage()
            ], 500);
        }
    }

    public function viewOrderDetails(Orders $order)
    {
        $user = Auth::user();

        // Ensure the supplier has items in this order
        $supplierItems = $order->items()->where('supplier_id', $user->id)->with(['product', 'chosenOffer'])->get();

        if ($supplierItems->isEmpty()) {
            return response()->json([
                'error' => 'You do not have any items in this order'
            ], 403);
        }

        // Reload the order with only selected fields and relationships
        $order = Orders::where('id', $order->id)
            ->select([
                'id',
                'po_number', // Make sure this field exists in your table
                'project_id',
                'client_id',
                'workflow',
                'delivery_address',
                'delivery_date',
                'delivery_time',
                'delivery_window',
                'delivery_method',
                'load_size',
                'special_equipment',
                'special_notes',
                'created_at',
                'updated_at'
            ])
            ->with(['client:id,name,email', 'project:id,name,site_contact_name,site_contact_phone,site_instructions'])
            ->first();

        return response()->json([
            'success' => true,
            'data' => [
                'order' => $order,
                'supplier_items' => $supplierItems
            ]
        ]);
    }



    
}


------------------------------------------------------------
FILE: Http/Controllers/UserManagement.php
------------------------------------------------------------
<?php
namespace App\Http\Controllers;

use App\Models\User;
use App\Models\Company;
use App\Models\Category;
use Illuminate\Http\Request;
use Illuminate\Support\Str;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Facades\Validator;
use Illuminate\Support\Facades\Storage;

class UserManagement extends Controller
{
    // List Users with Multiple Filters and Pagination
    public function index(Request $request)
    {
        $query = User::query();

        // Filters
        if ($request->has('role') && in_array($request->role, ['admin', 'client', 'supplier'])) {
          
            $query->where('role', $request->role);
        }

        if ($request->has('isDeleted')) {
        // Ensure the value is treated as a boolean (either true or false)
        $isDeleted = filter_var($request->isDeleted, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE);

        // If valid, apply the filter
        if ($isDeleted !== null) {
            $query->where('isDeleted', $isDeleted);
        }
}

        if ($request->has('company_id') && is_numeric($request->company_id)) {
            $query->where('company_id', $request->company_id);
        }

        if ($request->has('contact_name')) {
            $query->where('contact_name', 'like', '%' . $request->contact_name . '%');
        }

        if ($request->has('location')) {
            $query->where('location', 'like', '%' . $request->location . '%');
        }

        if ($request->has('lat') && $request->has('long')) {
            $query->where('lat', $request->lat)->where('long', $request->long);
        }

        // Get the 'per_page' value from the request, default to 10 if not provided
        $perPage = $request->get('per_page', 10); // Default to 10 if no value is provided

        // Pagination
        $users = $query->paginate($perPage);

        return response()->json($users);
    }

    
    // Add User
    public function store(Request $request)
    {
        // Manual validation handling (same as in registerSupplier)
        $validator = Validator::make($request->all(), [
            'name' => 'required|string|max:255',
            'email' => 'required|email|unique:users,email',
            'password' => 'required|string|min:6',
            'role' => 'required|string|in:admin,client,supplier',
            'company_name' => 'nullable|string|max:255', // Make sure the company name is optional
            'contact_name' => 'nullable|string|max:255',
            'contact_number' => 'nullable|string|max:255',
            'location' => 'nullable|string|max:255',
            'lat' => 'nullable|numeric',
            'long' => 'nullable|numeric',
            'delivery_radius' => 'nullable|numeric',
            'shipping_address' => 'nullable|string|max:255',
            'billing_address' => 'nullable|string|max:255',
            'client_public_id' => 'nullable|string|unique:users,client_public_id',
            'profile_image' => 'nullable|image|mimes:jpg,png,jpeg,gif',
            'notes' => 'nullable|string|max:1000',
        ]);

        // Check if validation fails
        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 400);
        }

        // Handle Company ID if it's for client or supplier
        $company_id = null;
        if ($request->role !== 'admin' && $request->has('company_name')) {
            // Look for the company by name, or create it if not found
            $company = Company::firstOrCreate([
                'name' => Str::lower($request->company_name),  // Company name is case-insensitive
            ]);

            // Assign the found or created company ID
            $company_id = $company->id;
        }

        // Handle Profile Image
        $imageUrl = null;
        if ($request->hasFile('profile_image') && $request->file('profile_image')->isValid()) {
            // Store the file under 'profile_images' directory in the 'public' disk
            $path = $request->file('profile_image')->store('profile_images', 'public');
            $imageUrl = 'storage/' . $path; // Relative path to the image
        }

        // Create the User
        $user = User::create([
            'name' => $request->name,
            'email' => $request->email,
            'password' => Hash::make($request->password),
            'role' => $request->role,
            'company_id' => $company_id,  // Assign company_id (can be null or an existing company ID)
            'contact_name' => $request->contact_name,
            'contact_number' => $request->contact_number,
            'location' => $request->location,
            'lat' => $request->lat,
            'long' => $request->long,
            'delivery_radius' => $request->delivery_radius,
            'shipping_address' => $request->shipping_address,
            'billing_address' => $request->billing_address,
            'client_public_id' => $request->client_public_id ?? 'MC-' . rand(100, 999),
            'profile_image' => $imageUrl,
            'isDeleted' => false,
            'notes' => $request->notes,
        ]);

        // Return the created user along with a success message and profile image URL
        return response()->json([
            'message' => 'User registered successfully.',
            'user' => $user,
            'role' => $user->role,
            'profile_image_url' => $imageUrl, // Return the image URL in response
        ], 201);
    }

    // Show User Details
    public function show($id)
    {
        $user = User::with('company')->find($id);
        if (!$user) {
            return response()->json(['error' => 'User not found'], 404);
        }
        return response()->json($user);
    }

    // Update User
    public function update(Request $request, $id)
    {
        // Find the user by ID
        $user = User::find($id);
        if (!$user) {
            return response()->json(['error' => 'User not found'], 404);
        }

        // Validate the request
        $validator = Validator::make($request->all(), [
            'name' => 'string|max:255',
            'email' => 'email|unique:users,email,' . $id,
            'password' => 'nullable|string|min:6',
            'role' => 'string|in:admin,client,supplier',
            'contact_name' => 'nullable|string|max:255',
            'contact_number' => 'nullable|string|max:255',
            'location' => 'nullable|string|max:255',
            'lat' => 'nullable|numeric',
            'long' => 'nullable|numeric',
            'delivery_radius' => 'nullable|numeric',
            'shipping_address' => 'nullable|string|max:255',
            'billing_address' => 'nullable|string|max:255',
            'profile_image' => 'nullable|image|mimes:jpg,png,jpeg,gif,webp',
            'notes' => 'nullable|string|max:1000',
        ]);

        // Check if validation fails
        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 400);
        }

        // Handle Profile Image
        $profileImagePath = $user->profile_image; // Existing profile image path

        if ($request->hasFile('profile_image')) {
            // Check if there's an old image and delete it before uploading the new one
            if ($profileImagePath) {
                $oldImagePath = str_replace('storage/', '', $profileImagePath); // Get the relative path
                $oldImagePath = 'storage/app/public/' . $oldImagePath;
                if (Storage::exists($oldImagePath)) {
                    Storage::delete($oldImagePath); // Delete the old image
                }
            }

            // Store the new profile image
            $profileImagePath = 'storage/'.$request->file('profile_image')->store('profile_images', 'public');
        }

        // Update the User with the new data
        $user->update([
            'name' => $request->name ?? $user->name,
            'email' => $request->email ?? $user->email,
            'password' => $request->password ? Hash::make($request->password) : $user->password,
            'role' => $request->role ?? $user->role,
            'contact_name' => $request->contact_name ?? $user->contact_name,
            'contact_number' => $request->contact_number ?? $user->contact_number,
            'location' => $request->location ?? $user->location,
            'lat' => $request->lat ?? $user->lat,
            'long' => $request->long ?? $user->long,
            'delivery_radius' => $request->delivery_radius ?? $user->delivery_radius,
            'shipping_address' => $request->shipping_address ?? $user->shipping_address,
            'billing_address' => $request->billing_address ?? $user->billing_address,
            'profile_image' => $profileImagePath ? $profileImagePath : $user->profile_image, // Store the relative path
            'notes' => $request->notes ?? $user->notes,
        ]);

        // Return the updated user information as a JSON response
        return response()->json($user->load('company'));
    }

    // Soft Delete User (Mark isDeleted as true)
    public function destroy($id)
    {
        $user = User::find($id);
        if (!$user) {
            return response()->json(['error' => 'User not found'], 404);
        }

        // Mark the user as deleted
        if($user->isDeleted){
            $user->update(['isDeleted' => false]);
            return response()->json(['message' => 'User restored successfully']);
        }
        $user->update(['isDeleted' => true]);

        return response()->json(['message' => 'User marked as deleted successfully']);
    }

    // Check if Company Exists
    public function checkCompany(Request $request)
    {
        $companyName = Str::lower($request->company_name);
        $company = Company::where('name', $companyName)->first();

        if ($company) {
            return response()->json(['exists' => true, 'company_id' => $company->id]);
        } else {
            return response()->json(['exists' => false]);
        }
    }


    public function addCategory(Request $request)
    {

        $validator = Validator::make($request->all(), [
            'name' => 'required|string|max:120|unique:category,name',
        ]);

        // Check if validation fails
        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 400);
        }

        $category = Category::create([
            'name' => $request->name,
        ]);
        return response()->json(['message' => 'Category added successfully', 'category' => $category], 201);
    }
    public function listCategories(Request $request)
    {
        // Default pagination parameters
        $perPage = $request->get('per_page', 10);  // Default 10 items per page
        $page = $request->get('page', 1);
        // Fetch categories with pagination
        $categories = Category::paginate($perPage);
        return response()->json($categories, 200);
    }

    public function deleteCategory($id)
    {
        $category = Category::find($id);
        if (!$category) {
            return response()->json(['error' => 'Category not found'], 404);
        }
        $category->delete();
        return response()->json(['message' => 'Category deleted successfully'], 200);
    }

    public function updateCategory(Request $request, $id)
    {
        $category = Category::find($id);
        if (!$category) {
            return response()->json(['error' => 'Category not found'], 404);
        }

        $data = $request->validate([
            'name' => 'required|string|max:120|unique:category,name,' . $id,
        ]);

        $category->update([
            'name' => $data['name'],
        ]);

        return response()->json(['message' => 'Category updated successfully', 'category' => $category], 200);
    }

    public function getCategory($id)
    {
      
        $category = Category::find($id);
        if (!$category) {
            return response()->json(['error' => 'Category not found'], 404);
        }
        return response()->json($category, 200);
    }

    public function getCompanies()
    {
        $companies = Company::all();
        return response()->json($companies);
    }

    public function getSuppliersWithDeliveryZones(Request $request)
    {
        $perPage = (int) $request->get('per_page', 10);
        $search = $request->get('search');

        $suppliers = User::where('role', 'supplier')
            ->whereNotNull('delivery_zones')
            ->where('delivery_zones', '!=', '[]')
            ->when($search, function ($query) use ($search) {
                return $query->where('name', 'like', '%' . $search . '%');
            })
            ->select('id', 'name', 'email', 'profile_image', 'delivery_zones')
            ->paginate($perPage);

        // Decode JSON for each supplier in paginated result
        $suppliers->getCollection()->transform(function ($supplier) {
            $supplier->delivery_zones = json_decode($supplier->delivery_zones, true);
            return $supplier;
        });

        return response()->json($suppliers);
    }

}


------------------------------------------------------------
FILE: Http/Middleware/AuthMiddleware.php
------------------------------------------------------------
<?php
// app/Http/Middleware/AuthMiddleware.php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Auth;

class AuthMiddleware
{
    public function handle(Request $request, Closure $next): Response
    {
        $path = $request->path();
        $isAuthenticated = Auth::check();
        
        Log::info('AuthMiddleware Debug', [
            'path' => $path,
            'authenticated' => $isAuthenticated,
            'user_id' => $isAuthenticated ? Auth::id() : null,
            'session_id' => session()->getId(),
            'cookie_received' => $request->cookie(config('session.cookie'))
        ]);

        // Public routes that don't require authentication
        $publicRoutes = ['login', 'register', 'login-submit', 'register-submit', 'logout', '', 'debug-auth', 'debug-sessions', 'reset-sessions', 'debug-session-full'];
        
        // If not authenticated and trying to access protected route
        if (!$isAuthenticated && !in_array($path, $publicRoutes)) {
            Log::warning('Redirecting to login - not authenticated', [
                'session_match' => $request->cookie(config('session.cookie')) === session()->getId()
            ]);
            return redirect()->route('login')->withErrors(['message' => 'Please log in to access this page.']);
        }

        Log::info('Allowing request to proceed');
        return $next($request);
    }
}

------------------------------------------------------------
FILE: Http/Middleware/IsAdmin.php
------------------------------------------------------------
<?php
namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Illuminate\Http\Response;

class isAdmin
{
    /**
     * Handle an incoming request.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \Closure  $next
     * @return \Illuminate\Http\Response
     */
    public function handle(Request $request, Closure $next)
    {
        // Ensure the user is authenticated before checking role
        $user = auth()->user();
      
        if (!$user) {
            // Return an unauthorized response if the user is not authenticated
            return response()->json(['message' => 'Unauthorized'], 401);  // Explicitly returning JsonResponse, but it's fine in this context
        }

        // Check if the authenticated user is an admin
        if ($user->role !== 'admin') {
            // Return a forbidden response if the user is not an admin
            return response()->json(['message' => 'Forbidden. Admin access only.'], 403);  // Explicitly returning JsonResponse
        }

        // Allow the request to proceed to the next middleware or controller
        return $next($request);  // This is a valid return, it doesn't return a JsonResponse
    }
}


------------------------------------------------------------
FILE: Http/Middleware/IsClient.php
------------------------------------------------------------
<?php
namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Illuminate\Http\Response;
use Illuminate\Support\Facades\Auth;
class isClient
{
    /**
     * Handle an incoming request.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \Closure  $next
     * @return \Illuminate\Http\Response
     */
    public function handle(Request $request, Closure $next)
    {
        // Ensure the user is authenticated before checking role
        $user = Auth::user();
      
        if (!$user) {
            // Return an unauthorized response if the user is not authenticated
            return response()->json(['message' => 'Unauthorized'], 401);  
        }

        // Check if the authenticated user is an client
        if (Auth::user()->role !== 'client') {
            // Return a forbidden response if the user is not an client
            return response()->json(['message' => 'Forbidden. Client access only.'], 403);  // Explicitly returning JsonResponse
        }

        // Allow the request to proceed to the next middleware or controller
        return $next($request);  // This is a valid return, it doesn't return a JsonResponse
    }
}


------------------------------------------------------------
FILE: Http/Middleware/IsSupplier.php
------------------------------------------------------------
<?php
namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;

class isSupplier
{
    /**
     * Handle an incoming request.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \Closure  $next
     * @return \Illuminate\Http\Response
     */
    public function handle(Request $request, Closure $next)
    {
        // Ensure the user is authenticated before checking role
        $user = Auth::user();
      
        if (!$user) {
            // Return an unauthorized response if the user is not authenticated
            return response()->json(['message' => 'Unauthorized'], 401);  
        }

        // Check if the authenticated user is an supplier
        if (Auth::user()->role !== 'supplier') {
            // Return a forbidden response if the user is not an supplier
            return response()->json(['message' => 'Forbidden. Supplier access only.'], 403);  // Explicitly returning JsonResponse
        }

        // Allow the request to proceed to the next middleware or controller
        return $next($request);  // This is a valid return, it doesn't return a JsonResponse
    }
}


------------------------------------------------------------
FILE: Models/Category.php
------------------------------------------------------------
<?php
namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Category extends Model
{
    use HasFactory;

    protected $table = 'category';

    protected $fillable = ['name'];


    public function products()
    {
        return $this->hasMany(MasterProducts::class, 'category');
    }
}


------------------------------------------------------------
FILE: Models/Company.php
------------------------------------------------------------
<?php
namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Company extends Model
{
    use HasFactory;

    protected $table = 'companies';

    protected $fillable = ['name'];

    public function users()
    {
        return $this->hasMany(User::class);
    }
}


------------------------------------------------------------
FILE: Models/MasterProducts.php
------------------------------------------------------------
<?php
namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class MasterProducts extends Model
{
    protected $table = 'master_products';
    protected $fillable = ['product_name', 'product_type', 'specifications', 'unit_of_measure', 'tech_doc', 'photo','is_approved','added_by','approved_by', 'slug', 'category'];

    public function supplierOffers()
    {
        return $this->hasMany(SupplierOffers::class, 'master_product_id');
    }

    public function category()
    {
        return $this->belongsTo(Category::class, 'category')->select('id', 'name');
    }

    public function added_by()
    {
        return $this->belongsTo(User::class, 'added_by')->select('id', 'name', 'email','profile_image');
    }

    // Relationship with the user who approved the product
    public function approved_by()
    {
        return $this->belongsTo(User::class, 'approved_by')->select('id', 'name', 'email','profile_image');
    }
}


------------------------------------------------------------
FILE: Models/OrderItem.php
------------------------------------------------------------
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\{BelongsTo};

class OrderItem extends Model
{
    protected $table = 'order_items';

    protected $fillable = [
        'order_id',
        'product_id',
        'quantity',
        'supplier_id',
        'custom_blend_mix',
        'supplier_unit_cost',
        'supplier_delivery_cost',
        'supplier_discount',
        'supplier_delivery_date',
        'choosen_offer_id',
        'suppier_notes',
        'supplier_confirms',
        'delivery_type',
        'delivery_cost',
        'is_qouted',
        'quoted_price',
        'is_paid',
    ];

    protected $casts = [
        'quantity'               => 'decimal:2',
        'supplier_unit_cost'     => 'decimal:2',
        'supplier_delivery_cost' => 'decimal:2',
        'supplier_discount'      => 'decimal:2',
        'quoted_price'           => 'decimal:2',
        'delivery_cost'          => 'decimal:2',
        'supplier_confirms'      => 'boolean',
        'is_paid'                => 'boolean',
        'is_qouted'              => 'boolean',
        'supplier_delivery_date' => 'datetime',

    ];

    // Relations
    public function order(): BelongsTo
    {
        return $this->belongsTo(Orders::class, 'order_id');
    }

    public function product(): BelongsTo
    {
        return $this->belongsTo(MasterProducts::class, 'product_id');
    }

    public function supplier(): BelongsTo
    {
        return $this->belongsTo(User::class, 'supplier_id');
    }

    public function chosenOffer(): BelongsTo
    {
        return $this->belongsTo(SupplierOffers::class, 'choosen_offer_id');
    }
}


------------------------------------------------------------
FILE: Models/Orders.php
------------------------------------------------------------
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\{BelongsTo, HasMany, HasManyThrough};

class Orders extends Model
{
    protected $table = 'orders';

    protected $fillable = [
        'po_number',
        'client_id',
        'project_id',
        'delivery_address',
        'delivery_lat',
        'delivery_long',
        'delivery_date',
        'delivery_time',
        'delivery_window',
        'delivery_method',
        'load_size',
        'special_equipment',
        'subtotal',
        'fuel_levy',
        'other_charges',
        'gst_tax',
        'discount',
        'total_price',
        'supplier_cost',
        'customer_cost',
        'customer_item_cost',
        'customer_delivery_cost',
        'payment_status',
        'order_status',
        'workflow',
        'reason',
        'repeat_order',
        'generate_invoice',
        'order_process',
        'special_notes',
        'supplier_paid_ids',
    ];

    protected $casts = [
        'delivery_date'     => 'datetime',
        'delivery_time'     => 'datetime:H:i:s',
        'delivery_lat'      => 'float',
        'delivery_long'     => 'float',
        'subtotal'          => 'decimal:2',
        'fuel_levy'         => 'decimal:2',
        'other_charges'     => 'decimal:2',
        'gst_tax'           => 'decimal:2',
        'discount'          => 'decimal:2',
        'total_price'       => 'decimal:2',
        'supplier_cost'     => 'decimal:2',
        'customer_cost'     => 'decimal:2',
        'customer_item_cost'         => 'decimal:2',
        'customer_delivery_cost'     => 'decimal:2',
        'supplier   _item_cost'         => 'decimal:2',
        'supplier   _delivery_cost'     => 'decimal:2',
        'profit_amount'      => 'decimal:2',
        'profit_margin_percent'      => 'decimal:2',
        'admin_margin'      => 'decimal:2',
        'repeat_order'      => 'boolean',
        'generate_invoice'  => 'boolean',
    ];

    // Enums as constants (optional helpers)
    public const PAYMENT_STATUS = ['Pending','Paid','Partially Paid','Partial Refunded','Refunded','Requested'];
    public const ORDER_STATUS   = ['In-Progress','Completed','Cancelled'];
    public const DELIVERY_WINDOW = ['Morning','Afternoon','Evening'];
    public const DELIVERY_METHOD = ['Other','Tipper','Agitator','Pump','Ute'];
    public const ORDER_PROCESS   = ['Automated','Action Required'];
    public const WORKFLOW        = ['Requested','Supplier Missing','Supplier Assigned','Payment Requested','On Hold','Delivered'];

    // Relations
    public function client(): BelongsTo
    {
        return $this->belongsTo(User::class, 'client_id');
    }

    public function project(): BelongsTo
    {
        return $this->belongsTo(Projects::class, 'project_id');
    }

    public function items(): HasMany
    {
        return $this->hasMany(OrderItem::class, 'order_id');
    }

    // Convenience: unique suppliers on this order
    public function suppliers(): HasManyThrough
    {
        return $this->hasManyThrough(
            User::class,
            OrderItem::class,
            'order_id',   // OrderItem foreign key...
            'id',         // User local key
            'id',         // Order local key
            'supplier_id' // OrderItem supplier key
        )->whereNotNull('order_items.supplier_id')->distinct();
    }

    // Scopes
    public function scopeForClient($q, int $clientId) { return $q->where('client_id', $clientId); }
    public function scopeStatus($q, string $status)   { return $q->where('order_status', $status); }
}


------------------------------------------------------------
FILE: Models/Projects.php
------------------------------------------------------------
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;


class Projects extends Model
{
    use HasFactory;

    // Define the table associated with the model
    protected $table = 'projects';

    // Define the fields that are mass assignable
    protected $fillable = [
        'name',
        'site_contact_name',
        'site_contact_phone',
        'site_instructions',
        'added_by',
    ];

    // Define the relationship to the User model
    public function added_by()
    {
        return $this->belongsTo(User::class, 'added_by')->select('id','name','email','profile_image');  // 'added_by' is the foreign key
    }
}


------------------------------------------------------------
FILE: Models/SupplierOffers.php
------------------------------------------------------------
<?php
namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class SupplierOffers extends Model
{
    protected $table = 'supplier_offers';
    protected $fillable = ['supplier_id', 'master_product_id', 'price', 'availability_status', 'status'];

    public function masterProduct()
    {
        return $this->belongsTo(MasterProducts::class);
    }

    public function supplier()
    {
        return $this->belongsTo(User::class, 'supplier_id')
            ->select('id', 'name', 'email', 'profile_image', 'delivery_zones')
            ->withCasts(['delivery_zones' => 'array']);
    }
}


------------------------------------------------------------
FILE: Models/User.php
------------------------------------------------------------
<?php

namespace App\Models;

use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Laravel\Sanctum\HasApiTokens; 


class User extends Authenticatable
{
    use HasFactory, Notifiable, HasApiTokens;

    protected $fillable = [
        'name',
        'email',
        'password',
        'role',
        'company_id',
        'contact_name',
        'contact_number',
        'location',
        'lat',
        'long',
        'delivery_radius',
        'shipping_address',
        'billing_address',
        'client_public_id',
        'profile_image',
        'isDeleted',
        'notes',
        'delivery_zones',
    ];

    protected $hidden = ['password', 'remember_token'];
    protected $casts = [
        'isDeleted' => 'boolean',
        'lat' => 'float',
        'long' => 'float',
        'delivery_zones' => 'array',
    ];


    // If it's stored as TEXT and not JSON type, use accessor:
    public function getDeliveryZonesAttribute($value)
    {
        return $value ? json_decode($value, true) : [];
    }

    public function company()
    {
        return $this->belongsTo(Company::class);
    }

    public function projects()
    {
        return $this->hasMany(Projects::class, 'added_by');  // 'added_by' is the foreign key
    }

    public function supplierOffers()
    {
        return $this->hasMany(SupplierOffers::class, 'supplier_id'); // 'supplier_id' is the foreign key in SupplierOffer
    }
}


------------------------------------------------------------
FILE: Providers/AppServiceProvider.php
------------------------------------------------------------
<?php

namespace App\Providers;

use Illuminate\Support\ServiceProvider;

class AppServiceProvider extends ServiceProvider
{
    /**
     * Register any application services.
     */
    public function register(): void
    {
        //
    }

    /**
     * Bootstrap any application services.
     */
    public function boot(): void
    {
        //
    }
}


------------------------------------------------------------
FILE: Services/OrderPricingService.php
------------------------------------------------------------
<?php

namespace App\Services;

use App\Models\Orders;
use App\Models\OrderItem;
use Illuminate\Support\Facades\DB;

class OrderPricingService
{
    /**
     * Recalculate customer-facing pricing when admin edits item price/discount/quoted price.
     * Supplier totals remain unchanged.
     *
     * @param  Orders $order  Loaded order with items relation (or will lazy-load).
     * @param  float|null $adminMargin  Override admin margin (default 0.50).
     * @param  float|null $gstRate      Override GST rate (default 0.05).
     * @param  bool $save               Persist changes.
     * @return Orders
     */
    public static function recalcCustomer(Orders $order, ?float $adminMargin = null, ?float $gstRate = null, bool $save = true): Orders
    {
        $ADMIN_MARGIN = $adminMargin ?? 0.50; // 50%
        $GST_RATE     = $gstRate     ?? 0.05; // 5%

        // Ensure items loaded
        $order->loadMissing(['items:id,order_id,quantity,supplier_unit_cost,supplier_discount,is_quoted,quoted_price,delivery_type,delivery_cost']);

        // 1) Rebuild customer_item_cost from items only
        $customer_item_cost = 0.0;
        $allItems = OrderItem::where('order_id',$order->id)->get();
        foreach ($allItems as $item) {
        
            if ((int)$item->is_quoted === 1 && $item->quoted_price !== null) {
  
                $customer_item_cost += (float)$item->quoted_price;
                continue;
            }
           
            $base_material = ($item->supplier_unit_cost * $item->quantity) - $item->supplier_discount;
            if ($base_material < 0) { $base_material = 0; }
     
            $customer_item_cost += $base_material * (1 + $ADMIN_MARGIN);
        }
     

        // 2) Keep existing customer_delivery_cost and supplier totals unchanged
        $customer_delivery_cost = (float) ($order->customer_delivery_cost ?? 0);
        $supplier_item_cost     = (float) ($order->supplier_item_cost ?? 0);
        $supplier_delivery_cost = (float) ($order->supplier_delivery_cost ?? 0);

        // 3) Recompute GST and totals
        $gst_tax = ($customer_item_cost + $customer_delivery_cost) * $GST_RATE;

        $discount      = (float) ($order->discount ?? 0);
        $other_charges = (float) ($order->other_charges ?? 0);

        $total_price = $customer_item_cost
                     + $customer_delivery_cost
                     + $gst_tax
                     - $discount
                     + $other_charges;

        // 4) Profit metrics based on frozen supplier totals
        $supplier_total        = $supplier_item_cost + $supplier_delivery_cost;
        $profit_before_tax     = $total_price - $supplier_total - $gst_tax - $discount - $other_charges;
        $profit_margin_percent = $supplier_total > 0 ? ($profit_before_tax / $supplier_total)*100 : 0.0;


        // 5) Persist
        $order->customer_item_cost     = round($customer_item_cost, 2);
        // customer_delivery_cost unchanged
        $order->gst_tax                = round($gst_tax, 2);
        $order->total_price            = round($total_price, 2);
        $order->profit_margin_percent  = $profit_margin_percent;
        $order->profit_amount          = round($profit_before_tax, 2); // actual profit amount

        if ($save) {
            DB::transaction(function () use ($order) {
                $order->save();
            });
        }

        return $order;
    }
}


------------------------------------------------------------
FILE: Services/Payments/LiveGroup.php
------------------------------------------------------------
<?php
namespace App\Services\Payments;

use GuzzleHttp\Client;
use Illuminate\Support\Facades\Config;

class LiveGroup {
  private Client $http; private string $merchant; private string $apiKey;
  public function __construct() {
    $this->merchant = Config::get('livegroup.merchant_id');
    $this->apiKey   = Config::get('livegroup.api_key');
    $this->http     = new Client([
      'base_uri' => Config::get('livegroup.base_url'),
      'timeout'  => Config::get('livegroup.timeout'),
    ]);
  }
  public function createIntent(array $payload): array {
    return $this->req('POST', '/v1/payments/intents', $payload);
  }
  public function getIntent(string $intentId): array {
    return $this->req('GET', "/v1/payments/intents/{$intentId}");
  }
  private function req(string $m, string $path, array $json=[]): array {
    $res = $this->http->request($m, $path, [
      'headers' => [
        'Authorization' => "Bearer {$this->apiKey}",
        'X-Merchant-Id' => $this->merchant,
        'Accept' => 'application/json',
      ],
      'json' => $json ?: null,
    ]);
    return json_decode((string)$res->getBody(), true);
  }
}

