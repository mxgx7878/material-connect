LARAVEL VIEWS CONVERSION
Generated: 2026-01-21 09:23:59
Project: C:\material-connect
================================================================================


------------------------------------------------------------
FILE: app/Http/Controllers/Admin/DashboardController.php
------------------------------------------------------------
<?php

namespace App\Http\Controllers\Admin;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;
use Illuminate\Support\Str;
use App\Models\Orders;
use App\Models\OrderItem;
use App\Models\User;
use App\Models\MasterProducts;
use DateTimeZone;
use DateTime;
use Carbon\Carbon;

class DashboardController extends Controller
{
    public function summary(Request $r)
    {
        $from = $r->date('from') ?? now()->startOfMonth();
        $to   = $r->date('to')   ?? now();
        $gran = $r->get('granularity', 'day');
        $tz   = $r->get('tz', 'Australia/Sydney');

        // Calculate previous period for comparison
        $periodDays = $from->diffInDays($to);
        $prevFrom = (clone $from)->subDays($periodDays + 1);
        $prevTo = (clone $from)->subDay();

        // Base scope for current period - FIXED: Use created_at
        $orders = Orders::query()
            ->when($r->client_id, fn($q, $v) => $q->where('client_id', $v))
            ->when($r->project_id, fn($q, $v) => $q->where('project_id', $v))
            ->when($r->workflow, fn($q, $v) => $q->where('workflow', $v))
            ->when($r->payment_status, fn($q, $v) => $q->where('payment_status', $v))
            ->when($r->delivery_method, fn($q, $v) => $q->where('delivery_method', $v));
            // ->whereBetween('created_at', [$from, $to]); // FIXED

        // Base scope for previous period (for comparison) - FIXED: Use created_at
        $prevOrders = Orders::query()
            ->when($r->client_id, fn($q, $v) => $q->where('client_id', $v))
            ->when($r->project_id, fn($q, $v) => $q->where('project_id', $v))
            ->when($r->workflow, fn($q, $v) => $q->where('workflow', $v))
            ->when($r->payment_status, fn($q, $v) => $q->where('payment_status', $v))
            ->when($r->delivery_method, fn($q, $v) => $q->where('delivery_method', $v))
            ->whereBetween('created_at', [$prevFrom, $prevTo]); // FIXED

        // KPIs - Current Period
        $ordersTotal = (int) (clone $orders)->count();
        $revenue = (float) (clone $orders)->whereIn('workflow',['Payment Requested','Delivered'])->sum('total_price');
        $awaitingPayment = (int) (clone $orders)->whereIn('payment_status', ['Pending', 'Requested'])->count();
        $supplierMissing = (int) (clone $orders)->where('workflow', 'Supplier Missing')->count();
        $completedOrders = (int) (clone $orders)->where('workflow', 'Delivered')->count();
        $avgOrderValue = $ordersTotal > 0 ? round($revenue / $ordersTotal, 2) : 0;
        $activeClients = (int) (clone $orders)->distinct('client_id')->count('client_id');
        
        // Get active suppliers from order items
        $orderIds = (clone $orders)->pluck('id');
        $activeSuppliers = OrderItem::whereIn('order_id', $orderIds)
            ->whereNotNull('supplier_id')
            ->distinct('supplier_id')
            ->count('supplier_id');

        // KPIs - Previous Period
        $ordersTotalPrev = (int) (clone $prevOrders)->count();
        $revenuePrev = (float) (clone $prevOrders)->sum('total_price');
        $completedOrdersPrev = (int) (clone $prevOrders)->where('workflow', 'Delivered')->count();
        $activeClientsPrev = (int) (clone $prevOrders)->distinct('client_id')->count('client_id');

        // Calculate percentage changes
        $ordersChange = $this->calculatePercentageChange($ordersTotal, $ordersTotalPrev);
        $revenueChange = $this->calculatePercentageChange($revenue, $revenuePrev);
        $completedChange = $this->calculatePercentageChange($completedOrders, $completedOrdersPrev);
        $clientsChange = $this->calculatePercentageChange($activeClients, $activeClientsPrev);

        // Total counts (not period-specific)
        $totalClients = User::where('role', 'client')->count();
        $totalSuppliers = User::where('role', 'supplier')->whereIn('status', ['approved', 'active'])->count();
        $pendingSuppliers = User::where('role', 'supplier')->where('status', 'pending')->count();

        // Performance metrics
        $cancelledOrders = (int) (clone $orders)->where('order_status', 'Cancelled')->count();
        $cancellationRate = $ordersTotal > 0 ? round(($cancelledOrders / $ordersTotal) * 100, 2) : 0;

        // Repeat client rate - FIXED: Use created_at
        $clientsWithMultipleOrders = Orders::query()
            ->whereBetween('created_at', [$from, $to]) // FIXED
            ->selectRaw('client_id, COUNT(*) as order_count')
            ->groupBy('client_id')
            ->having('order_count', '>', 1)
            ->count();
        $repeatClientRate = $activeClients > 0 ? round(($clientsWithMultipleOrders / $activeClients) * 100, 2) : 0;

        $kpis = [
            // Primary metrics
            'orders_total' => $ordersTotal,
            'orders_total_prev' => $ordersTotalPrev,
            'orders_change' => $ordersChange,
            
            'revenue' => $revenue,
            'revenue_prev' => $revenuePrev,
            'revenue_change' => $revenueChange,
            
            'avg_order_value' => $avgOrderValue,
            
            'completed_orders' => $completedOrders,
            'completed_orders_prev' => $completedOrdersPrev,
            'completed_change' => $completedChange,
            
            // Activity metrics
            'active_clients' => $activeClients,
            'active_clients_prev' => $activeClientsPrev,
            'active_clients_change' => $clientsChange,
            
            'active_suppliers' => $activeSuppliers,
            
            // Alerts & Actions
            'awaiting_payment' => $awaitingPayment,
            'supplier_missing' => $supplierMissing,
            'pending_supplier_approvals' => $pendingSuppliers,
            
            // Performance
            'cancellation_rate' => $cancellationRate,
            'repeat_client_rate' => $repeatClientRate,
            
            // System totals
            'total_clients' => $totalClients,
            'total_suppliers' => $totalSuppliers,
        ];

        // Which charts to build
        $want = collect(explode(',', $r->get('charts', 'date,supplier,product,price_bucket,status')))
            ->map(fn($x) => trim($x))->filter()->values();

        $charts = [];

        // 1) Date revenue & order count - FIXED: Use created_at in date formatting
        if ($want->contains('date')) {
            $bucket = match ($gran) {
                'week'  => "DATE_FORMAT(CONVERT_TZ(created_at, '+00:00', '{$this->offset($tz)}'), '%x-%v')", // FIXED
                'month' => "DATE_FORMAT(CONVERT_TZ(created_at, '+00:00', '{$this->offset($tz)}'), '%Y-%m')", // FIXED
                default => "DATE(CONVERT_TZ(created_at, '+00:00', '{$this->offset($tz)}'))", // FIXED
            };

            $rows = (clone $orders)
                ->selectRaw("$bucket AS bucket, COUNT(*) AS orders, SUM(total_price) AS revenue")
                ->groupBy('bucket')->orderBy('bucket')->get();

            $charts[] = [
                'id'       => 'time_revenue',
                'title'    => 'Revenue & Orders Over Time',
                'group_by' => 'date',
                'labels'   => $rows->pluck('bucket')->values(),
                'series'   => [
                    ['name' => 'Revenue', 'data' => $rows->pluck('revenue')->map(fn($v) => (float)$v)->values()],
                    ['name' => 'Orders', 'data' => $rows->pluck('orders')->map(fn($v) => (int)$v)->values()],
                ],
            ];
        }

        // 2) Order status distribution
        if ($want->contains('status')) {
            $statusDist = (clone $orders)
                ->selectRaw('workflow, COUNT(*) AS count')
                ->groupBy('workflow')
                ->orderByDesc('count')
                ->get();

            $charts[] = [
                'id'       => 'order_status',
                'title'    => 'Order Status Distribution',
                'group_by' => 'status',
                'type'     => 'donut',
                'labels'   => $statusDist->pluck('workflow')->values(),
                'series'   => $statusDist->pluck('count')->map(fn($v) => (int)$v)->values(),
            ];
        }

        // 3) Supplier revenue - FIXED: Use created_at
        if ($want->contains('supplier')) {
            // Get orders that have at least one supplier assigned
            $supplierRevenue = OrderItem::query()
            ->join('orders', 'orders.id', '=', 'order_items.order_id')
            ->whereBetween('orders.created_at', [$from, $to])
            ->whereIn('orders.workflow', ['Payment Requested', 'Delivered'])
            ->whereNotNull('order_items.supplier_id')
            ->when($r->supplier_id, fn($q, $v) => $q->where('order_items.supplier_id', $v))
            ->selectRaw('
                order_items.supplier_id AS supplier_id,
                SUM(
                    (COALESCE(order_items.supplier_unit_cost,0) * COALESCE(order_items.quantity,0))
                    + COALESCE(order_items.supplier_delivery_cost,0)
                    - COALESCE(order_items.supplier_discount,0)
                ) AS revenue
            ')
            ->groupBy('order_items.supplier_id')
            ->orderByDesc('revenue')
            ->limit(10)
            ->get()
            ->map(fn($r) => [
                'supplier_id' => (int) $r->supplier_id,
                'revenue'     => (float) $r->revenue,
            ])
            ->values();

            $supplierIds = $supplierRevenue->pluck('supplier_id');
            $supplierNames = User::whereIn('id', $supplierIds)->pluck('name', 'id');

            $charts[] = [
                'id'       => 'supplier_revenue',
                'title'    => 'Top Suppliers by Revenue',
                'group_by' => 'supplier',
                'labels'   => $supplierRevenue->map(fn($r) => $supplierNames[$r['supplier_id']] ?? '#'.$r['supplier_id'])->values(),
                'series'   => [[
                    'name' => 'Revenue',
                    'data' => $supplierRevenue->pluck('revenue')->map(fn($v) => round((float)$v, 2))->values(),
                ]],
            ];
        }

        // 4) Product mix - FIXED: Use created_at
        if ($want->contains('product')) {
            $productRevenue = OrderItem::query()
                ->join('orders', 'orders.id', '=', 'order_items.order_id')
                ->join('master_products', 'master_products.id', '=', 'order_items.product_id')
                ->whereBetween('orders.created_at', [$from, $to]) // FIXED
                ->when($r->product_id, fn($q, $v) => $q->where('order_items.product_id', $v))
                ->selectRaw('
                    order_items.product_id,
                    master_products.product_name,
                    COUNT(DISTINCT orders.id) AS order_count,
                    SUM(orders.total_price) / COUNT(DISTINCT orders.id) AS avg_revenue
                ')
                ->groupBy('order_items.product_id', 'master_products.product_name')
                ->orderByDesc('order_count')
                ->limit(10)
                ->get();

            $charts[] = [
                'id'       => 'product_revenue',
                'title'    => 'Top Products by Order Count',
                'group_by' => 'product',
                'labels'   => $productRevenue->pluck('product_name')->values(),
                'series'   => [[
                    'name' => 'Orders',
                    'data' => $productRevenue->pluck('order_count')->map(fn($v) => (int)$v)->values(),
                ]],
            ];
        }

        // 5) Price buckets
        if ($want->contains('price_bucket')) {
            $b = $this->parseBuckets($r->get('buckets', '0-500,500-1000,1000-2000,2000-5000,5000+'));
            $dist = $this->bucketizePrices($orders, $b);
            $charts[] = [
                'id'       => 'price_dist',
                'title'    => 'Order Value Distribution',
                'group_by' => 'price_bucket',
                'type'     => 'bar',
                'labels'   => array_keys($dist),
                'series'   => [['name' => 'Orders', 'data' => array_values($dist)]],
            ];
        }

        // TABLES

        // Top clients by spend
        $topClients = Orders::query()
            ->join('users as u', 'orders.client_id', '=', 'u.id')
            ->whereBetween('orders.created_at', [$from, $to]) // FIX: Specify orders.created_at
            ->selectRaw('
                orders.client_id,
                u.name AS client_name,
                u.email AS client_email,
                COUNT(orders.id) AS order_count,
                SUM(orders.total_price) AS total_spend
            ')
            ->groupBy('orders.client_id', 'u.name', 'u.email')
            ->orderByDesc('total_spend')
            ->limit(10)
            ->get()
            ->map(fn($r) => [
                'client_id' => $r->client_id,
                'client_name' => $r->client_name,
                'client_email' => $r->client_email,
                'order_count' => (int) $r->order_count,
                'total_spend' => (float) $r->total_spend,
            ])
            ->values();

        // Top suppliers by order count and revenue share - FIXED: Use created_at
        $topSuppliers = OrderItem::query()
        ->join('orders', 'orders.id', '=', 'order_items.order_id')
        ->join('users', 'users.id', '=', 'order_items.supplier_id')
        ->whereBetween('orders.created_at', [$from, $to])
        ->whereIn('orders.workflow', ['Payment Requested', 'Delivered']) // confirm exact values
        ->whereNotNull('order_items.supplier_id')
        ->selectRaw('
            order_items.supplier_id,
            users.name AS supplier_name,
            users.email AS supplier_email,
            COUNT(DISTINCT orders.id) AS order_count,
            SUM(
                (COALESCE(order_items.supplier_unit_cost,0) * COALESCE(order_items.quantity,0))
                + COALESCE(order_items.supplier_delivery_cost,0)
                - COALESCE(order_items.supplier_discount,0)
            ) AS total_revenue
        ')
        ->groupBy('order_items.supplier_id', 'users.name', 'users.email')
        ->orderByDesc('order_count')
        ->limit(10)
        ->get()
        ->map(fn($r) => [
            'supplier_id'    => $r->supplier_id,
            'supplier_name'  => $r->supplier_name,
            'supplier_email' => $r->supplier_email,
            'order_count'    => (int) $r->order_count,
            'revenue'        => (float) $r->total_revenue,
        ])
        ->values();

        // Recent activity feed (last 7 days, up to 15 items)
        $recentActivity = Orders::query()
            ->with(['client:id,name', 'project:id,name'])
            ->whereBetween('created_at', [now()->subDays(7), now()])
            ->orderBy('created_at', 'desc')
            ->limit(15)
            ->get()
            ->map(fn($order) => [
                'id' => $order->id,
                'type' => 'order_created',
                'order_id' => $order->id,
                'po_number' => $order->po_number,
                'client_name' => $order->client->name ?? 'Unknown Client',
                'project_name' => $order->project->name ?? 'N/A',
                'amount' => (float) $order->total_price,
                'workflow' => $order->workflow,
                'timestamp' => $order->created_at->toIso8601String(),
                'time_ago' => $order->created_at->diffForHumans(),
            ])
            ->values();

        // Prepare response filters
        $respFilters = [
            'from'            => $from instanceof Carbon ? $from->toDateString() : (string) $from,
            'to'              => $to instanceof Carbon ? $to->toDateString() : (string) $to,
            'granularity'     => $gran,
            'group_by'        => null,
            'metric'          => 'revenue',
            'client_id'       => $r->client_id,
            'project_id'      => $r->project_id,
            'supplier_id'     => $r->supplier_id,
            'product_id'      => $r->product_id,
            'workflow'        => $r->workflow,
            'payment_status'  => $r->payment_status,
            'delivery_method' => $r->delivery_method,
            'tz'              => $tz,
            'currency'        => 'AUD',
            'charts'          => $want->all(),
        ];

        // System alerts
        $alerts = [];
        if ($awaitingPayment > 0) {
            $alerts[] = [
                'type' => 'warning',
                'priority' => 'high',
                'message' => "{$awaitingPayment} order(s) awaiting payment",
                'action_url' => '/admin/orders?payment_status=Pending',
            ];
        }
        if ($supplierMissing > 0) {
            $alerts[] = [
                'type' => 'error',
                'priority' => 'high',
                'message' => "{$supplierMissing} order(s) missing supplier assignment",
                'action_url' => '/admin/orders?workflow=Supplier+Missing',
            ];
        }
        if ($pendingSuppliers > 0) {
            $alerts[] = [
                'type' => 'info',
                'priority' => 'medium',
                'message' => "{$pendingSuppliers} supplier(s) pending approval",
                'action_url' => '/admin/suppliers?status=pending',
            ];
        }

        return response()->json([
            'filters' => $respFilters,
            'kpis'    => $kpis,
            'charts'  => $charts,
            'tables'  => [
                'top_clients_by_spend' => $topClients,
                'top_suppliers_by_revenue' => $topSuppliers,
                'recent_activity' => $recentActivity,
            ],
            'alerts' => $alerts,
            'metadata' => [
                'generated_at' => now()->toIso8601String(),
                'data_freshness' => 'real-time',
                'total_records_analyzed' => $ordersTotal,
                'period_days' => $periodDays,
            ],
        ]);
    }

    /**
     * Calculate percentage change between current and previous values
     */
    protected function calculatePercentageChange($current, $previous): float
    {
        if ($previous == 0) {
            return $current > 0 ? 100.0 : 0.0;
        }
        return round((($current - $previous) / $previous) * 100, 2);
    }

    protected function parseBuckets(string $spec): array
    {
        $out = [];
        foreach (explode(',', $spec) as $raw) {
            $t = trim($raw);
            if ($t === '') continue;

            if (Str::endsWith($t, '+')) {
                $min = (float) rtrim($t, '+');
                $out[] = ['label' => "{$min}+", 'min' => $min, 'max' => null];
                continue;
            }

            if (preg_match('/^\s*([0-9]*\.?[0-9]+)\s*-\s*([0-9]*\.?[0-9]+)\s*$/', $t, $m)) {
                $min = (float) $m[1];
                $max = (float) $m[2];
                if ($max < $min) [$min, $max] = [$max, $min];
                $label = $min == (int)$min && $max == (int)$max ? "{$min}-{$max}" : "{$min}-{$max}";
                $out[] = ['label' => $label, 'min' => $min, 'max' => $max];
            }
        }
        usort($out, fn($a, $b) => ($a['min'] <=> $b['min']) ?: (($a['max'] ?? INF) <=> ($b['max'] ?? INF)));
        return $out;
    }

    protected function buildPriceBucketCase(array $buckets, string $column = 'total_price'): string
    {
        $cases = [];
        foreach ($buckets as $b) {
            $min = $b['min'];
            $max = $b['max'];
            $label = addslashes($b['label']);
            if (is_null($max)) {
                $cases[] = "WHEN {$column} >= {$min} THEN '{$label}'";
            } else {
                $cases[] = "WHEN {$column} >= {$min} AND {$column} < {$max} THEN '{$label}'";
            }
        }
        $cases[] = "ELSE 'Other'";
        return 'CASE ' . implode(' ', $cases) . ' END';
    }

    protected function bucketizePrices(\Illuminate\Database\Eloquent\Builder $orders, array $buckets): array
    {
        if (empty($buckets)) return [];

        $caseSql = $this->buildPriceBucketCase($buckets, 'total_price');

        $rows = (clone $orders)
            ->selectRaw("{$caseSql} AS bucket, COUNT(*) AS cnt")
            ->groupBy('bucket')
            ->pluck('cnt', 'bucket');

        $ordered = [];
        foreach ($buckets as $b) {
            $label = $b['label'];
            $ordered[$label] = (int) ($rows[$label] ?? 0);
        }
        if (isset($rows['Other'])) $ordered['Other'] = (int)$rows['Other'];

        return $ordered;
    }

    protected function offset(string $tz): string
    {
        try {
            $zone = new DateTimeZone($tz);
        } catch (\Exception $e) {
            $zone = new DateTimeZone('UTC');
        }
        $now = new DateTime('now', $zone);
        $offset = $zone->getOffset($now) / 3600;
        $sign = $offset >= 0 ? '+' : '-';
        $hours = str_pad(abs((int)$offset), 2, '0', STR_PAD_LEFT);
        $minutes = str_pad(abs(($offset * 60) % 60), 2, '0', STR_PAD_LEFT);
        return "{$sign}{$hours}:{$minutes}";
    }
}


------------------------------------------------------------
FILE: app/Http/Controllers/Admin/MasterProductsController.php
------------------------------------------------------------
<?php

namespace App\Http\Controllers\Admin;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Validator;
use Illuminate\Support\Facades\Storage;
use App\Models\MasterProducts;
use App\Models\SupplierOffers;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Str;
use App\Models\User;
use App\Models\Company;
use Illuminate\Support\Facades\Http;

class MasterProductsController extends Controller
{
    /**
     * List all master products.
     */
    public function index(Request $request)
    {
        $perPage = (int) $request->get('per_page', 10);
        $page = (int) $request->get('page', 1);

        $query = MasterProducts::with(['added_by', 'approved_by', 'category']);

        // Apply filters
        if ($request->filled('search')) {
            $search = $request->get('search');
            $query->where('product_name', 'like', "%{$search}%");
        }

        if ($request->filled('category')) {
            $query->where('category', $request->get('category'));
        }

        if ($request->filled('is_approved')) {
            $query->where('is_approved', $request->get('is_approved'));
        }

        // Paginate after filters
        $products = $query->paginate($perPage, ['*'], 'page', $page);

        // Append supplier offers count
        $products->getCollection()->transform(function ($product) {
            $product->supplierOffersCount = SupplierOffers::where('master_product_id', $product->id)->count();
            return $product;
        });

        return response()->json($products, 200);
    }


    /**
     * Show a specific master product.
     */
    public function show($id)
    {
        // Find the product with eager-loaded relationships
        $product = MasterProducts::with(['added_by', 'approved_by', 'category'])->find($id);

        // Check if the product exists
        if (!$product) {
            return response()->json(['error' => 'Product not found'], 404);
        }

        // Load supplier offers and eager load the supplier relationship
        $product->supplierOffers = SupplierOffers::with('supplier')->where('master_product_id', $product->id)->get();

        // Decode delivery_zones manually in case the accessor isn't being triggered
        $product->supplierOffers->each(function ($offer) {
            if ($offer->supplier && isset($offer->supplier->delivery_zones)) {
                // Manually decode the delivery_zones if it's still a string
                $offer->supplier->delivery_zones = json_decode($offer->supplier->delivery_zones, true);
            }
        });

        // Return the response with the product and decoded supplier offer details
        return response()->json($product, 200);
    }


    /**
     * Create a new master product.
     */
    public function store(Request $request)
    {
        $validator = Validator::make($request->all(), [
            'product_name' => 'required|string|max:255|unique:master_products,product_name',
            'product_type' => 'required|string|max:255',
            'specifications' => 'nullable|string',
            'unit_of_measure' => 'nullable|string|max:100',
            'tech_doc' => 'nullable|file|mimes:pdf,docx,xlsx',
            'photo' => 'nullable|image|mimes:jpeg,png,jpg,gif|max:2048',
            'is_approved' => 'boolean',
            'category' => 'nullable|string|max:255|exists:category,id'
        ]);

        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 400);
        }

        $techDocPath = null;
        if ($request->hasFile('tech_doc') && $request->file('tech_doc')->isValid()) {
            $techDocPath = $request->file('tech_doc')->store('tech_docs', 'public');
        }

        $photoPath = null;
        if ($request->hasFile('photo') && $request->file('photo')->isValid()) {
            $photoPath = $request->file('photo')->store('product_photos', 'public');
        }

        $approverId = null;
        if ($request->is_approved) {
            $approverId = Auth::id();
        }

        $product = MasterProducts::create([
            'product_name' => $request->product_name,
            'product_type' => $request->product_type,
            'specifications' => $request->specifications,
            'unit_of_measure' => $request->unit_of_measure,
            'tech_doc' => $techDocPath,
            'photo' => $photoPath,
            'added_by' => Auth::id(),
            'is_approved' => $request->is_approved ?? false,
            'approved_by' => $approverId,
            'slug' => Str::slug($request->product_name) . '-' . Str::random(6),
            'category' => $request->category,
        ]);

        return response()->json(['message' => 'Product created successfully', 'product' => $product], 201);
    }

    /**
     * Update a master product.
     */
    public function update(Request $request, $id)
    {
        $product = MasterProducts::find($id);

        if (!$product) {
            return response()->json(['error' => 'Product not found'], 404);
        }

        $validator = Validator::make($request->all(), [
            'product_name' => 'sometimes|required|string|max:255',
            'product_type' => 'sometimes|required|string|max:255',
            'specifications' => 'nullable|string',
            'unit_of_measure' => 'nullable|string|max:100',
            'tech_doc' => 'nullable|file|mimes:pdf,docx,xlsx',
            'photo' => 'nullable|image|mimes:jpeg,png,jpg,gif|max:2048',
            'is_approved' => 'boolean',
            'category' => 'nullable|string|max:255|exists:category,id'
        ]);

        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 400);
        }

        if ($request->hasFile('tech_doc') && $request->file('tech_doc')->isValid()) {
            if ($product->tech_doc) {
                Storage::delete('public/' . $product->tech_doc);
            }
            $product->tech_doc = $request->file('tech_doc')->store('tech_docs', 'public');
        }

        if ($request->hasFile('photo') && $request->file('photo')->isValid()) {
            if ($product->photo) {
                Storage::delete('public/' . $product->photo);
            }
            $product->photo = $request->file('photo')->store('product_photos', 'public');
        }

        if ($request->has('is_approved')) {
            if ($request->is_approved && !$product->is_approved) {
                $product->approved_by = Auth::id();
            } elseif (!$request->is_approved) {
                $product->approved_by = null;
            }
            $product->is_approved = $request->is_approved;
        }

        $product->update([
            'product_name' => $request->product_name ?? $product->product_name,
            'product_type' => $request->product_type ?? $product->product_type,
            'specifications' => $request->specifications ?? $product->specifications,
            'unit_of_measure' => $request->unit_of_measure ?? $product->unit_of_measure,
            'slug' => $request->product_name ? Str::slug($request->product_name) . '-' . Str::random(6) : $product->slug,
            'is_approved' => $product->is_approved,
            'approved_by' => $product->approved_by,
            'category' => $request->category ?? $product->category,
            'tech_doc' => $product->tech_doc,
            'photo' => $product->photo,
        ]);

        return response()->json(['message' => 'Product updated successfully', 'product' => $product], 200);
    }

    /**
     * Delete a master product.
     */
    public function destroy($id)
    {
        $product = MasterProducts::find($id);

        if (!$product) {
            return response()->json(['error' => 'Product not found'], 404);
        }

        if ($product->tech_doc) {
            Storage::delete('public/' . $product->tech_doc);
        }

        if ($product->photo) {
            Storage::delete('public/' . $product->photo);
        }

        $product->delete();

        return response()->json(['message' => 'Product deleted successfully'], 200);
    }

    public function approveRejectMasterProduct($id)
    {
        $product = MasterProducts::find($id);

        if (!$product) {
            return response()->json(['error' => 'Product not found'], 404);
        }

        if($product->is_approved) {
            // If already approved, reject it
            $product->is_approved = false;
            $product->approved_by = null;
        } else {
            // If not approved, approve it
            $product->is_approved = true;
            $product->approved_by = Auth::id();
        }
        $product->save();

        return response()->json(['message' => 'Product approval status updated', 'is_approved' => $product->is_approved], 200);
        
    }

    public function approveRejectSupplierOffer(Request $request , $id)
    {
        $offer = SupplierOffers::find($id);

        if (!$offer) {
            return response()->json(['error' => 'Supplier offer not found'], 404);
        }

        $validator = Validator::make($request->all(), [
            'status' => 'required|in:Approved,Rejected,Pending',
        ]);
        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 400);
        }
        $offer->status = $request->status;
        $offer->save();

        return response()->json(['message' => 'Supplier offer approval status updated', 'status' => $offer->status], 200);
        
    }


    public function importMasterProducts()
    {
        $filePath = base_path('Products-2.csv'); // CSV in Laravel root
        
        if (!file_exists($filePath)) {
            dd("CSV file not found.");
        }

        $handle = fopen($filePath, 'r');
       
        // Skip header row
        $header = fgetcsv($handle);

        while (($row = fgetcsv($handle)) !== false) {

            // CSV Columns Example:
            // 0 => Product Name
            // 1 => Product Type
            // 2 => Unit of Measure
            // 3 => Delivery Method

            $productName     = trim($row[0] ?? null);
            $productType     = trim($row[1] ?? null);
            $unitMeasure     = trim($row[2] ?? null);
            $deliveryMethod  = trim($row[3] ?? null);
       

            if (!$productName) {
                continue; // skip empty rows
            }

            MasterProducts::updateOrCreate(
                ['product_name' => $productName], // unique key
                [
                    'product_type'     => $productType,
                    'unit_of_measure'  => $unitMeasure,
                    'delivery_method'  => $deliveryMethod,

                    'category'         => 1,
                    'is_approved'      => 1,
                    'approved_by'      => 1,
                    'added_by'         => 1,

                    'slug'             => Str::slug($productName),

                    // other fields set null as requested
                    'specifications'   => null,
                    'tech_doc'         => null,
                    'photo'            => null,
                ]
            );
        }

        fclose($handle);

        return "Master products imported successfully.";
    }

    public function importOffers()
    {
        $filePath = base_path('supplier-offers.csv'); // CSV in Laravel root
        
        if (!file_exists($filePath)) {
            dd("CSV file not found.");
        }

        $handle = fopen($filePath, 'r');
        
        // Skip header row
        $header = fgetcsv($handle);

        while (($row = fgetcsv($handle)) !== false) {

            // CSV Columns Example:
            // 0 => Supplier ID
            // 1 => Product ID
            // 2 => Price


            $supplierId = trim($row[0] ?? null);
            $productId = trim($row[1] ?? null);
            $price = trim($row[2] ?? null);

            // Remove the dollar sign and format the price to two decimal places
            $price = str_replace('$', '', $price);
            $price = number_format((float)$price, 2, '.', ''); // Ensure 2 decimal places

            if (!$supplierId || !$productId) {
                continue; // skip empty rows
            }

            SupplierOffers::updateOrCreate(
                [
                    'supplier_id' => $supplierId,
                    'master_product_id' => $productId,
                    'price' => $price,
                    'availability_status' => 'In Stock',
                    'status' => 'Approved',
                ]
            );
        }

        fclose($handle);

        return "Supplier offers imported successfully.";
    }


    public function importUsers()
    {
        $filePath = base_path('suppliers.csv'); // CSV in Laravel root
        
        if (!file_exists($filePath)) {
            dd("CSV file not found.");
        }

        $handle = fopen($filePath, 'r');
        
        // Skip header row
        $header = fgetcsv($handle);

        while (($row = fgetcsv($handle)) !== false) {

            // CSV Columns Example:
            // 0 => Name
            // 1 => Email
            // 2 => Company Name
            // 3 => Contact Number

            $name     = trim($row[0] ?? null);
            $email    = trim($row[1] ?? null);
            $company_name = trim($row[2] ?? null);
            $contact_number     = trim($row[3] ?? null);


            if (!$name || !$email || !$company_name || !$contact_number) {
                continue; // skip empty rows
            }

            $company = Company::firstOrCreate(
                ['name' => $company_name]
            );
            $client_public_id = 'MC-' . str_pad(User::count() + 440, 3, '0', STR_PAD_LEFT);
            User::updateOrCreate(
                ['email' => $email], // unique key
                [
                    'name'     => $company_name,
                    'password' => Hash::make('password'),
                    'role'     => 'supplier',
                    'company_id' => $company->id,
                    'contact_number' => $contact_number,
                    'company_name' => $company_name,
                    'contact_name' => $name,
                    'status' => 'Active',
                    'client_public_id' => $client_public_id,
                ]
            );
        }

        fclose($handle);

        return "Users imported successfully.";
    }



    public function updateDeliveryZonesFromCSV()
    {

        set_time_limit(300);
        // Path to the CSV file in the root directory
        $filePath = base_path('zones.csv'); // Use base_path() to get the project root directory

        // Read the CSV file into an array
        $csvData = array_map('str_getcsv', file($filePath));
        $header = array_shift($csvData); // Extract the header to get column names
        $suppliers = [];

        // Loop through the CSV data and group by supplier name
        foreach ($csvData as $row) {
            $supplierName = $row[0]; // Assuming 'Supplier Name' is in the first column
            $address = $row[1]; // Assuming 'Address' is in the second column
            $radius = $row[2]; // Assuming 'Radius' is in the third column
            
            // Store data grouped by supplier name
            if (!isset($suppliers[$supplierName])) {
                $suppliers[$supplierName] = [];
            }
            
            $suppliers[$supplierName][] = [
                'address' => $address,
                'radius' => $radius
            ];
        }

        // Google Maps API Key
        $googleMapsApiKey = "AIzaSyAUjFL6wmCy8ETAqV1bhFRUEySaUAAX2_k"; // Ensure you set this in your .env file

        // Loop through each supplier, get lat/lng for each address, and update users
        foreach ($suppliers as $supplierName => $zones) {
            // Find the user by supplier name
            $user = User::where('name', $supplierName)->first();
            
            if ($user) {
                $deliveryZones = [];

                foreach ($zones as $zone) {
                    // Fetch lat/long using Google Maps API
                    $response = Http::get('https://maps.googleapis.com/maps/api/geocode/json', [
                        'address' => $zone['address'],
                        'key' => $googleMapsApiKey,
                    ]);

                    $data = $response->json();

                    if (isset($data['results'][0]['geometry']['location'])) {
                        $lat = $data['results'][0]['geometry']['location']['lat'];
                        $long = $data['results'][0]['geometry']['location']['lng'];
                        
                        // Add the data to delivery zones
                        $deliveryZones[] = [
                            'address' => $zone['address'],
                            'lat' => $lat,
                            'long' => $long,
                            'radius' => $zone['radius'],
                        ];
                    }
                }
                // dd($deliveryZones);
                // Encode the delivery zones and save to the user's delivery_zones field
                $user->delivery_zones = json_encode($deliveryZones);
                $user->save();
            }
        }

        return response()->json(['status' => 'Zones updated successfully']);
    }


    public function importOffersWithProducts()
{
    $filePath = base_path('offers.csv'); // CSV in Laravel root
    
    if (!file_exists($filePath)) {
        dd("CSV file not found.");
    }

    $handle = fopen($filePath, 'r');
    
    // Skip header row
    $header = fgetcsv($handle);

    $suppliers = [];

    // Read through the file and group products by supplier name
    while (($row = fgetcsv($handle)) !== false) {

        // CSV Columns Example (based on your clarification):
        // 0 => Supplier Name
        // 1 => Product Name
        // 2 => Product Type
        // 3 => Price
        // 4 => Unit of Measure
        // 5 => Delivery Method

        $supplierName    = trim($row[0] ?? null);
        $productName     = trim($row[1] ?? null);
        $productType     = trim($row[2] ?? null);
        $price           = trim($row[3] ?? null);
        $unitMeasure     = trim($row[4] ?? null);
        $deliveryMethod  = trim($row[5] ?? null);

        if (!$supplierName || !$productName || !$price) {
            continue; // skip empty rows
        }

        // Remove any non-numeric characters (such as currency symbols) from the price
        $price = preg_replace('/[^\d.]/', '', $price); // Remove any non-numeric characters except decimal
        $price = number_format((float)$price, 2, '.', ''); // Ensure two decimal places

        // Group by Supplier Name
        if (!isset($suppliers[$supplierName])) {
            $suppliers[$supplierName] = [];
        }

        $suppliers[$supplierName][] = [
            'product_name'   => $productName,
            'product_type'   => $productType,
            'price'          => $price,
            'unit_measure'   => $unitMeasure,
            'delivery_method'=> $deliveryMethod
        ];
    }

    fclose($handle);

    // Now process each supplier's products
    foreach ($suppliers as $supplierName => $products) {
        // Find the supplier ID by name
        $supplier = User::where('name', $supplierName)->first();

        if ($supplier) {
            foreach ($products as $product) {
                // Check if the product already exists in the MasterProducts table
                $masterProduct = MasterProducts::where('product_name', $product['product_name'])->first();

                if (!$masterProduct) {
                    // If the product doesn't exist, add it to the MasterProducts table
                    $masterProduct = MasterProducts::create([
                        'product_name'   => $product['product_name'],
                        'product_type'   => $product['product_type'],
                        'unit_of_measure'=> $product['unit_measure'],
                        'delivery_method'=> $product['delivery_method'],
                        'category'       => 1,
                        'is_approved'    => 1,
                        'approved_by'    => 1,
                        'added_by'       => 1,
                        'slug'           => Str::slug($product['product_name']),
                    ]);
                }

                // Now, create the offer for the supplier and product
                SupplierOffers::updateOrCreate(
                    [
                        'supplier_id' => $supplier->id,
                        'master_product_id' => $masterProduct->id,
                        'price' => $product['price'], // Correctly formatted price
                        'availability_status' => 'In Stock',
                        'status' => 'Approved',
                    ]
                );
            }
        }
    }

    return "Offers with products imported successfully.";
}


}


------------------------------------------------------------
FILE: app/Http/Controllers/Admin/OrderAdminController.php
------------------------------------------------------------
<?php

namespace App\Http\Controllers\Admin;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;
use App\Models\Orders; // Adjust if your model is named Order
use App\Models\Projects;
use App\Models\OrderItem;
use App\Services\OrderPricingService;
use App\Models\SupplierOffers;
use App\Models\User; // assuming clients are users with role=client
use Illuminate\Validation\Rule;
use Illuminate\Support\Facades\Validator;
use Illuminate\Support\Facades\Auth;
use Stripe\Climate\Order;

// use Pest\Configuration\Project;

class OrderAdminController extends Controller
{
    //


    public function index(Request $request)
    {
        $perPage   = (int) $request->get('per_page', 10);
        $search    = trim((string) $request->get('search', ''));
        $clientId  = $request->get('client_id');
        $projectId = $request->get('project_id');
        $supplierId= $request->get('supplier_id');
        $workflow  = $request->get('workflow');
        $payment   = $request->get('payment_status');
        $ddFrom    = $request->get('delivery_date_from');
        $ddTo      = $request->get('delivery_date_to');
        $method    = $request->get('delivery_method');
        $repeat    = $request->get('repeat_order') ?? null;
        $hasMissing= $request->get('has_missing_supplier');
        $confirms  = $request->get('supplier_confirms'); // "true"/"false" or null
        $minTotal  = $request->get('min_total');
        $maxTotal  = $request->get('max_total');
        $sort      = $request->get('sort', 'created_at');
        $dir       = strtolower($request->get('dir', 'desc')) === 'asc' ? 'asc' : 'desc';
        $details   = filter_var($request->get('details', false), FILTER_VALIDATE_BOOLEAN);

        if (!is_null($confirms)) {
            $confirms = $confirms === "true";
        }

        // Allowed sort columns (updated)
        $sortMap = [
            'po_number'      => 'po_number',
            'delivery_date'  => 'delivery_date',
            'created_at'     => 'created_at',
            'updated_at'     => 'updated_at',
            'total_price'    => 'total_price',          // use this instead of customer_cost/total
            'profit_amount'  => 'profit_amount',        // actual profit amount column
            'profit_before_tax'    => 'profit_before_tax',
            'profit_margin_percent'=> 'profit_margin_percent',
            'items_count'    => DB::raw('items_count'),
        ];
        if (!array_key_exists($sort, $sortMap)) {
            $sort = 'created_at';
        }

        // Base query
        $query = Orders::query()
            ->with([
                'client:id,name',
                'project:id,name',
                'items:id,order_id,supplier_id,quantity,supplier_confirms'
            ])
            ->withCount([
                'items as items_count',
                'items as unassigned_items_count' => function ($q) {
                    $q->whereNull('supplier_id');
                },
            ])
            ->withCount(['items as suppliers_count' => function ($q) {
                $q->whereNotNull('supplier_id')->select(DB::raw('COUNT(DISTINCT supplier_id)'));
            }])
            ->where('is_archived', false);

        // Text search
        if ($search !== '') {
            $query->where('po_number', 'like', "%{$search}%");
        }
        if ($clientId) {
            $query->where('client_id', $clientId);
        }
        if ($projectId) {
            $query->where('project_id', $projectId);
        }
        if ($workflow) {
            $query->where('workflow', $workflow);
        }
        if ($payment) {
            $query->where('payment_status', $payment);
        }
        if ($method) {
            $query->where('delivery_method', $method);
        }
        if ($ddFrom) {
            $query->whereDate('delivery_date', '>=', $ddFrom);
        }
        if ($ddTo) {
            $query->whereDate('delivery_date', '<=', $ddTo);
        }
        if (isset($repeat) && $repeat !== '') {
            $query->where('repeat_order', filter_var($repeat, FILTER_VALIDATE_BOOLEAN) ? 1 : 0);
        }
        if ($supplierId) {
            $query->whereHas('items', function ($q) use ($supplierId) {
                $q->where('supplier_id', $supplierId);
            });
        }
        if ($hasMissing) {
            $query->whereHas('items', function ($q) {
                $q->whereNull('supplier_id');
            });
        }
        if (!is_null($confirms)) {
            $query->whereHas('items', function ($q) use ($confirms) {
                $q->where('supplier_confirms', $confirms);
            });
        }

        // Totals filter now uses total_price only
        if ($minTotal !== null) {
            $query->where('total_price', '>=', $minTotal);
        }
        if ($maxTotal !== null) {
            $query->where('total_price', '<=', $maxTotal);
        }

        // Sorting
        if ($sort === 'items_count') {
            $query->orderBy('items_count', $dir);
        } else {
            $query->orderBy($sortMap[$sort], $dir);
        }

        $paginator = $query->paginate($perPage);

        // Transform rows
        $data = $paginator->getCollection()->map(function (Orders $o) {
            $total  = (float)($o->total_price ?? 0);
            $profit = (float)($o->profit_amount ?? $o->profit_amount ?? 0);

            $orderInfo = null;
            if ($o->workflow === 'Supplier Missing' && $o->unassigned_items_count > 0) {
                $orderInfo = 'Supplier missing for ' . $o->unassigned_items_count . ' items';
            } elseif ($o->workflow === 'Supplier Assigned') {
                $orderInfo = 'Waiting for suppliers to confirm';
            } elseif ($o->workflow === 'Payment Requested') {
                $orderInfo = 'Awaiting client payment';
            }
          
            //claude
            return [
                'id'                       => $o->id,
                'po_number'                => $o->po_number,
                'client'                   => optional($o->client)->name,
                'project'                  => optional($o->project)->name,
                'delivery_date'            => $o->delivery_date,
                'delivery_time'            => $o->delivery_time,
                'delivery_method'          => $o->delivery_method,
                'workflow'                 => $o->workflow,
                'payment_status'           => $o->payment_status,
                'order_process'            => $o->order_process,
                'items_count'              => $o->items_count,
                'unassigned_items_count'   => $o->unassigned_items_count,
                'suppliers_count'          => $o->suppliers_count ?? 0,
                
                // NEW: Supplier costs
                'supplier_item_cost'       => round((float)($o->supplier_item_cost ?? 0), 2),
                'supplier_delivery_cost'   => round((float)($o->supplier_delivery_cost ?? 0), 2),
                'supplier_total'           => round((float)($o->supplier_item_cost ?? 0) + (float)($o->supplier_delivery_cost ?? 0), 2),
                
                // NEW: Customer costs
                'customer_item_cost'       => round((float)($o->customer_item_cost ?? 0), 2),
                'customer_delivery_cost'   => round((float)($o->customer_delivery_cost ?? 0), 2),
                
                'total_price'              => round($total, 2),
                'profit_amount'            => round($profit, 2),
                'profit_margin_percent'    => round((float)($o->profit_margin_percent ?? 0), 4),
                
                // NEW: Other charges
                'gst_tax'                  => round((float)($o->gst_tax ?? 0), 2),
                'discount'                 => round((float)($o->discount ?? 0), 2),
                'other_charges'            => round((float)($o->other_charges ?? 0), 2),
                
                'order_info'               => $orderInfo,
                'repeat_order'             => $o->repeat_order,
                'created_at'               => $o->created_at,
                'updated_at'               => $o->updated_at,
            ];
        });

        // Metrics
        $base = Orders::query();
        $metrics = [
            'total_orders_count'     => (clone $base)->count(),
            'supplier_missing_count' => (clone $base)->where('workflow', 'Supplier Missing')->count(),
            'supplier_assigned_count'=> (clone $base)->where('workflow', 'Supplier Assigned')->count(),
            'awaiting_payment_count' => (clone $base)->where('workflow', 'Payment Requested')->count(),
            'delivered_count'        => (clone $base)->where('workflow', 'Delivered')->count(),
        ];

        $response = [
            'data' => $data,
            'pagination' => [
                'per_page'       => $paginator->perPage(),
                'current_page'   => $paginator->currentPage(),
                'total_pages'    => $paginator->lastPage(),
                'total_items'    => $paginator->total(),
                'has_more_pages' => $paginator->hasMorePages(),
            ],
            'metrics' => $metrics,
        ];

        if ($details) {
            $response['filters'] = [
                'clients'          => User::query()->where('role', 'client')->select('id','name','profile_image')->orderBy('name')->get(),
                'suppliers'        => User::where('role','supplier')->select('id','name','profile_image')->orderBy('name')->get(),
                'projects'         => Projects::query()->select('id','name')->orderBy('name')->get(),
                'workflows'        => ['Requested','Supplier Missing','Supplier Assigned','Payment Requested','On Hold','Delivered'],
                'payment_statuses' => ['Pending','Requested','Paid','Partially Paid','Partial Refunded','Refunded'],
                'delivery_methods' => ['Other','Tipper','Agitator','Pump','Ute'],
            ];
        }

        return response()->json($response);
    }



    public function show(Orders $order)
    {
        // dd($order->delivery_method);
        $order->load(['client:id,name', 'project:id,name', 'items.product:id,product_name']);
     
        $deliveryLat = $order->delivery_lat ?? null;   // adjust if different
        $deliveryLng = $order->delivery_long ?? null;
        // dd($order->project->id);
        $filters['projects'] = Projects::where('added_by', $order->client_id)->where('id', '!=', $order->project->id)->get();
        

        $payload = [
            //Order Details For Display (Not Changeable)
            'id' => $order->id,
            'po_number' => $order->po_number,
            'client' => optional($order->client)->name,
            'project' => optional($order->project)->name,
            'delivery_address' => $order->delivery_address,
            'delivery_lat'=>$order->delivery_lat,
            'delivery_long'=> $order->delivery_long,
            'delivery_date' => $order->delivery_date,
            'delivery_time' => $order->delivery_time,
            'delivery_window'=> $order->delivery_window,
            'delivery_method' => $order->delivery_method,
            'load_size'=> $order->load_size,
            'special_equipment'=> $order->special_equipment,
            'repeat_order'=> (int) $order->repeat_order,
            'order_process'=> $order->order_process,
                //status
            'workflow' => $order->workflow,
            'payment_status' => $order->payment_status,
            'order_status' => $order->order_status,

            'gst_tax'=> round((float)$order->gst_tax),
            'discount'=>round((float)$order->discount),
            'other_charges'=>round((float)$order->other_charges),
            'total_price'=>round((float)$order->total_price),
            'customer_item_cost'=>round((float)$order->customer_item_cost),
            'customer_delivery_cost'=>round((float)$order->customer_delivery_cost),
            'supplier_item_cost'=>round((float)$order->supplier_item_cost),
            'supplier_delivery_cost'=>round((float)$order->supplier_delivery_cost),
            'profit_margin_percent'=>(float)$order->profit_margin_percent,
            'profit_amount'=>round((float)$order->profit_amount),
            'items' => [],
            'filters'=>$filters
        ];

        // If not Supplier Missing, return items without eligibility calc
        if ($order->workflow !== 'Supplier Missing') {
            
            foreach ($order->items as $it) {
            //    dd($it->is_quoted);
                $payload['items'][] = [
                    'id' => $it->id,
                    'product_id' => $it->product_id,
                    'product_name' => optional($it->product)->product_name,
                    'quantity' => $it->quantity,
                    'supplier' => $it->supplier,
                    'choosen_offer_id' => $it->choosen_offer_id ?? null,
                    'supplier_confirms' => $it->supplier_confirms,
                    'supplier_unit_cost' => $it->supplier_unit_cost,
                    'delivery_cost' => $it->delivery_cost,
                    'supplier_discount' => $it->supplier_discount,
                    'delivery_type'=>$it->delivery_type,
                    'is_quoted'         => (int) $it->is_quoted,
                    'is_paid' => (int) $it->is_paid,
                    'quoted_price'=>$it->quoted_price,
                    'eligible_suppliers' => [],
                ];
            }
            return response()->json(['data' => $payload]);
        }

        $canComputeDistance = is_numeric($deliveryLat) && is_numeric($deliveryLng);

        // preload offers for all products on this order
        $masterIds = $order->items->pluck('product_id')->filter()->unique()->values();

        $offersByProduct = SupplierOffers::query()
            ->whereIn('master_product_id', $masterIds)
            ->with(['supplier:id,name,role,delivery_zones'])
            ->get()
            ->groupBy('master_product_id');
     
        foreach ($order->items as $it) {
            // already assigned  just echo item info
            if (!is_null($it->supplier_id)) {
                // dd($it);
                $payload['items'][] = [
                    'id' => $it->id,
                    'product_id' => $it->product_id,
                    'product_name' => optional($it->product)->product_name,
                    'quantity' => $it->quantity,
                    'supplier' => $it->supplier()->select('id','name','profile_image','delivery_zones')->first(),
                    'choosen_offer_id' => $it->choosen_offer_id ?? null,
                    'supplier_confirms' => $it->supplier_confirms,
                    'supplier_unit_cost' => $it->supplier_unit_cost,
                    'delivery_cost' => $it->delivery_cost,
                    'supplier_discount' => $it->supplier_discount,
                    'delivery_type'=>$it->delivery_type,
                    'is_quoted'         => (int) $it->is_quoted,
                    'is_paid' => (int) $it->is_paid,
                    'quoted_price'=>$it->quoted_price,
                    'eligible_suppliers' => [],
                ];
                continue;
            }

            // unassigned  build eligible_suppliers
            $eligible = [];
            $productOffers = $offersByProduct->get($it->product_id, collect());

            foreach ($productOffers as $offer) {
                $supplier = $offer->supplier; // users table row
                if (!$supplier) continue;
                if (strtolower((string)$supplier->role) !== 'supplier') continue;

                if (empty($supplier->delivery_zones)) continue; // must not be null/empty
                $zones = is_array($supplier->delivery_zones)
                    ? $supplier->delivery_zones
                    : $this->decodeZones($supplier->delivery_zones);
                if (empty($zones)) continue;

                $distance = null;
                // dd($canComputeDistance);
                // $canComputeDistance = true;
                if ($canComputeDistance) {
                    // dd($zones, $deliveryLat, $deliveryLng);
                    $distance = $this->nearestZoneDistanceKm($zones, (float)$deliveryLat, (float)$deliveryLng);
                }

                $eligible[] = [
                    'supplier_id' => (int) $supplier->id,
                    'name'=> (string) $supplier->name,
                    'offer_id'    => (int) $offer->id,
                    'unit_cost' => (float) $offer->price,
                    'distance'    => is_null($distance) ? null : round($distance, 3),
                ];
            }

            usort($eligible, function ($a, $b) {
                if ($a['distance'] === null && $b['distance'] === null) return 0;
                if ($a['distance'] === null) return 1;
                if ($b['distance'] === null) return -1;
                return $a['distance'] <=> $b['distance'];
            });

            $payload['items'][] = [
                'id' => $it->id,
                'product_id' => $it->product_id,
                'product_name' => optional($it->product)->product_name,
                'quantity' => $it->quantity,
                'supplier_id' => $it->supplier_id,
                'eligible_suppliers' => $eligible,
            ];
        }

        return response()->json(['data' => $payload]);
    }

    public function assignSupplier(Request $request)
    {
        $v = Validator::make($request->all(), [
            'order_id' => ['required','integer','min:1'],
            'item_id'  => ['required','integer','min:1'],
            'supplier' => ['required','integer','min:1'],     // supplier_id
            'offer_id' => ['sometimes','integer','min:1'],    // optional
        ]);
        if ($v->fails()) return response()->json(['error' => $v->errors()], 422);

        $orderId    = (int) $request->order_id;
        $itemId     = (int) $request->item_id;
        $supplierId = (int) $request->supplier;
        $offerId    = $request->filled('offer_id') ? (int) $request->offer_id : null;

        return DB::transaction(function () use ($orderId, $itemId, $supplierId, $offerId) {

            /** @var Orders $order */
            $order = Orders::with('items')->lockForUpdate()->findOrFail($orderId);

            /** @var OrderItem $item */
            $item = $order->items()->whereKey($itemId)->lockForUpdate()->firstOrFail();
            if (!$item->product_id) {
                return response()->json(['error' => ['item' => ['Item has no product_id.']]], 422);
            }

            // supplier must exist and be role=supplier
            $supplier = User::find($supplierId);
            if (!$supplier || strtolower((string)$supplier->role) !== 'supplier') {
                return response()->json(['error' => ['supplier' => ['Invalid supplier.']]], 422);
            }

            // pick matching offer by supplier+product (or the explicit one)
            $offerQ = SupplierOffers::query()
                ->where('supplier_id', $supplierId)
                ->where('master_product_id', $item->product_id)
                ->where('status','Approved')
                ->whereIn('availability_status',['In Stock','Limited']);
            if ($offerId) $offerQ->whereKey($offerId);

            $offer = $offerQ->orderBy('price')->first();
            if (!$offer) {
                return response()->json(['error' => ['offer' => ['No offer for this supplier and product.']]], 422);
            }

            $unitCost         = (float)($offer->price ?? $offer->price ?? 0);
            // $supplierDiscount = (float)($offer->supplier_discount ?? $offer->discount ?? 0);

            // assign. delivery fields stay null. no confirms flag.
            $item->forceFill([
                'supplier_id'            => $supplierId,
                'choosen_offer_id'       => $offer->id,
                'supplier_unit_cost'     => round($unitCost, 2),
                'supplier_discount'      => 0.00,
                'supplier_delivery_cost' => 0.00,
                'delivery_type'          => null,
                'delivery_cost'          => 0.00,
            ])->saveOrFail();

            // if all items now have a supplier -> set workflow
            $unassignedCount = $order->items()->whereNull('supplier_id')->count();
            if ($unassignedCount === 0 && $order->workflow !== 'Supplier Assigned') {
                $order->workflow = 'Supplier Assigned';
                $order->save();
            }

            // recalc customer totals
            $order->load('items');
            OrderPricingService::recalcCustomer($order, null, null, true);

            return response()->json([
                'message' => 'Supplier assigned.',
                'order' => [
                    'id'                     => $order->id,
                    'workflow'               => $order->workflow,
                    'total_price'            => $order->total_price,
                    'profit_amount'          => $order->profit_amount,
                    'profit_margin_percent'  => $order->profit_margin_percent,
                ],
                'item' => [
                    'id'                     => $item->id,
                    'product_id'             => $item->product_id,
                    'supplier_id'            => $item->supplier_id,
                    'choosen_offer_id'       => $item->choosen_offer_id,
                    'supplier_unit_cost'     => $item->supplier_unit_cost,
                    'supplier_discount'      => $item->supplier_discount,
                    'supplier_delivery_cost' => $item->supplier_delivery_cost, // null
                    'delivery_type'          => $item->delivery_type,          // null
                    'delivery_cost'          => $item->delivery_cost,          // null
                ],
                'offer' => [
                    'id'                => $offer->id,
                    'supplier_id'       => $offer->supplier_id,
                    'master_product_id' => $offer->master_product_id,
                ],
            ]);
        });
    }

    public function supplierPaidStatus(Request $request, Orders $order, OrderItem $orderItem)
    {
        // only admins hit this via middleware
        $v = Validator::make($request->all(), [
            'is_paid'         => ['sometimes','required','boolean'],
            
        ]);
        if ($v->fails()) {
            return response()->json(['error' => $v->errors()], 422);
        }

        $item = OrderItem::find((int)$orderItem->id);
        if (!$item) {
            return response()->json(['error' => 'Item not found'], 404);
        }

        $isPaid = filter_var($request->is_paid, FILTER_VALIDATE_BOOLEAN);

        $item->is_paid = $isPaid ? 1 : 0;
        // $item->supplier_status = $isPaid ? 'Paid' : 'Unpaid';
        $item->save();

        return response()->json([
            'success' => true,
            'message' => $isPaid
                ? 'Item marked as paid and supplier status set to Paid'
                : 'Item marked as unpaid and supplier status set to Unpaid',
            'item' => $item,
        ]);

    }

    public function adminUpdate(Request $request, Orders $order)
    {
        // only admins hit this via middleware
        $v = Validator::make($request->all(), [
            'discount'        => ['sometimes','required','numeric','min:0'],
            'is_paid'         => ['sometimes','required','boleean'],
            'item_id'         => ['sometimes','required','numeric','min:1'],  
        ]);

        if ($v->fails()) {
            return response()->json(['error' => $v->errors()], 422);
        }
        //for discount
        

        $dirty = [];

        //for discount
        if ($request->has('discount')) {
            $dirty['discount'] = (float)$request->discount;
            // dd($request->discount);
            // Apply updates
            $order->update($dirty);

            // Refresh minimal payload
            $order->load(['project:id,name','items:id,order_id,product_id,supplier_id,supplier_delivery_date']);
            // Recalculate customer-facing totals only
            OrderPricingService::recalcCustomer($order, null, null, true);

            return response()->json([
                'success' => true,
                'message' => 'Order updated by admin',
                'order'   => $order,
            ]);
        }

        if ($request->has('item_id') && $request->has('is_paid')) {
            $item = OrderItem::find((int)$request->item_id);
            if (!$item) {
                return response()->json(['error' => 'Item not found'], 404);
            }

            $isPaid = filter_var($request->is_paid, FILTER_VALIDATE_BOOLEAN);

            $item->is_paid = $isPaid ? 1 : 0;
            $item->supplier_status = $isPaid ? 'Paid' : 'Unpaid';
            $item->save();

            return response()->json([
                'success' => true,
                'message' => $isPaid
                    ? 'Item marked as paid and supplier status set to Paid'
                    : 'Item marked as unpaid and supplier status set to Unpaid',
                'item' => $item,
            ]);
        }
        
    }


    /** Decode users.delivery_zones JSON to [['lat'=>..,'lng'=>..,'radius_km'=>?...],...] */
    private function decodeZones($json): array
    {
        try {
            $raw = is_array($json) ? $json : json_decode($json, true, 512, JSON_THROW_ON_ERROR);
        } catch (\Throwable $e) {
            return [];
        }
        $zones = [];
        foreach ((array)$raw as $z) {
            $lat = $z['lat'] ?? $z['latitude'] ?? null;
            $lng = $z['lng'] ?? $z['longitude'] ?? null;
            $rkm = $z['radius_km'] ?? $z['radius'] ?? null;
            if (is_numeric($lat) && is_numeric($lng)) {
                $zones[] = ['lat'=>(float)$lat,'lng'=>(float)$lng,'radius_km'=>is_numeric($rkm)?(float)$rkm:null];
            }
        }
        return $zones;
    }

    /** Nearest zones center distance in km */
    private function nearestZoneDistanceKm(array $zones, float $lat, float $lng): ?float
    {
        // dd($zones, $lat , $lng);
        $min = null;
        foreach ($zones as $z) {
            $d = $this->haversineKm($lat, $lng, $z['lat'], $z['long']);
            if ($min === null || $d < $min) $min = $d;
        }
        return $min;
    }

    /** Haversine distance in km */
    private function haversineKm(float $lat1, float $lon1, float $lat2, float $lon2): float
    {
        $R = 6371;
        $dLat = deg2rad($lat2 - $lat1);
        $dLon = deg2rad($lon2 - $lon1);
        $a = sin($dLat/2)**2 + cos(deg2rad($lat1))*cos(deg2rad($lat2))*sin($dLon/2)**2;
        return 2 * $R * atan2(sqrt($a), sqrt(1 - $a));
    }



    public function setItemQuotedPrice(Request $request, int $orderId, int $itemId)
    {
       
        $data = $request->validate([
            'quoted_price' => 'nullable|numeric|min:0', // null clears quote
        ]);

        $check = Orders::where('id',$orderId)->where('payment_status','pending')->first();

        if(!$check)
        {
            return response()->json([
                'error'=>"Can not update it's pricing now",
            ], 409);
        }

        return DB::transaction(function () use ($orderId, $itemId, $data) {
            // Lock the item row and guarantee it belongs to the order
            /** @var OrderItem $item */
            $item = OrderItem::where('order_id', $orderId)
                ->lockForUpdate()
                ->findOrFail($itemId);

            // Important: do not coerce null to 0.00
            $quoted = array_key_exists('quoted_price', $data) ? $data['quoted_price'] : null;

            // Assign and save
            $item->forceFill([
                'quoted_price' => $quoted,                 // stays null if clearing
                'is_quoted'    => is_null($quoted) ? 0 : 1,
            ]);

            $item->saveOrFail();

            // Recalculate customer-facing totals only
            $order = Orders::with('items')->findOrFail($orderId);
            OrderPricingService::recalcCustomer($order, null, null, true);

            return response()->json([
                'message' => 'Quoted price saved. Customer totals recalculated.',
                'order' => [
                    'id'                     => $order->id,
                    'customer_item_cost'     => $order->customer_item_cost,
                    'customer_delivery_cost' => $order->customer_delivery_cost,
                    'gst_tax'                => $order->gst_tax,
                    'total_price'            => $order->total_price,
                    'profit_amount'          => $order->profit_amount,
                    'profit_margin_percent'  => $order->profit_margin_percent,
                ],
                'item' => [
                    'id'           => $item->id,
                    'is_quoted'    => (int)$item->is_quoted,
                    'quoted_price' => $item->quoted_price, // null if cleared
                ],
            ]);
        });
    }


    public function updateOrderPricingAdmin(Request $request, OrderItem $orderItem)
    {
        $v = Validator::make($request->all(), [
            'supplier_unit_cost' => 'sometimes|required|numeric|min:0',
            'supplier_discount' => 'sometimes|required|numeric|min:0',
            'supplier_delivery_date' => 'sometimes|required|date',
            'supplier_confirms' => 'sometimes|required|boolean',
            'delivery_cost' => 'sometimes|required|numeric|min:0',
            'delivery_type'=> 'required|in:Included,Supplier,ThirdParty,Fleet,None ',
            'supplier_notes' => 'sometimes|nullable|string|max:500',
            'quantity' => 'sometimes|nullable|numeric|min:1'
        ]);

        if ($v->fails()) {
            return response()->json(['error' => $v->errors()], 422);
        }

        // Check if the authenticated user is the supplier for this order item

        if(!in_array($orderItem->order->workflow, ['Supplier Assigned', 'Requested', 'Payment Requested'])) {  //, 'Payment Requested', 'On Hold', 'Delivered'
            return response()->json([
                'message' => 'Cannot update order item now as the order is in '.$orderItem->order->workflow.' status'
            ], 403);
        }   

        // Check if order item is already confirmed
        if ($orderItem->supplier_confirms && $request->has('supplier_confirms') && !$request->supplier_confirms) {
            return response()->json([
                'message' => 'Cannot unconfirm an already confirmed order item'
            ], 422);
        }

        try {
            DB::beginTransaction();

            // Update the order item with provided fields
            $updateData = [];
            
            if ($request->has('supplier_unit_cost')) {
                $updateData['supplier_unit_cost'] = $request->supplier_unit_cost;
            }
            
            if ($request->has('delivery_cost')) {
                $updateData['delivery_cost'] = $request->delivery_cost;
            }
            
            if ($request->has('supplier_discount')) {
                $updateData['supplier_discount'] = $request->supplier_discount;
            }

            if ($request->has('delivery_type')) {
                $updateData['delivery_type'] = $request->delivery_type;
            }
            
            if ($request->has('supplier_delivery_date')) {
                $updateData['supplier_delivery_date'] = $request->supplier_delivery_date;
            }
            
            if ($request->has('supplier_confirms')) {
                $updateData['supplier_confirms'] = $request->supplier_confirms;
            }
            
            if ($request->has('supplier_notes')) {
                $updateData['supplier_notes'] = $request->supplier_notes;
            }
            
            if($request->has('quantity')) {
                $updateData['quantity'] = $request->quantity;
            }

            // Update the order item
            $orderItem->update($updateData);

            // If supplier confirmed the order, trigger workflow check
            if ($request->has('supplier_confirms') && $request->supplier_confirms) {
                $this->workflow($orderItem->order);
            }

            DB::commit();

            // Reload the order item with relationships
            $orderItem->load(['order', 'product', 'chosenOffer']);

            return response()->json([
                'success' => true,
                'message' => 'Order item updated successfully',
                'data' => $orderItem
            ]);

        } catch (\Exception $e) {
            DB::rollBack();
            return response()->json([
                'error' => 'Failed to update order item: ' . $e->getMessage()
            ], 500);
        }
    }

    private function workflow(Orders $order)
    {
        $currentWorkflow = $order->workflow;

        switch ($currentWorkflow) {
            case 'Supplier Assigned':
                $allConfirmed = $order->items()->where('supplier_confirms', false)->count() === 0;
                if (!$allConfirmed) {
                    break;
                }

                // Constants
                $ADMIN_MARGIN    = 0.50;
                $DELIVERY_MARGIN = 0.10;
                $FLEET_MARGIN    = 0.15;
                $GST_RATE        = 0.10;

                // Accumulators
                $customer_item_cost     = 0.0;
                $customer_delivery_cost = 0.0;
                $supplier_item_cost     = 0.0;
                $supplier_delivery_cost = 0.0;

                foreach ($order->items as $item) {
                    // Supplier material cost
                    $base_material_cost = ($item->supplier_unit_cost * $item->quantity) - $item->supplier_discount;
                    if ($base_material_cost < 0) { $base_material_cost = 0; }
                    $supplier_item_cost += $base_material_cost;

                    // Customer item cost with admin margin or quoted override
                    if ((int)$item->is_quoted === 1 && $item->quoted_price !== null) {
                        $customer_item_cost += (float)$item->quoted_price;
                    } else {
                        $customer_item_cost += $base_material_cost * (1 + $ADMIN_MARGIN);
                    }

                    // Delivery handling
                    $dtype = (string)$item->delivery_type;
                    if ($dtype === 'Supplier' || $dtype === 'ThirdParty') {
                        $customer_delivery_cost += $item->delivery_cost * (1 + $DELIVERY_MARGIN);
                        $supplier_delivery_cost += $item->delivery_cost;
                    } elseif ($dtype === 'Fleet') {
                        $customer_delivery_cost += $item->delivery_cost * (1 + $FLEET_MARGIN);
                        $supplier_delivery_cost += $item->delivery_cost;
                    } elseif ($dtype === 'Included' || $dtype === 'None' || $dtype === '' || $dtype === null) {
                        // No delivery cost
                    } else {
                        // Unknown type: supplier bears base delivery
                        $supplier_delivery_cost += (float)$item->delivery_cost;
                    }
                }

                // GST on customer-facing costs
                $gst_tax = ($customer_item_cost + $customer_delivery_cost) * $GST_RATE;

                // Totals
                $discount      = (float)($order->discount ?? 0);
                $other_charges = (float)($order->other_charges ?? 0);

                $total_price = $customer_item_cost
                            + $customer_delivery_cost
                            + $gst_tax
                            - $discount
                            + $other_charges;

                // Profit metrics
                $supplier_total    = $supplier_item_cost + $supplier_delivery_cost;
                $profit_before_tax = $total_price - $supplier_total - $gst_tax;
                $profit_margin_percent = $supplier_total > 0 ? ($profit_before_tax / $supplier_total) : 0.0;

                // Save to order
                $order->customer_item_cost     = round($customer_item_cost, 2);
                $order->customer_delivery_cost = round($customer_delivery_cost, 2);
                $order->supplier_item_cost     = round($supplier_item_cost, 2);
                $order->supplier_delivery_cost = round($supplier_delivery_cost, 2);
                $order->gst_tax                = round($gst_tax, 2);
                $order->total_price            = round($total_price, 2);

                // Actual profit amount (not percentage)
                $order->profit_amount          = round($profit_before_tax, 2);
                $order->profit_margin_percent  = round($profit_margin_percent,2);

                $order->workflow = 'Payment Requested';
                $order->order_status = "Confirmed";
                // dd($customer_item_cost, $customer_delivery_cost, $supplier_item_cost, $supplier_delivery_cost, $profit_margin_percent, $profit_before_tax);
                $order->save();

                break;
        }
    
    }

    public function updateOrderStatus(Request $request,Order $order){
        $v = Validator::make($request->all(), [
            'order_status' => ['required','string'],
        ]);
        if ($v->fails()) return response()->json(['error' => $v->errors()], 422);
        
        $order->order_status = $request->order_status;
        $order->save();

        // FIXED: Remove the extra "->order"
        return response()->json([
            'order_status' => $order->order_status,
            'message' => 'Order Status set to ' . $order->order_status
        ], 200);
    }

    public function updatePaymentStatus(Request $request,Orders $order){
        $v = Validator::make($request->all(), [
            'payment_status' => ['required','string'],
        ]);
        if ($v->fails()) return response()->json(['error' => $v->errors()], 422);
       
        $order->payment_status = $request->payment_status;
        $order->save();

        return response()->json([
            'payment_status' => $order->payment_status,
            'message' => 'Order Payment Status set to ' . $order->payment_status
        ], 200);
        
    }

    public function archiveOrder(Orders $order)
    {

        $order->is_archived = 1;
        $order->archived_by = Auth::id();
        $order->save();

        return response()->json([
            'success' => true,
            'message' => 'Order Deleted (Archived) successfully',
            'order'   => $order->only(['id','is_archived']),
        ]);
    }

    public function getArchive(Request $request) {
        $ordersPerPage = $request->get('orders_per_page', 10);
        $usersPerPage = $request->get('users_per_page', 10);
        $projectsPerPage = $request->get('projects_per_page', 10);

        // Fetch archived orders with relationships
        $orders = Orders::where('is_archived', 1)
                    ->with(['project:id,name', 'client:id,name'])
                    ->latest('updated_at')
                    ->paginate($ordersPerPage);

        // Fetch deleted users
        $users = User::where('isDeleted', 1)
                    ->latest('updated_at')
                    ->paginate($usersPerPage);

        // Fetch archived projects with client
        $projects = Projects::where('is_archived', 1)
                    ->with(['added_by:id,name'])
                    ->latest('updated_at')
                    ->paginate($projectsPerPage);

        return response()->json([
            'success' => true,
            'data' => [
                'orders' => [
                    'data' => $orders->items(),
                    'current_page' => $orders->currentPage(),
                    'per_page' => $orders->perPage(),
                    'total' => $orders->total(),
                    'last_page' => $orders->lastPage(),
                ],
                'users' => [
                    'data' => $users->items(),
                    'current_page' => $users->currentPage(),
                    'per_page' => $users->perPage(),
                    'total' => $users->total(),
                    'last_page' => $users->lastPage(),
                ],
                'projects' => [
                    'data' => $projects->items(),
                    'current_page' => $projects->currentPage(),
                    'per_page' => $projects->perPage(),
                    'total' => $projects->total(),
                    'last_page' => $projects->lastPage(),
                ],
            ]
        ]);
    }
}


------------------------------------------------------------
FILE: app/Http/Controllers/AdminController.php
------------------------------------------------------------
<?php
//To be deleted
namespace App\Http\Controllers;

use App\Models\User;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;



class AdminController extends Controller
{
    public function clients()
    {
        // dd('here');
        $clients = User::where('role', 'client')->get();
        $totalClients = $clients->count();
        $activeClients = $clients->where('status', 'Active')->count();
        $inactiveClients = $clients->where('status', 'In-Active')->count();
        $joinedThisMonth = $clients->where('created_at', '>=', now()->startOfMonth())->count();
        return view('clients.index', compact('clients','totalClients','activeClients','inactiveClients','joinedThisMonth'));
    }

    public function addClient(Request $request)
    {
        $data = $request->validate([
            'name'           => 'required|string|max:120',
            'email'          => 'required|email|max:120|unique:users,email',
            'password'       => 'required|string|min:8|confirmed',
            'company_name'   => 'nullable|string|max:120',
            'contact_name'   => 'nullable|string|max:100',
            'contact_number' => 'nullable|string|max:20',
            'shipping_address' => 'nullable|string|max:255',
            'delivery_address' => 'nullable|string|max:255',
        ]);


        $user = User::create([
            'name'           => $data['name'],
            'email'          => $data['email'],
            'password'       => Hash::make($data['password']),   // <-- hashed here
            'role'           => 'client',
            'company_name'   => $data['company_name'] ?? null,
            'contact_name'   => $data['contact_name'] ?? null,
            'contact_number' => $data['contact_number'] ?? null,
            'shipping_address' => $data['shipping_address'] ?? null,
            'delivery_address' => $data['delivery_address'] ?? null,
            'status'         => 'Active', // Default status
        ]);


        return redirect()->route('clients')->with('success', 'Client added successfully');
    }


    
}


------------------------------------------------------------
FILE: app/Http/Controllers/ApiAuthController.php
------------------------------------------------------------
<?php
namespace App\Http\Controllers;

use App\Models\User;
use App\Models\Company;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Str;
use Illuminate\Support\Facades\Validator;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Storage;
use Laravel\Sanctum\HasApiTokens;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Http;

class ApiAuthController extends Controller
{
    // Register Client
    public function registerClient(Request $request)
    {
        $validator = Validator::make($request->all(), [
            'name' => 'required|string|max:255',
            'email' => 'required|email|unique:users,email',
            'password' => 'required|string|min:6',
            'contact_name' => 'required|string|max:255',
            'contact_number' => 'required|string|max:255',
            'shipping_address' => 'required|string|max:255',
            'billing_address' => 'required|string|max:255',
            'profile_image' => 'nullable|image|max:2048', // Optional profile image
            'company_name' => 'nullable|string|max:255',
            'lat' => 'nullable|numeric',
            'long' => 'nullable|numeric',
        ]);

        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 400);
        }

        $imageUrl = null;
        // Handle profile image
        if ($request->hasFile('profile_image') && $request->file('profile_image')->isValid()) {
            // Store the file under 'profile_images' directory in the 'public' disk
            $path = $request->file('profile_image')->store('profile_images', 'public');
            $imageUrl = 'storage/' . $path; // Relative path to the image
        } 

        // Check if company exists, or create new
        $company = Company::firstOrCreate([
            'name' => Str::lower($request->company_name),
        ]);

        // Generate unique client ID
        do {
            $clientPublicId = 'MC-' . rand(100, 999);
        } while (User::where('client_public_id', $clientPublicId)->exists());

        // Register client
        $user = User::create([
            'name' => $request->name,
            'email' => $request->email,
            'password' => Hash::make($request->password),
            'role' => 'client',
            'company_id' => $company->id,
            'contact_name' => $request->contact_name,
            'contact_number' => $request->contact_number,
            'shipping_address' => $request->shipping_address,
            'billing_address' => $request->billing_address,
            'client_public_id' => $clientPublicId,
            'isDeleted' => false,
            'profile_image' => $imageUrl, // Store the relative path
            'lat' => $request->lat,
            'long' => $request->long,
        ]);

        // Create Sanctum Token for the user
        $token = $user->createToken('ClientApp')->plainTextToken;


        return response()->json([
            'message' => 'Client registered successfully.',
            'token' => $token,
            'user' => $user,
            'role' => $user->role,
            'profile_image_url' => $imageUrl, // Return the image URL in response
        ], 201);
    }


    // Register Supplier
    public function registerSupplier(Request $request)
    {
        $validator = Validator::make($request->all(), [
            'name' => 'required|string|max:255',
            'email' => 'required|email|unique:users,email',
            'password' => 'required|string|min:6',
            'contact_name' => 'required|string|max:255',
            'contact_number' => 'required|string|max:255',
            'location' => 'nullable|string|max:255',
            'company_name' => 'required|string|max:255',
            'profile_image' => 'nullable|image|max:2048', // Optional profile image
        ]);

        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 400);
        }

        // Check if company exists, or create new
        $company = Company::firstOrCreate([
            'name' => Str::lower($request->company_name), // Assuming the company name is based on contact name
        ]);

        $imageUrl = null;
        // Handle profile image
        if ($request->hasFile('profile_image') && $request->file('profile_image')->isValid()) {
            // Store the file under 'profile_images' directory in the 'public' disk
            $path = $request->file('profile_image')->store('profile_images', 'public');
            $imageUrl = 'storage/' . $path; // Relative path to the image
        }

        // Register supplier (auto-role assignment)
        $user = User::create([
            'name' => $request->name,
            'email' => $request->email,
            'password' => Hash::make($request->password),
            'role' => 'supplier', // Set role as supplier for registration
            'company_id' => $company->id,
            'contact_name' => $request->contact_name,
            'contact_number' => $request->contact_number,
            'location' => $request->location,
            'isDeleted' => false,
            'profile_image' => $imageUrl,
        ]);

        // Create Sanctum Token for the user
        $token = $user->createToken('SupplierApp')->plainTextToken;

        return response()->json([
            'message' => 'Supplier registered successfully.',
            'token' => $token,
            'user' => $user,
            'role' => $user->role,
            'profile_image_url' => $imageUrl, // Return the image URL in response
        ], 201);
    }
    
    // Login Function
    public function login(Request $request)
    {
        $validator = Validator::make($request->all(), [
            'email' => 'required|email',
            'password' => 'required|string|min:6',
        ]);

        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 400);
        }

        if (!User::where('email', $request->email)->exists()) {
            return response()->json(['error' => 'Email not registered.'], 404);
        }

        // Check credentials
        if (Auth::attempt(['email' => $request->email, 'password' => $request->password])) {
            $user = Auth::user();
            if($user->isDeleted == 1){
                return response()->json(['error' => 'Your account has been deleted. Please contact support.'], 403);
            }

            // Create a new token for the user
            $token = $user->createToken('UserApp')->plainTextToken;

            return response()->json([
                'message' => 'Login successful.',
                'token' => $token,
                'user' => $user,
                'role' => $user->role,
            ], 200);
        }

        return response()->json(['error' => 'Password is wrong'], 401);
    }


    public function checkAuth(Request $request)
    {
        // Check if the user is authenticated using Sanctum or session authentication
        if (Auth::check()) {
            // The user is authenticated
            $user = Auth::user()->load('company'); // Get the authenticated user
            if($user->role === 'supplier' && $user->delivery_zones && $user->delivery_zones !== 'null' && $user->delivery_zones !== null ) {
                $user->delivery_zones = $user->delivery_zones;
            }
    
            // Return the user details along with the role
            return response()->json([
                'message' => 'User is authenticated',
                'user' => $user,
                'role' => $user->role,
            ], 200); // 200 OK status code
        } else {
            // The user is not authenticated
            return response()->json([
                'message' => 'User is not authenticated',
            ], 401); // Unauthorized status code
        }
    }


    public function logout(Request $request)
    {
        $user = Auth::user();
        if ($request->boolean('all')) {
            $user->tokens()->delete();                 // revoke all tokens
        } else {
            $user->currentAccessToken()?->delete();    // revoke current token
        }
        return response()->json(['message' => 'Logged out'], 200);
    }

    /**
     * Update profile (no password). Handles client and supplier fields.
     * Accepts:
     *  - Common: name, email, contact_name, contact_number, profile_image
     *  - Client: shipping_address, billing_address, lat, long, company_name
     *  - Supplier: location, delivery_radius, company_name
     */
    public function updateProfile(Request $request)
    {
        $user = Auth::user();

        $validator = Validator::make($request->all(), [
            'name'            => 'sometimes|string|max:255',
            'email'           => 'sometimes|email|unique:users,email,' . $user->id,
            'contact_name'    => 'sometimes|nullable|string|max:255',
            'contact_number'  => 'sometimes|nullable|string|max:255',
            'profile_image'   => 'sometimes|file|image|max:4096',

            // client fields
            'shipping_address'=> 'sometimes|nullable|string|max:255',
            'billing_address' => 'sometimes|nullable|string|max:255',
            'lat'             => 'sometimes|nullable|numeric',
            'long'            => 'sometimes|nullable|numeric',

            // supplier fields
            'location'        => 'sometimes|nullable|string|max:255',
            'delivery_radius' => 'sometimes|nullable|numeric',

            // both roles may set or change company
            'company_name'    => 'sometimes|nullable|string|max:255',
        ]);

        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 422);
        }

        // company
        $companyId = $user->company_id;
        if ($request->filled('company_name')) {
            $company = Company::firstOrCreate(['name' => Str::lower($request->company_name)]);
            $companyId = $company->id;
        }

        // profile image
        $profileImagePath = $user->profile_image;
        if ($request->hasFile('profile_image') && $request->file('profile_image')->isValid()) {
            if ($profileImagePath) {
                $old = str_replace('storage/', '', $profileImagePath);
                Storage::disk('public')->delete($old);
            }
            $stored = $request->file('profile_image')->store('profile_images', 'public');
            $profileImagePath = 'storage/' . $stored;
        }

        // payload
        $data = [
            'name'            => $request->input('name', $user->name),
            'email'           => $request->input('email', $user->email),
            'contact_name'    => $request->input('contact_name', $user->contact_name),
            'contact_number'  => $request->input('contact_number', $user->contact_number),
            'profile_image'   => $profileImagePath,
            'company_id'      => $companyId,
        ];

        if ($user->role === 'client') {
            $data += [
                'shipping_address'=> $request->input('shipping_address', $user->shipping_address),
                'billing_address' => $request->input('billing_address', $user->billing_address),
                'lat'             => $request->input('lat', $user->lat),
                'long'            => $request->input('long', $user->long),
            ];
        }

        if ($user->role === 'supplier') {
            $data += [
                'location'        => $request->input('location', $user->location),
                'delivery_radius' => $request->input('delivery_radius', $user->delivery_radius),
            ];
        }

        $user->update($data);

        return response()->json([
            'message' => 'Profile updated',
            'user'    => $user->fresh((['company'])),
        ], 200);
    }

    /**
     * Change password.
     * Required: current_password, new_password, new_password_confirmation
     */
    public function changePassword(Request $request)
    {
        $validator = Validator::make($request->all(), [
            'current_password'        => 'required|string',
            'new_password'            => 'required|string|min:6|confirmed',
            // field name must be new_password_confirmation
        ], [
            'new_password.confirmed' => 'New password confirmation does not match.',
        ]);

        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 422);
        }

        $user = Auth::user();

        if (!Hash::check($request->current_password, $user->password)) {
            return response()->json(['error' => ['current_password' => ['Current password is incorrect.']]], 400);
        }

        $user->password = Hash::make($request->new_password);
        $user->save();

        // Optional: rotate token on password change
        $request->user()->tokens()->delete();
        $newToken = $user->createToken('UserApp')->plainTextToken;

        return response()->json([
            'message' => 'Password updated',
            'token'   => $newToken,
        ], 200);
    }
    
    
    public function dataHanlde(Request $request)
    {
        // Loop through each user from the request
        foreach ($request->all() as $user) {
            // Generate client_public_id based on the count of users in the database
            $client_public_id = 'MC-' . str_pad(User::count() + 440, 3, '0', STR_PAD_LEFT);
    
            // Prepare user data to insert into the users table
            $userData = [
                'name' => $user['name'],
                'contact_name' => $user['contact_name'],
                'email' => isset($user['email']) ? $user['email'] : null, // Use email if provided, otherwise set to null
                'password' => Hash::make('password'), // Use Hash::make to securely hash the password
                'status' => 'active',
                'client_public_id' => $client_public_id,
                'role' => 'supplier',
                'company_id' => $user['company_id'], // Use the company_id from the request
            ];
    
            // Create a new user record
            User::create($userData);
        }
    
        return response()->json(['message' => 'Users have been successfully added!']);
    }


public function deliveryZonesManagementWithLatLong(Request $request)
{
    // Google Maps API Key
    $googleMapsApiKey = "AIzaSyAUjFL6wmCy8ETAqV1bhFRUEySaUAAX2_k"; // Store your Google Maps API Key in .env file

    // Validate the request
    $validator = Validator::make($request->all(), [
        'zones' => 'sometimes|array',
        'zones.*.user_id' => 'required|exists:users,id', // Ensure the user_id exists in users table
        'zones.*.address' => 'sometimes|string|max:255',
        'zones.*.radius' => 'sometimes|numeric',
    ]);

    if ($validator->fails()) {
        return response()->json(['error' => $validator->errors()], 400);
    }

    // Check if zones are provided, otherwise clear the delivery zones
    if (!$request->zones || count($request->zones) === 0) {
        return response()->json(['message' => 'No zones provided'], 400);
    }

    // Initialize an array to collect zones by user_id
    $userZones = [];

    // Loop through each zone and get latitude and longitude using Google Maps API
    foreach ($request->zones as $zone) {
        // Google Maps Geocoding API request
        $response = Http::get('https://maps.googleapis.com/maps/api/geocode/json', [
            'address' => $zone['address'],
            'key' => $googleMapsApiKey,
        ]);

        // Check if the response is successful
        if ($response->successful()) {
            $result = $response->json()['results'][0] ?? null;

            if ($result) {
                // Extract latitude and longitude from the response
                $lat = $result['geometry']['location']['lat'];
                $long = $result['geometry']['location']['lng'];

                // Create the zone data with lat, long, and radius
                $zoneData = [
                    'address' => $zone['address'],
                    'lat' => $lat,
                    'long' => $long,
                    'radius' => $zone['radius'],
                ];

                // Append the zone to the user's zones collection
                if (!isset($userZones[$zone['user_id']])) {
                    $userZones[$zone['user_id']] = [];
                }
                $userZones[$zone['user_id']][] = $zoneData;
            }
        }
    }

    // Now update each user with their corresponding zones
    foreach ($userZones as $userId => $zones) {
        // Find the user by user_id
        $user = DB::table('users')->where('id', $userId)->first();

        if (!$user) {
            return response()->json(['error' => 'Supplier not found for user_id ' . $userId], 404);
        }

        // Check if the user already has zones, and merge new zones if needed
        $existingZones = json_decode($user->delivery_zones, true) ?? [];

        // Merge the existing zones with the new ones
        $mergedZones = array_merge($existingZones, $zones);

        // Update the delivery_zones for the user
        DB::table('users')
            ->where('id', $userId)
            ->update(['delivery_zones' => json_encode($mergedZones)]);
    }

    return response()->json(['message' => 'Delivery zones updated successfully']);
}

}


------------------------------------------------------------
FILE: app/Http/Controllers/AuthController.php
------------------------------------------------------------
<?php
//To be deleted
namespace App\Http\Controllers;

use App\Models\User;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Facades\Log;

class AuthController extends Controller
{
    public function registerAdmin(Request $request)
    {
        
        $data = $request->validate([
            'name'     => 'required|string|max:120',
            'email'    => 'required|email|max:120|unique:users,email',
            'password' => 'required|string|min:8|confirmed',
        ]);

        $user = User::create([
            'name'     => $data['name'],
            'email'    => $data['email'],
            'password' => Hash::make($data['password']),   // <-- hashed here
            'role'     => 'admin',
        ]);

        Auth::login($user);

        return response()->json(['message' => 'Admin registered successfully'], 201);

        // return redirect()->route('dashboard')->with('success', 'Admin registered successfully');
    }


    // Register (client only)
    public function register(Request $request)
    {
        $data = $request->validate([
            'name'           => 'required|string|max:120',
            'email'          => 'required|email|max:120|unique:users,email',
            'password'       => 'required|string|min:8|confirmed',
            'company_name'   => 'nullable|string|max:120',
            'contact_name'   => 'nullable|string|max:100',
            'contact_number' => 'nullable|string|max:20',
            'shipping_address' => 'nullable|string|max:255',
            'delivery_address' => 'nullable|string|max:255',
        ]);
        // dd($data);

        $user = User::create([
            'name'           => $data['name'],
            'email'          => $data['email'],
            'password'       => Hash::make($data['password']),   // <-- hashed here
            'role'           => 'client',
            'company_name'   => $data['company_name'] ?? null,
            'contact_name'   => $data['contact_name'] ?? null,
            'contact_number' => $data['contact_number'] ?? null,
            'shipping_address' => $data['shipping_address'] ?? null,
            'delivery_address' => $data['delivery_address'] ?? null,
            'status'         => 'Active', // Default status
        ]);

        Auth::login($user);
        // dd($user);
        return redirect()->route('dashboard')->with('success', 'Registered successfully');
    }

    // Login
  public function login(Request $request){
        $credentials = $request->validate([
            'email' => 'required|email',
            'password' => 'required',
        ]);

        if (Auth::attempt($credentials)) {
            $request->session()->regenerate();
            

            
            return redirect()->intended('/dashboard');
        }

        return back()->withErrors([
            'email' => 'Invalid credentials.',
        ]);
    }


    // Logout
    public function logout(Request $request)
    {
        Auth::logout();
        $request->session()->invalidate();
        $request->session()->regenerateToken();
        return redirect('/');
    }

    //dashboard
    public function dashboard()
    {
        
        return view('dashboard');
    }
}


------------------------------------------------------------
FILE: app/Http/Controllers/Controller.php
------------------------------------------------------------
<?php

namespace App\Http\Controllers;

abstract class Controller
{
    //
}


------------------------------------------------------------
FILE: app/Http/Controllers/OrderController.php
------------------------------------------------------------
<?php

namespace App\Http\Controllers;

use App\Models\Orders;
use App\Models\MasterProducts;
use App\Models\SupplierOffers;
use App\Models\OrderItem;
use App\Models\Projects;
use Illuminate\Support\Facades\DB;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Validator;

class OrderController extends Controller
{
    /**
     * Create a new order with multiple products.
     */
    public function createOrder(Request $request)
    {
        $v = Validator::make($request->all(), [
            'po_number'        => 'nullable|unique:orders,po_number|string|max:50',
            'project_id'       => 'required|exists:projects,id',
            'delivery_address' => 'required|string',
            'delivery_lat'     => 'required|numeric',
            'delivery_long'    => 'required|numeric',
            'delivery_date'    => 'required|date',
            'delivery_time'    => 'nullable|date_format:H:i',
            // 'delivery_method'  => 'in:Other,Tipper,Agitator,Pump,Ute',
            'load_size'        => 'nullable|string|max:50',
            'special_equipment'=> 'nullable|string|max:255',
            'items'            => 'required|array|min:1',
            'items.*.product_id'       => 'required|exists:master_products,id',
            'items.*.quantity'         => 'required|numeric|min:0.01',
            'items.*.custom_blend_mix' => 'nullable|string',
            'repeat_order'     => 'nullable|boolean',
            'special_notes'    => 'nullable|string|max:1000',
        ]);

        if ($v->fails()) {
            return response()->json(['error' => $v->errors()], 422);
        }

        $user = Auth::user();

        return DB::transaction(function () use ($request, $user) {
            // 1) Create order
            /** @var Orders $order */
            $order = Orders::create([
                'po_number'        => $request->po_number,
                'client_id'        => $user->id,
                'project_id'       => $request->project_id,
                'delivery_address' => $request->delivery_address,
                'delivery_lat'     => $request->delivery_lat,
                'delivery_long'    => $request->delivery_long,
                'delivery_date'    => $request->delivery_date,
                'delivery_time'    => $request->delivery_time,
                // 'delivery_method'  => $request->delivery_method,
                'load_size'        => $request->load_size,
                'special_equipment'=> $request->special_equipment,
                // monetary fields start at zero; youll roll them up later
                'other_charges'    => 0,
                'gst_tax'          => 0,
                'discount'         => 0,
                'total_price'      => 0,
                'supplier_item_cost'    => 0,
                'customer_item_cost'    => 0,
                'customer_delivery_cost'    => 0,
                'supplier_delivery_cost'    => 0,
                // initial states per spec
                'payment_status'   => 'Pending',
                'order_status'     => 'Draft',
                'order_process'    => 'Automated',
                'generate_invoice' => 0,
                'repeat_order'     => $request->repeat_order ? $request->repeat_order : 0,
                'special_notes'    => $request->special_notes ?? null,
                // add 'workflow' column in your table if not present yet
            ]);

            $lat = (float) $order->delivery_lat;
            $lng = (float) $order->delivery_long;

            // 2) Preload candidate offers for all requested product_ids
            $productIds = collect($request->items)->pluck('product_id')->unique()->values();
            // dd($productIds);
            $offers = SupplierOffers::with(['supplier:id,delivery_zones'])
                ->whereIn('master_product_id', $productIds)   // adjust column name if different
                ->where('status', 'Approved')                     // only approved offers
                ->whereIn('availability_status', ['In Stock', 'Limited'])                       // optional filter if you have it
                ->get()
                ->groupBy('master_product_id');
            $anyMissingSupplier = false;
            // dd($offers);
            // 3) Create items with nearest in-zone supplier if available
            foreach ($request->items as $row) {
                $pid   = (int) $row['product_id'];
                $qty   = (float) $row['quantity'];
                $blend = $row['custom_blend_mix'] ?? null;

                [$chosenOffer, $distanceKm] = $this->pickNearestOfferInZone(
                    $offers->get($pid) ?? collect(), $lat, $lng
                );

                if ($chosenOffer) {
                    $order->items()->create([
                        'product_id'             => $pid,
                        'quantity'               => $qty,
                        'supplier_id'            => $chosenOffer->supplier_id,
                        'custom_blend_mix'       => $blend,
                        'supplier_unit_cost'     => (float) ($chosenOffer->unit_cost ?? $chosenOffer->price ?? 0),
                        'supplier_delivery_cost' => (float) ($chosenOffer->delivery_cost ?? 0),
                        'supplier_delivery_date' => $order->delivery_date,
                        'choosen_offer_id'      => $chosenOffer->id,
                        'supplier_confirms'      => 0,
                    ]);
                } else {
                    $anyMissingSupplier = true;

                    $order->items()->create([
                        'product_id'             => $pid,
                        'quantity'               => $qty,
                        'supplier_id'            => null,
                        'custom_blend_mix'       => $blend,
                        'supplier_unit_cost'     => 0,
                        'supplier_delivery_cost' => 0,
                        'supplier_delivery_date' => $order->delivery_date,
                        'supplier_confirms'      => 0,
                    ]);
                }
            }

            // 4) Update workflow + order_process if any item unassigned
            if ($anyMissingSupplier) {
                $order->workflow      = 'Supplier Missing';
                $order->order_process = 'Action Required';
                $order->save();
            } else {
                // all items assigned to a supplier
                $order->workflow      = 'Supplier Assigned';
                $order->order_process = 'Automated';
                $order->save();
                // $this->workflow($order);
            }

            // Optionally eager-load for response
            $order->load(['items.product','items.supplier']);

            return response()->json([
                'message' => 'Order created',
                'order'   => $order
            ], 201);
        });
    }

    /** Repeat Order */
    public function repeatOrder(Request $request, Orders $order)
    {
        // Step 1: Validate the request data
        $v = Validator::make($request->all(), [
            'delivery_date'    => 'required|date',
            'items'            => 'required|array|min:1',
            'items.*.product_id'       => 'required|exists:master_products,id',
            'items.*.quantity'         => 'required|numeric|min:0.01',
            'special_notes'    => 'nullable|string|max:1000',
        ]);

        if ($v->fails()) {
            return response()->json(['error' => $v->errors()], 422);
        }

        $user = Auth::user();

        return DB::transaction(function () use ($request, $user, $order) {
            // Step 2: Create a new order (replicating the original order)
            $newOrder = $order->replicate();
            $newOrder->client_id = $user->id;
            $newOrder->delivery_date = $request->delivery_date;  // New delivery date
            $newOrder->payment_status = 'Pending';
            $newOrder->order_process = 'Automated';
            $newOrder->order_status = 'Draft';  // Default order status
            $newOrder->repeat_order = 1;  // Mark as repeat order
            $newOrder->special_notes = $request->special_notes ?? null;
            $newOrder->other_charges    = 0;
            $newOrder->gst_tax          = 0;
            $newOrder->discount         = 0;
            $newOrder->total_price      = 0;
            $newOrder->supplier_item_cost    = 0;
            $newOrder->customer_item_cost    = 0;
            $newOrder->customer_delivery_cost    = 0;
            $newOrder->supplier_delivery_cost    = 0;
            $newOrder->save();

            $lat = (float) $newOrder->delivery_lat;
            $lng = (float) $newOrder->delivery_long;

            // Step 3: Preload candidate offers for all requested product_ids
            $productIds = collect($request->items)->pluck('product_id')->unique()->values();
            $offers = SupplierOffers::with(['supplier:id,delivery_zones'])
                ->whereIn('master_product_id', $productIds)
                ->where('status', 'Approved')
                ->whereIn('availability_status', ['In Stock', 'Limited'])
                ->get()
                ->groupBy('master_product_id');

            $anyMissingSupplier = false;

            // Step 4: Create items for the new order with nearest available supplier
            foreach ($request->items as $row) {
                $pid   = (int) $row['product_id'];
                $qty   = (float) $row['quantity'];
                $blend = $row['custom_blend_mix'] ?? null;

                // Pick nearest available supplier
                [$chosenOffer, $distanceKm] = $this->pickNearestOfferInZone(
                    $offers->get($pid) ?? collect(), $lat, $lng
                );

                if ($chosenOffer) {
                    // If supplier found, create the order item with supplier data
                    $newOrder->items()->create([
                        'product_id'             => $pid,
                        'quantity'               => $qty,
                        'supplier_id'            => $chosenOffer->supplier_id,
                        'custom_blend_mix'       => $blend,
                        'supplier_unit_cost'     => (float) ($chosenOffer->unit_cost ?? $chosenOffer->price ?? 0),
                        'supplier_delivery_cost' => (float) ($chosenOffer->delivery_cost ?? 0),
                        'supplier_delivery_date' => $newOrder->delivery_date,
                        'choosen_offer_id'      => $chosenOffer->id,
                        'supplier_confirms'      => 0,
                    ]);
                } else {
                    // If no supplier is available, mark as missing supplier
                    $anyMissingSupplier = true;

                    $newOrder->items()->create([
                        'product_id'             => $pid,
                        'quantity'               => $qty,
                        'supplier_id'            => null,
                        'custom_blend_mix'       => $blend,
                        'supplier_unit_cost'     => 0,
                        'supplier_delivery_cost' => 0,
                        'supplier_delivery_date' => $newOrder->delivery_date,
                        'supplier_confirms'      => 0,
                    ]);
                }
            }

            // Step 5: Update the order workflow based on supplier assignment
            if ($anyMissingSupplier) {
                $newOrder->workflow = 'Supplier Missing';
                $newOrder->order_process = 'Action Required';
            } else {
                $newOrder->workflow = 'Supplier Assigned';
                $newOrder->order_process = 'Automated';
            }

            $newOrder->save();

            // Optionally eager-load for response
            $newOrder->load(['items.product', 'items.supplier']);

            return response()->json([
                'message' => 'Order repeated successfully',
                'order'   => $newOrder
            ], 201);
        });
    }


    // Helper function | Workflow 
    private function workflow(Orders $order)
    {
        $currentWorkflow = $order->workflow;

        switch ($currentWorkflow) {
            case 'Supplier Assigned':
                $allConfirmed = $order->items()->where('supplier_confirms', false)->count() === 0;
                if ($allConfirmed) {
                    // Calculate pricing
                    $subtotal = 0;
                    $supplierCost = 0;
                    $adminMarginPercentage = 0.50; // 50% admin margin
                    $deliveryCost = 0;
                    $fuelLevy = 0;
                    $itemCostWithMargin= 0;
                    $adminMarginAmount = 0;
                    
                    foreach ($order->items as $item) {
                        // Calculate item cost excluding delivery
                        $itemCost = ($item->supplier_unit_cost * $item->quantity) - $item->supplier_discount;
                        
                        // Add admin margin to item cost (50% on top of item cost)
                        $itemCostWithMargin = $itemCost + ($itemCost * $adminMarginPercentage);
                        
                        $subtotal += $itemCostWithMargin;
                        $supplierCost += $itemCost; // Supplier cost without admin margin
                        $deliveryCost += $item->supplier_delivery_cost;
                    }
                   
                    
                    // Calculate fuel levy (10% on delivery cost as per your example)
                    $fuelLevy = $deliveryCost + ($deliveryCost * 0.10);
                    //  dd($subtotal,$fuelLevy);
                    
                    // Calculate GST (10% on subtotal)
                    $gstTax = $subtotal * 0.10;
                    
                    // Calculate total price
                    $totalPrice = $subtotal + $gstTax + $fuelLevy - $order->discount + $order->other_charges;
                    
                    // Calculate actual admin margin amount (for tracking)
                    $adminMarginAmount = $subtotal * $adminMarginPercentage;

                    // Update order pricing fields
                    $order->subtotal = $subtotal;
                    $order->fuel_levy = $fuelLevy;
                    $order->gst_tax = $gstTax;
                    $order->total_price = $totalPrice;
                    $order->supplier_cost = $supplierCost + $deliveryCost; // Total supplier cost including delivery
                    $order->customer_cost = $totalPrice;
                    $order->admin_margin = $adminMarginAmount; // The actual margin amount
                    $order->workflow = 'Payment Requested';
                    $order->save();
                }
                break;
        }
    }


    /**
     * Pick nearest offer whose supplier has a delivery zone covering the point.
     * Zones format expected on users.delivery_zones: JSON array of
     * [{ "lat": <float>, "long": <float>, "radius": <km as number>, "address": "..." }, ...]
     * Returns [SupplierOffers|null, float distanceKm]
     */
    private function pickNearestOfferInZone($offersForProduct, float $lat, float $lng): array
    {
        // dd( $offersForProduct, $lat, $lng);
        $bestOffer = null;
        $bestDist  = PHP_FLOAT_MAX;

        foreach ($offersForProduct as $offer) {
            $supplier = $offer->supplier;
            if (!$supplier || empty($supplier->delivery_zones)) {
                continue;
            }

            $zones = is_string($supplier->delivery_zones)
                ? json_decode($supplier->delivery_zones, true)
                : $supplier->delivery_zones;
            // dd($zones);

            if (!is_array($zones)) {
                continue;
            }

            foreach ($zones as $z) {
                if (!isset($z['lat'], $z['long'], $z['radius'])) {
                    continue;
                }
                $distKm = $this->haversineKm($lat, $lng, (float)$z['lat'], (float)$z['long']);
                
                if ($distKm <= (float)$z['radius']) {
                    // dd($distKm, $bestDist);
                    // inside this zone
                    if ($distKm < $bestDist) {
                        $bestDist  = $distKm;
                        $bestOffer = $offer;
                    }
                }
            }
        }

        return [$bestOffer, $bestOffer ? $bestDist : INF];
    }

    private function haversineKm(float $lat1, float $lon1, float $lat2, float $lon2): float
    {
        $R = 6371.0088; // mean Earth radius in km
        $dLat = deg2rad($lat2 - $lat1);
        $dLon = deg2rad($lon2 - $lon1);
        $a = sin($dLat/2) * sin($dLat/2)
           + cos(deg2rad($lat1)) * cos(deg2rad($lat2))
           * sin($dLon/2) * sin($dLon/2);
        $c = 2 * atan2(sqrt($a), sqrt(1-$a));
        return $R * $c;
    }


    public function getClientProducts(Request $request)
    {
        // $user    = Auth::user();
        $perPage = (int) $request->integer('per_page', 10);
        $page    = (int) $request->integer('page', 1);
        $perPage = 1000;
        // aggregate approved, available offers per product (scoped to this client's suppliers)
        $offersAgg = SupplierOffers::query()
            ->select('supplier_offers.master_product_id')
            ->selectRaw('MIN(supplier_offers.price) AS price_min')
            ->selectRaw('MAX(supplier_offers.price) AS price_max')
            ->join('users as suppliers', 'suppliers.id', '=', 'supplier_offers.supplier_id')
            // ->where('suppliers.client_id', $user->id)
            ->where('supplier_offers.status', 'Approved')
            ->whereIn('supplier_offers.availability_status', ['In Stock', 'Limited'])
            ->groupBy('supplier_offers.master_product_id');

        $query = MasterProducts::query()
            ->joinSub($offersAgg, 'oa', function ($join) {
                $join->on('oa.master_product_id', '=', 'master_products.id');
            })
            ->select('master_products.*', 'oa.price_min', 'oa.price_max');

        // search by product_name
        if ($search = trim((string) $request->get('search'))) {
            $query->where('master_products.product_name', 'like', "%{$search}%");
        }

        // filter by category_id
        if ($request->filled('category')) {
            $query->where('master_products.category', $request->get('category'));
        }

        // sort
        if ($request->get('sort') === 'price') {
            $query->orderBy('oa.price_min', 'asc');
        } else {
            $query->orderBy('master_products.product_name', 'asc');
        }
        $query->whereNotIn('master_products.product_type', ['pavers','paver','bricks','brick','blocks','block']);

        $products = $query->with('category')->paginate($perPage, ['*'], 'page', $page);

        $products->getCollection()->transform(function ($p) {
            $p->price = ($p->price_min == $p->price_max)
                ? sprintf('$%.2f', $p->price_min)
                : sprintf('$%.2f - $%.2f', $p->price_min, $p->price_max);
            return $p;
        });

        return response()->json([
            'data' => $products->items(),
            'meta' => [
                'current_page' => $products->currentPage(),
                'per_page'     => $products->perPage(),
                'total'        => $products->total(),
                'last_page'    => $products->lastPage(),
            ],
        ]);
    }

    public function getClientProductDetails($id)
    {
        // dd($id);
        // $user = Auth::user();

        $product = MasterProducts::with('category')->find($id);
        if (!$product) {
            return response()->json(['error' => 'Product not found'], 404);
        }

        // fetch approved, available offers for this product (scoped to this client's suppliers)
        $offers = SupplierOffers::with(['supplier:id,company_name,delivery_zones'])
            ->where('master_product_id', $product->id)
            // ->whereHas('supplier', function ($q) use ($user) {
            //     $q->where('client_id', $user->id);
            // })
            ->where('status', 'Approved')
            ->whereIn('availability_status', ['In Stock', 'Limited'])
            ->orderBy('price', 'asc')
            ->get();

        return response()->json($product);
    }

    //Get my orders
    // public function getMyOrders(Request $request)
    // {
    //     $user = Auth::user();

    //     $details = filter_var($request->get('details', false), FILTER_VALIDATE_BOOLEAN);

    //     $perPage = (int) $request->get('per_page', 10);
    //     $search  = trim((string) $request->get('search', ''));
    //     $sort    = $request->get('sort', 'created_at');
    //     $dir     = strtolower($request->get('dir', 'desc')) === 'asc' ? 'asc' : 'desc';
    //     $delivery_date = $request->get('delivery_date');
    //     $project_id    = $request->get('project_id');
    //     $workflow      = $request->get('workflow');
    //     $order_status = $request->get('order_status');
    //     $repeat_order   = null;
    //     if($request->has('repeat_order')) {
    //         $repeat_order = $request->get('repeat_order');
    //         if($repeat_order === 'true' || $repeat_order === '1') {
    //             $repeat_order = true;
    //         } elseif($repeat_order === 'false' || $repeat_order === '0') {
    //             $repeat_order = false;
    //         } else {
    //             $repeat_order = null; // invalid value, ignore filter
    //         }
    //     } else {
    //         $repeat_order = null;
    //     }

    //     $query = Orders::with(['project','items.product','items.supplier'])
    //         ->where('client_id', $user->id);

    //     if ($search !== '')        $query->where('po_number', 'like', "%{$search}%");
    //     if ($delivery_date)        $query->whereDate('delivery_date', $delivery_date);
    //     if ($project_id)           $query->where('project_id', $project_id);
    //     if ($workflow)             $query->where('workflow', $workflow);
    //     if ($repeat_order !== null) $query->where('repeat_order', (bool)$repeat_order);
    //     if ($order_status)         $query->where('order_status',$order_status);
    //     // dd($repeat_order);
    //     $allowedSorts = ['po_number','delivery_date','created_at','updated_at'];
    //     if (!in_array($sort, $allowedSorts, true)) $sort = 'created_at';

    //     $orders = $query->orderBy($sort, $dir)->paginate($perPage);

    //     // enrich each order with order_info
    //     $enriched = collect($orders->items())->map(function (Orders $o) {
    //         $missing = $o->items->whereNull('supplier_id');
    //         if ($o->workflow === 'Supplier Missing') {
    //             $missingNames = $missing->map(fn($it) => optional($it->product)->product_name)
    //                                     ->filter()->unique()->values()->all();
    //             $o->order_info = 'Supplier missing for: ' . implode(', ', $missingNames);
    //         } elseif ($o->workflow === 'Supplier Assigned') {
    //             $o->order_info = 'Waiting for suppliers to confirm';
    //         } elseif ($o->workflow === 'Payment Requested') {
    //             $o->order_info = 'Awaiting your payment';
    //         } else {
    //             $o->order_info = null;
    //         }
    //         return $o;
    //     })->values()->all();

    //     $base = Orders::where('client_id', $user->id);
    //     $metrics = [
    //         'total_orders_count'      => (clone $base)->count(),
    //         'supplier_missing_count'  => (clone $base)->where('workflow', 'Supplier Missing')->count(),
    //         'supplier_assigned_count' => (clone $base)->where('workflow', 'Supplier Assigned')->count(),
    //         'awaiting_payment_count'  => (clone $base)->where('workflow', 'Payment Requested')->count(),
    //         'delivered_count'         => (clone $base)->where('workflow', 'Delivered')->count(),
    //     ];

    //     $response = [
    //         'data' => $enriched,
    //         'pagination' => [
    //             'per_page' => $orders->perPage(),
    //             'current_page' => $orders->currentPage(),
    //             'total_pages' => $orders->lastPage(),
    //             'total_items' => $orders->total(),
    //             'has_more_pages' => $orders->hasMorePages(),
    //         ],
    //         'metrics' => $metrics,
    //     ];

    //     if ($details) {
    //         $projects = Projects::where('added_by', $user->id)
    //             ->orderBy('created_at','desc')
    //             ->get(['id','name']);
    //         $response['projects'] = $projects;
    //     }

    //     return response()->json($response);
    // }
    public function getMyOrders(Request $request)
    {
        $user = Auth::user();

        $details = filter_var($request->get('details', false), FILTER_VALIDATE_BOOLEAN);

        $perPage = (int) $request->get('per_page', 10);
        $search  = trim((string) $request->get('search', ''));
        $sort    = $request->get('sort', 'created_at');
        $dir     = strtolower($request->get('dir', 'desc')) === 'asc' ? 'asc' : 'desc';
        $delivery_date = $request->get('delivery_date');
        $project_id    = $request->get('project_id');
        $order_status  = $request->get('order_status');
        $payment_status = $request->get('payment_status');
        $delivery_method = $request->get('delivery_method');
        
        $repeat_order   = null;
        if($request->has('repeat_order')) {
            $repeat_order = $request->get('repeat_order');
            if($repeat_order === 'true' || $repeat_order === '1') {
                $repeat_order = true;
            } elseif($repeat_order === 'false' || $repeat_order === '0') {
                $repeat_order = false;
            } else {
                $repeat_order = null;
            }
        }

        $query = Orders::with(['project','items.product'])
            ->where('client_id', $user->id)->where('is_archived', false);

        if ($search !== '')         $query->where('po_number', 'like', "%{$search}%");
        if ($delivery_date)         $query->whereDate('delivery_date', $delivery_date);
        if ($project_id)            $query->where('project_id', $project_id);
        if ($order_status)          $query->where('order_status', $order_status);
        if ($payment_status)        $query->where('payment_status', $payment_status);
        if ($delivery_method)       $query->where('delivery_method', $delivery_method);
        if ($repeat_order !== null) $query->where('repeat_order', (bool)$repeat_order);

        $allowedSorts = ['po_number','delivery_date','total_price','created_at','updated_at'];
        if (!in_array($sort, $allowedSorts, true)) $sort = 'created_at';

        $orders = $query->orderBy($sort, $dir)->paginate($perPage);

        $enriched = collect($orders->items())->map(function (Orders $o) {
            if ($o->order_status === 'Draft') {
                $o->order_info = 'Order draft created';
            } elseif ($o->order_status === 'Confirmed') {
                $o->order_info = 'Order confirmed, awaiting schedule';
            } elseif ($o->order_status === 'Scheduled') {
                $o->order_info = 'Order scheduled for delivery';
            } elseif ($o->order_status === 'In Transit') {
                $o->order_info = 'Order in transit';
            } elseif ($o->order_status === 'Delivered') {
                $o->order_info = 'Order delivered';
            } elseif ($o->order_status === 'Completed') {
                $o->order_info = 'Order completed';
            } elseif ($o->order_status === 'Cancelled') {
                $o->order_info = 'Order cancelled';
            } elseif ($o->payment_status === 'Unpaid' || $o->payment_status === 'Requested') {
                $o->order_info = 'Payment required';
            } else {
                $o->order_info = null;
            }
            return $o;
        })->values()->all();

        $base = Orders::where('client_id', $user->id);
        $metrics = [
            'total_orders_count'   => (clone $base)->count(),
            'draft_count'          => (clone $base)->where('order_status', 'Draft')->count(),
            'confirmed_count'      => (clone $base)->where('order_status', 'Confirmed')->count(),
            'scheduled_count'      => (clone $base)->where('order_status', 'Scheduled')->count(),
            'in_transit_count'     => (clone $base)->where('order_status', 'In Transit')->count(),
            'delivered_count'      => (clone $base)->where('order_status', 'Delivered')->count(),
            'completed_count'      => (clone $base)->where('order_status', 'Completed')->count(),
            'cancelled_count'      => (clone $base)->where('order_status', 'Cancelled')->count(),
        ];

        $response = [
            'data' => $enriched,
            'pagination' => [
                'per_page' => $orders->perPage(),
                'current_page' => $orders->currentPage(),
                'total_pages' => $orders->lastPage(),
                'total_items' => $orders->total(),
                'has_more_pages' => $orders->hasMorePages(),
            ],
            'metrics' => $metrics,
        ];

        if ($details) {
            $projects = Projects::where('added_by', $user->id)
                ->orderBy('created_at','desc')
                ->get(['id','name']);
            
            $response['projects'] = $projects;
            $response['order_statuses'] = ['Draft', 'Confirmed', 'Scheduled', 'In Transit', 'Delivered', 'Completed', 'Cancelled'];
            $response['payment_statuses'] = ['Unpaid', 'Partially Paid', 'Paid'];
            $response['delivery_methods'] = ['Tipper', 'Agitator', 'Pump', 'Ute', 'Other'];
        }

        return response()->json($response);
    }


    /**
     * Client view. If workflow = Supplier Missing, include eligible suppliers per missing item.
     */
    public function viewMyOrder(Orders $order)
    {
        abort_unless($order->client_id === Auth::id(), 403);

        $order->load(['project','items.product','items.supplier']);

        $missing = $order->items->whereNull('supplier_id');
            if ($order->workflow === 'Supplier Missing') {
                $missingNames = $missing->map(fn($it) => optional($it->product)->product_name)
                                        ->filter()->unique()->values()->all();
                $order->order_info = 'Supplier missing for: ' . implode(', ', $missingNames);
            } elseif ($order->workflow === 'Supplier Assigned') {
                $order->order_info = 'Waiting for suppliers to confirm';
            } elseif ($order->workflow === 'Payment Requested') {
                $order->order_info = 'Awaiting your payment';
            } else {
                $order->order_info = null;
            }

        $orderData = $order->only([
            'id','po_number','project_id','client_id','workflow','delivery_address','order_status',
            'delivery_date','delivery_time','delivery_method','repeat_order','customer_item_cost','payment_status','customer_delivery_cost','discount','other_charges','gst_tax','total_price','reason','created_at','updated_at'
        ]);
        
        $order->items->each(function (OrderItem $item) use ($order) {
            $item->supplier_unit_cost = (((float) $item->supplier_unit_cost - (float)$item->supplier_discount)/2) + (float) $item->supplier_unit_cost ;
        });

        $orderData['project'] = optional($order->project)?->only(['id','name','site_contact_name','site_contact_phone','site_instructions']);
        $orderData['order_info'] = $order->order_info;
        return response()->json([
            'success' => true,
            'data' => [
                'order' => $orderData,
                'items' => $order->items,
            ],
        ]);
    }


    /**
     * Assign a supplier to a specific order item and advance workflow if all assigned.
     * Body: { "supplier_id": <int> }
     */
    public function assignSupplier(Request $request, OrderItem $item)
    {
        $v = Validator::make($request->all(), ['supplier_id' => 'required|exists:users,id']);
        if ($v->fails()) return response()->json(['error'=>$v->errors()], 422);

        $order = $item->order()->with('items')->first();
        abort_unless($order && $order->client_id === Auth::id(), 403);

        $supplierId = (int) $request->supplier_id;

        $chosenOffer = SupplierOffers::with('supplier:id,delivery_zones')
            ->where('supplier_id', $supplierId)
            ->where('master_product_id', $item->product_id)
            ->where('status', 'Approved')
            ->whereIn('availability_status', ['In Stock','Limited'])
            ->whereHas('supplier', fn($q) => $q->whereJsonLength('delivery_zones','>=',1))
            ->first();

        if (!$chosenOffer) {
            return response()->json(['error' => 'No valid offer with delivery zones for this product'], 422);
        }

        $item->update([
            'supplier_id'             => $chosenOffer->supplier_id,
            'choosen_offer_id'        => $chosenOffer->id,
            'supplier_unit_cost'      => (float) ($chosenOffer->unit_cost ?? $chosenOffer->price ?? 0),
            'supplier_delivery_cost'  => (float) ($chosenOffer->delivery_cost ?? 0),
            'supplier_delivery_date'  => $order->delivery_date,
            'supplier_confirms'       => false,
        ]);

        if ($order->items()->whereNull('supplier_id')->count() === 0) {
            $order->update(['workflow' => 'Supplier Assigned', 'order_process' => 'Automated']);
        }

        return response()->json([
            'success' => true,
            'message' => 'Supplier assigned',
            'order_workflow' => $order->workflow,
            'item' => $item->fresh(['product','supplier','chosenOffer']),
        ]);
    }



    /**
     * Mark or unmark an order as repeat order.
     */    
    public function markRepeatOrder(Orders $order, Request $request)
    {
        abort_unless($order->client_id === Auth::id(), 403);
        $order->repeat_order = true;
        $order->save();
        return response()->json([
            'success' => true,
            'message' => 'Order marked as repeat order',
            'order'   => $order->only(['id','repeat_order']),
        ]); 
    }

    
    public function reorderFromProject(Request $request)
    {
        $v = Validator::make($request->all(), [
            'project_id'       => 'required|exists:projects,id',
            'product_id'       => 'required|exists:master_products,id',
            'order_item_id'    => 'required|exists:order_items,id', // NEW
            'quantity'         => 'required|numeric|min:0.01',
            'po_number'        => 'nullable|unique:orders,po_number|string|max:50',
            'delivery_date'    => 'required|date',
            'delivery_time'    => 'nullable|date_format:H:i',
            'delivery_method'  => 'nullable|in:Other,Tipper,Agitator,Pump,Ute',
            'special_notes'    => 'nullable|string|max:1000',
            'custom_blend_mix' => 'nullable|string',
        ]);

        if ($v->fails()) {
            return response()->json(['error' => $v->errors()], 422);
        }

        $user = Auth::user();

        // Verify project belongs to user
        $project = Projects::where('id', $request->project_id)
            ->where('added_by', $user->id)
            ->first();

        if (!$project) {
            return response()->json(['error' => 'Project not found or unauthorized'], 404);
        }

        // Find template item and ensure it belongs to this client's project
        /** @var \App\Models\OrderItem|null $templateItem */
        $templateItem = OrderItem::where('id', $request->order_item_id)
            ->whereHas('order', function ($q) use ($user, $project) {
                $q->where('client_id', $user->id)
                ->where('project_id', $project->id);
            })
            ->first();

        if (!$templateItem) {
            return response()->json(['error' => 'Order item not found for this project'], 404);
        }

        return DB::transaction(function () use ($request, $user, $project, $templateItem) {
            // 1) Create order
            /** @var Orders $order */
            $order = Orders::create([
                'po_number'              => $request->po_number,
                'client_id'              => $user->id,
                'project_id'             => $request->project_id,
                'delivery_address'       => $project->delivery_address,
                'delivery_lat'           => $project->delivery_lat,
                'delivery_long'          => $project->delivery_long,
                'delivery_date'          => $request->delivery_date,
                'delivery_time'          => $request->delivery_time,
                'delivery_method'        => $request->delivery_method ?? 'Other',
                'load_size'              => null,
                'special_equipment'      => null,
                'other_charges'          => 0,
                'gst_tax'                => 0,
                'discount'               => 0,
                'total_price'            => 0,
                'supplier_item_cost'     => 0,
                'customer_item_cost'     => 0,
                'customer_delivery_cost' => 0,
                'supplier_delivery_cost' => 0,
                'payment_status'         => 'Pending',
                'order_status'           => 'Draft',
                'order_process'          => 'Automated',
                'generate_invoice'       => 0,
                'repeat_order'           => 1,
                'special_notes'          => $request->special_notes,
            ]);

            // 2) Create order item by COPYING pricing from template item
            $qty = (float) $request->quantity;

            $order->items()->create([
                'product_id'             => $request->product_id, // should match $templateItem->product_id
                'quantity'               => $qty,

                // copy supplier + offer
                'supplier_id'            => $templateItem->supplier_id,
                'choosen_offer_id'       => $templateItem->choosen_offer_id,

                // copy pricing
                'supplier_unit_cost'     => $templateItem->supplier_unit_cost,
                'supplier_delivery_cost' => $templateItem->supplier_delivery_cost,
                'supplier_discount'      => $templateItem->supplier_discount,

                // quoted logic (if used in your system)
                'is_quoted'              => $templateItem->is_quoted ?? $templateItem->is_qouted,
                'quoted_price'           => $templateItem->quoted_price,

                // copy other attributes
                'custom_blend_mix'       => $request->custom_blend_mix ?? $templateItem->custom_blend_mix,
                'delivery_type'          => $templateItem->delivery_type,
                'delivery_cost'          => $templateItem->delivery_cost,
                'supplier_delivery_date' => $order->delivery_date,

                // IMPORTANT: reset confirmation + payment
                'supplier_confirms'      => 0,
                'is_paid'                => 0,
            ]);

            // 3) Workflow based on whether supplier exists
            if ($templateItem->supplier_id) {
                $order->workflow      = 'Supplier Assigned';
                $order->order_process = 'Automated';
            } else {
                $order->workflow      = 'Supplier Missing';
                $order->order_process = 'Action Required';
            }

            $order->save();

            // If you want to recalc totals using your pricing service:
            // OrderPricingService::recalcCustomer($order, null, null, true);

            $order->load(['items.product', 'items.supplier']);

            return response()->json([
                'message' => 'Order created successfully from project item',
                'order'   => $order,
            ], 201);
        });
    }

    public function setOrderStatus(Orders $order, Request $request)
    {

        $v = Validator::make($request->all(), [
            'order_status' => 'required|in:Cancelled',
        ]);

        if ($v->fails()) {
            return response()->json(['error' => $v->errors()], 422);
        }

        $order->order_status = $request->order_status;
        $order->save();

        return response()->json([
            'success' => true,
            'message' => 'Order status updated',
            'order'   => $order->only(['id','order_status']),
        ]);
    }

    public function archiveOrder(Orders $order)
    {
        if($order->client_id !== Auth::id()) {
            return response()->json(['error' => 'Unauthorized'], 403);
        }

        $order->is_archived = 1;
        $order->archived_by = Auth::id();
        $order->save();

        return response()->json([
            'success' => true,
            'message' => 'Order archived',
            'order'   => $order->only(['id','is_archived']),
        ]);
    }
        

}




------------------------------------------------------------
FILE: app/Http/Controllers/PaymentController.php
------------------------------------------------------------
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Stripe\Stripe;
use Stripe\PaymentIntent;
use Stripe\Customer;
use App\Models\Orders;
use App\Models\User;

class PaymentController extends Controller
{
    public function __construct()
    {
        Stripe::setApiKey(env('STRIPE_SECRET'));
    }

    public function processPayment(Request $request)
    {
        $request->validate([
            'payment_method_id' => 'required|string',
            'order_id' => 'required|integer',
        ]);

        $order = Orders::findOrFail($request->order_id);
        $user = auth()->user();

        if ($order->client_id !== $user->id) {
            return response()->json(['error' => 'Unauthorized'], 403);
        }

        if ($order->workflow !== 'Payment Requested') {
            return response()->json(['error' => 'Order not ready for payment'], 400);
        }

        try {
            // Get or create Stripe customer
            $customerId = $this->getOrCreateCustomer($user);

            // Create and confirm payment in one step
            $paymentIntent = PaymentIntent::create([
                'amount' => round($order->total_price * 100),
                'currency' => 'aud',
                'customer' => $customerId,
                'payment_method' => $request->payment_method_id,
                'confirm' => true,
                'automatic_payment_methods' => [
                   'enabled' => true,
                   'allow_redirects' => 'never', // <-- key part
                ],
                'metadata' => [
                    'order_id' => $order->id,
                    'user_id' => $user->id,
                ],
            ]);

            if ($paymentIntent->status === 'succeeded') {
                $order->payment_status = 'Paid';
                $order->workflow = 'Delivered';
                $order->save();

                return response()->json([
                    'success' => true,
                    'message' => 'Payment successful',
                    'order' => [
                        'id' => $order->id,
                        'payment_status' => $order->payment_status,
                        'workflow' => $order->workflow,
                    ]
                ]);
            } else {
                $order->payment_status = 'Failed';
                $order->save();

                return response()->json([
                    'success' => false,
                    'message' => 'Payment failed',
                    'status' => $paymentIntent->status
                ], 400);
            }
        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => $e->getMessage()
            ], 500);
        }
    }

    private function getOrCreateCustomer(User $user)
    {
        if ($user->stripe_customer_id) {
            try {
                Customer::retrieve($user->stripe_customer_id);
                return $user->stripe_customer_id;
            } catch (\Exception $e) {
                // Customer doesn't exist, create new one
            }
        }

        $customer = Customer::create([
            'email' => $user->email,
            'name' => $user->name,
            'metadata' => [
                'user_id' => $user->id,
            ],
        ]);

        $user->stripe_customer_id = $customer->id;
        $user->save();

        return $customer->id;
    }
}

------------------------------------------------------------
FILE: app/Http/Controllers/ProjectController.php
------------------------------------------------------------
<?php

namespace App\Http\Controllers;

use App\Models\Projects as Project;
use App\Models\Orders;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Validator;
use Illuminate\Validation\Rule;

class ProjectController extends Controller
{
    /**
     * GET /client/projects
     *
     * Project listing for the client, including:
     * - total_orders (count of orders in project)
     * - total_order_amount (sum of order.total_price)
     * - basic filters (search, delivery date range, workflow)
     */
    public function index(Request $request)
    {
        $user = Auth::user();
        abort_unless($user && $user->role === 'client', 403, 'Forbidden');

        $perPage = (int) $request->get('per_page', 10);
        $search  = trim((string) $request->get('search', ''));
        $sort    = $request->get('sort', 'created_at');
        $dir     = strtolower($request->get('dir', 'desc')) === 'asc' ? 'asc' : 'desc';

        // order filters
        $order_status = $request->get('order_status');                // e.g. "Supplier Missing", "Payment Requested", etc.
        $ddFrom   = $request->get('delivery_date_from');      // Y-m-d
        $ddTo     = $request->get('delivery_date_to');        // Y-m-d

        // Base project query for this client
        $query = Project::query()
            ->where('added_by', $user->id)->where('is_archived', 0);

        if ($search !== '') {
            $query->where(function ($q) use ($search) {
                $q->where('name', 'like', "%{$search}%")
                  ->orWhere('delivery_address', 'like', "%{$search}%")
                  ->orWhere('site_contact_name', 'like', "%{$search}%");
            });
        }

        // Sort by project fields
        if (!in_array($sort, ['name', 'created_at', 'updated_at'], true)) {
            $sort = 'created_at';
        }

        $paginator = $query->orderBy($sort, $dir)->paginate($perPage);

        // Attach per-project order stats with filters applied
        $userId = $user->id;

        $paginator->getCollection()->transform(function (Project $project) use ($userId, $order_status, $ddFrom, $ddTo) {
            $ordersQuery = $project->orders()
                ->where('client_id', $userId);

            if ($order_status) {
                $ordersQuery->where('order_status', $order_status);
            }
            if ($ddFrom) {
                $ordersQuery->whereDate('delivery_date', '>=', $ddFrom);
            }
            if ($ddTo) {
                $ordersQuery->whereDate('delivery_date', '<=', $ddTo);
            }

            $project->total_orders       = (int) $ordersQuery->count();
            $project->total_order_amount = (float) $ordersQuery->sum('total_price');

            return $project;
        });

        return response()->json([
            'data' => $paginator->items(),
            'meta' => [
                'current_page' => $paginator->currentPage(),
                'per_page'     => $paginator->perPage(),
                'total'        => $paginator->total(),
                'last_page'    => $paginator->lastPage(),
            ],
        ]);
    }

    /**
     * GET /client/projects/{id}
     *
     * View a single project with:
     * - project details
     * - all orders within the project (with filters)
     * - items (products) with consistent pricing per project
     * - analytics
     *
     * NOTE for item pricing:
     *   - if item has `is_quoted == 1`, use `quoted_price` as the price
     *   - otherwise, use `supplier_unit_cost` as the price
     */
    public function projectDetails($id, Request $request)
    {
        $user = Auth::user();
        abort_unless($user && $user->role === 'client', 403, 'Forbidden');

        /** @var Project|null $project */
        $project = Project::where('id', $id)
            ->where('added_by', $user->id)
            ->first();

        if (!$project) {
            return response()->json(['error' => 'Project not found'], 404);
        }

        // filters for orders inside this project
        $order_status = $request->get('order_status');                // ex: "Supplier Missing"
        $ddFrom   = $request->get('delivery_date_from');      // Y-m-d
        $ddTo     = $request->get('delivery_date_to');        // Y-m-d

        $ordersQuery = $project->orders()
            ->where('client_id', $user->id)
            ->with([
                // FIX: include id + all required product columns
                'items.product:id,product_name,photo,product_type,specifications',
                'items.supplier:id,name',
            ])
            ->orderBy('delivery_date', 'desc')
            ->orderBy('created_at', 'desc');

        if ($order_status) {
            $ordersQuery->where('order_status', $order_status);
        }
        if ($ddFrom) {
            $ordersQuery->whereDate('delivery_date', '>=', $ddFrom);
        }
        if ($ddTo) {
            $ordersQuery->whereDate('delivery_date', '<=', $ddTo);
        }

        /** @var \Illuminate\Support\Collection|\App\Models\Orders[] $orders */
        $orders = $ordersQuery->get();

        // ---- Analytics ----
        $totalOrders = $orders->count();
        $totalAmount = (float) $orders->sum('total_price');

        $byOrderStatus = $orders
            ->groupBy('order_status')
            ->map(fn($group) => $group->count())
            ->toArray();

        $firstOrderDate = optional($orders->min('delivery_date'))->toDateString() ?? null;
        $lastOrderDate  = optional($orders->max('delivery_date'))->toDateString() ?? null;

        $analytics = [
            'total_orders'       => $totalOrders,
            'total_order_amount' => $totalAmount,
            'avg_order_value'    => $totalOrders > 0 ? round($totalAmount / $totalOrders, 2) : 0.0,
            'by_order_status'    => $byOrderStatus,
            'first_order_date'   => $firstOrderDate,
            'last_order_date'    => $lastOrderDate,
        ];

        // ---- Project products with consistent pricing ----
        $allItems = $orders->flatMap(function (Orders $order) {
            return $order->items;
        });

        $projectProducts = $allItems
        ->groupBy('product_id')
        ->map(function ($rows) {
            /** @var \App\Models\OrderItem $first */
            $first = $rows->first();
            $last = $rows->last(); // Get the most recent item for reordering

            // Core rule:
            // if item has quoted price => use quoted_price
            // else => use supplier_unit_cost
            if (!is_null($first->quoted_price) && (int) $first->is_quoted === 1) {
                $unitPrice = (float) $first->quoted_price;
            } else {
                $unitPrice = (float) $first->supplier_unit_cost;
            }

            $deliveryCost = (float) $first->supplier_delivery_cost;

            return [
                'product_id'              => $first->product_id,
                'product_name'            => optional($first->product)->product_name,
                'product_image'           => optional($first->product)->photo,
                'product_type'            => optional($first->product)->product_type,
                'product_specifications'  => optional($first->product)->specifications,
                'unit_price'              => $unitPrice * (1+0.50),
                'delivery_cost'           => $deliveryCost,
                'total_quantity'          => (float) $rows->sum('quantity'),
                'orders_count'            => (int) $rows->pluck('order_id')->unique()->count(),
                'first_order_id'          => $rows->min('order_id'),
                'last_order_id'           => $rows->max('order_id'),
                'last_order_item_id'      => $last->id, // NEW - For reordering with same pricing
            ];
        })
        ->values();

        // ---- Shape orders payload for frontend ----
        $ordersPayload = $orders->map(function (Orders $order) {
            return [
                'id'              => $order->id,
                'po_number'       => $order->po_number,
                'delivery_date'   => $order->delivery_date,
                'delivery_time'   => $order->delivery_time,
                'delivery_method' => $order->delivery_method,
                'order_status'    => $order->order_status,
                'payment_status'  => $order->payment_status,
                'total_price'     => (float) $order->total_price,
                'items'           => $order->items->map(function ($item) {
                    // Apply "quoted vs supplier_unit_cost" rule for display price
                    if (!is_null($item->quoted_price) && (int) $item->is_quoted === 1) {
                        $displayUnitPrice = (float) $item->quoted_price;
                    } else {
                        $displayUnitPrice = (float) $item->supplier_unit_cost;
                    }

                    return [
                        'id'                     => $item->id,
                        'product_id'             => $item->product_id,
                        'product_name'           => optional($item->product)->product_name,
                        'product_image'          => optional($item->product)->photo,
                        'product_type'           => optional($item->product)->product_type,
                        'product_specifications' => optional($item->product)->specifications,
                        'quantity'               => (float) $item->quantity,
                        'is_quoted'              => (int) $item->is_quoted,
                        'quoted_price'           => $item->quoted_price,
                        'supplier_unit_cost'     => $item->supplier_unit_cost,
                        'supplier_delivery_cost' => $item->supplier_delivery_cost,
                        'display_unit_price'     => $displayUnitPrice,
                        'supplier_name'          => optional($item->supplier)->name,
                        'custom_blend_mix'       => $item->custom_blend_mix,
                    ];
                }),
            ];
        });

        return response()->json([
            'project'          => $project,
            'analytics'        => $analytics,
            'orders'           => $ordersPayload,
            'project_products' => $projectProducts,
        ]);
    }

    public function show($id)
    {
        
        $project = Project::find($id);
        if (!$project) {
            return response()->json(['error' => 'Project not found'], 404);
        }
    
        
        $user = Auth::user();
        abort_unless($user && $user->role === 'client', 403, 'Forbidden');

        // compare against the FK column
        abort_unless((int) $project->added_by === (int) $user->id, 404, 'Project not found');
        

        $project->load('added_by.company');
        // dd($project);
        return response()->json($project, 200);
    }


    public function store(Request $request)
    {
        $user = Auth::user();
        abort_unless($user && $user->role === 'client', 403, 'Forbidden');

        $validator = Validator::make($request->all(), [
            'name'               => ['required','string','max:255'],
            'site_contact_name'  => ['nullable','string','max:255'],
            'site_contact_phone' => ['nullable','string','max:50'],
            'site_instructions'  => ['nullable','string'],
            'delivery_address' => 'required|string',
            'delivery_lat'     => 'required|numeric',
            'delivery_long'    => 'required|numeric',
        ]);

        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 400);
        }

        $data = $validator->validated();

        $project = Project::create([
            ...$data,
            'added_by' => $user->id, // lock to this client
        ]);

        return response()->json($project->load('added_by.company'), 201);
    }

    public function update(Request $request, Project $project)
    {
        $user = Auth::user();
        abort_unless($user && $user->role === 'client', 403, 'Forbidden');
        abort_unless($project->added_by === $user->id, 404, 'Project not found');

        $validator = Validator::make($request->all(), [
            'name'               => ['sometimes','required','string','max:255'],
            'site_contact_name'  => ['nullable','string','max:255'],
            'site_contact_phone' => ['nullable','string','max:50'],
            'site_instructions'  => ['nullable','string'],
            'delivery_address' => 'required|string',
            'delivery_lat'     => 'required|numeric',
            'delivery_long'    => 'required|numeric',
        ]);

        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 400);
        }

        $data = $validator->validated();

        // do NOT change added_by
        $project->update($data);

        return response()->json($project->fresh()->load('added_by.company'), 200);
    }


    public function destroy(Project $project)
    {
        $user = Auth::user();
        if($user->id == $project->added_by){
            $project->is_archived = 1;
            $project->archived_by = $user->id;
            $project->save();
            return response()->json(['message' => 'Project deleted successfully'], 200);
        }else{
            return response()->json(['error' => 'Unauthorized'], 403);
        }
    }
}


------------------------------------------------------------
FILE: app/Http/Controllers/ProjectController2.php
------------------------------------------------------------
<?php

namespace App\Http\Controllers;

use App\Models\Projects as Project; // keep alias if your model is named Projects
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Validator; // added
use Illuminate\Validation\Rule;

class ProjectController extends Controller
{
    // GET /client/projects
    public function index(Request $request)
    {

        $projects= Project::where('added_by', Auth::id())->get();
        return response()->json(['data'=>$projects]);
        $user = Auth::user();
        abort_unless($user && $user->role === 'client', 403, 'Forbidden');

        $perPage = (int) $request->get('per_page', 10);
        $search  = trim((string) $request->get('search', ''));
        $sort    = $request->get('sort', 'created_at');
        $dir     = $request->get('dir', 'desc');

        $query = Project::with('added_by.company')
            ->where('added_by', $user->id);

        if ($search !== '') {
            $query->where('name', 'like', "%{$search}%");
        }

        $allowedSorts = ['name','created_at','updated_at'];
        if (!in_array($sort, $allowedSorts, true)) $sort = 'created_at';
        $dir = strtolower($dir) === 'asc' ? 'asc' : 'desc';

        return response()->json(
            $query->orderBy($sort, $dir)->paginate($perPage),
            200
        );
    }

    // GET /client/projects/{project}
    public function show($id)
    {
        
        $project = Project::find($id);
        if (!$project) {
            return response()->json(['error' => 'Project not found'], 404);
        }
    
        
        $user = Auth::user();
        abort_unless($user && $user->role === 'client', 403, 'Forbidden');

        // compare against the FK column
        abort_unless((int) $project->added_by === (int) $user->id, 404, 'Project not found');
        

        $project->load('added_by.company');
        // dd($project);
        return response()->json($project, 200);
    }

    // POST /client/projects
    public function store(Request $request)
    {
        $user = Auth::user();
        abort_unless($user && $user->role === 'client', 403, 'Forbidden');

        $validator = Validator::make($request->all(), [
            'name'               => ['required','string','max:255'],
            'site_contact_name'  => ['nullable','string','max:255'],
            'site_contact_phone' => ['nullable','string','max:50'],
            'site_instructions'  => ['nullable','string'],
            'delivery_address' => 'required|string',
            'delivery_lat'     => 'required|numeric',
            'delivery_long'    => 'required|numeric',
        ]);

        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 400);
        }

        $data = $validator->validated();

        $project = Project::create([
            ...$data,
            'added_by' => $user->id, // lock to this client
        ]);

        return response()->json($project->load('added_by.company'), 201);
    }

    // PUT /client/projects/{project}
    public function update(Request $request, Project $project)
    {
        $user = Auth::user();
        abort_unless($user && $user->role === 'client', 403, 'Forbidden');
        abort_unless($project->added_by === $user->id, 404, 'Project not found');

        $validator = Validator::make($request->all(), [
            'name'               => ['sometimes','required','string','max:255'],
            'site_contact_name'  => ['nullable','string','max:255'],
            'site_contact_phone' => ['nullable','string','max:50'],
            'site_instructions'  => ['nullable','string'],
            'delivery_address' => 'required|string',
            'delivery_lat'     => 'required|numeric',
            'delivery_long'    => 'required|numeric',
        ]);

        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 400);
        }

        $data = $validator->validated();

        // do NOT change added_by
        $project->update($data);

        return response()->json($project->fresh()->load('added_by.company'), 200);
    }

    // DELETE /client/projects/{project}
    public function destroy($id)
    {
        $project = Project::find($id);
        if (!$project) {
            return response()->json(['error' => 'Project not found'], 404);
        }
        
        $user = Auth::user();
        abort_unless($user && $user->role === 'client', 403, 'Forbidden');
        abort_unless($project->added_by === $user->id, 404, 'Project not found');

        $project->delete();
        return response()->json(['message' => 'Project deleted'], 200);
    }
}


------------------------------------------------------------
FILE: app/Http/Controllers/SupplierController.php
------------------------------------------------------------
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\Models\SupplierOffers;
use App\Models\MasterProducts;
use App\Models\User;
use Illuminate\Support\Facades\Validator;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Str;

class SupplierController extends Controller
{   

    /**
     * Add a product to the supplier's inventory.
     */

    public function deliveryZonesManagement(Request $request)
    {
        // Logic for managing delivery zones
        $validator = Validator::make($request->all(), [
            'zones' => 'sometimes|array',
            'zones.*.lat' => 'sometimes|numeric',
            'zones.*.long' => 'sometimes|numeric',
            'zones.*.radius' => 'sometimes|numeric',
            'zones.*.address' => 'sometimes|string|max:255',
        ]);
        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 400);
        }
        /** @var User $user */
        $user = Auth::user();
        abort_unless($user && $user->role === 'supplier', 403, 'Forbidden');
        if( !$request->zones || $request->zones === null || $request->zones === '' || count($request->zones) === 0){
            $user->delivery_zones = null;
            $user->save();
            return response()->json(['message' => 'Delivery zones cleared', 'delivery_zones' => []], 200);
        }
        $user->delivery_zones = json_encode($request->zones);
        $user->save();
        return response()->json(['message' => 'Delivery zones updated successfully', 'delivery_zones' => $user->delivery_zones], 200);
    }

    public function getDeliveryZones()
    {
        // Get the authenticated user
        $user = Auth::user();

        // Ensure the user exists and is a supplier
        abort_unless($user && $user->role === 'supplier', 403, 'Forbidden');

        // Check if delivery_zones is not set, null, or empty
        if (!$user->delivery_zones || $user->delivery_zones === null || $user->delivery_zones === '') {
            return response()->json(['delivery_zones' => []], 200);
        }

        // Decode the delivery_zones if it is a JSON string
        $decodedZones = json_decode($user->delivery_zones, true);

        // If json_decode fails and the result is null, handle that case
        if (json_last_error() !== JSON_ERROR_NONE) {
            return response()->json(['error' => 'Invalid JSON format in delivery_zones'], 400);
        }

        // Return the decoded delivery_zones
        return response()->json(['delivery_zones' => $decodedZones], 200);
    }


    /**
     * Get Master Product Inventory.
     */
    public function getMasterProductInventory(Request $request)
    {
        $perPage = (int) $request->get('per_page', 10);
        $page = (int) $request->get('page', 1); 
        $query = MasterProducts::with(['added_by', 'approved_by', 'category'])
            ->where('is_approved', true); // Only approved products

        //Apply Category filter
        if ($request->filled('category_id')) {
            $query->where('category', $request->get('category_id'));
        }
        // Apply search filter
        if ($request->filled('search')) {
            $search = $request->get('search');
            $query->where('product_name', 'like', "%{$search}%");
        }
        // Paginate after filters
        $products = $query->paginate($perPage, ['*'], 'page', $page);
        // dd($products->toArray());
        // Append supplier offers count
        $products->getCollection()->transform(function ($product) {
            $product->supplierOffersCount = SupplierOffers::where('master_product_id', $product->id)->count();
            $product->suppliers = SupplierOffers::with('supplier')->where('master_product_id', $product->id)->get();
            $product->suppliers->transform(function ($supplier) {
                $supplier->isMe = Auth::id() == $supplier->supplier_id;
                return $supplier;
            });
            return $product;
        });
        return response()->json($products, 200);
    }

    /**
     * Add a product to the supplier's inventory.
     */
    public function addProductToInventory(Request $request)
    {
        $validator = Validator::make($request->all(), [
            'master_product_id' => 'required|exists:master_products,id',
            'price' => 'required|numeric',
            'availability_status' => 'required|in:In Stock,Out of Stock,Limited',
        ]);

        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 400);
        }

        // Create supplier offer for the product
        $supplierOffer = SupplierOffers::updateOrCreate([
            'supplier_id' => Auth::id(), // Authenticated supplier
            'master_product_id' => $request->master_product_id,
            'price' => $request->price,
            'availability_status' => $request->availability_status,
            'status' => 'Pending', // Default status, awaiting approval if needed
        ]);

        return response()->json(['message' => 'Product added to inventory successfully', 'supplier_offer' => $supplierOffer], 201);
    }

    /**
     * Request a new product to be added to the master catalog.
     */
    public function requestNewProduct(Request $request)
    {
        $validator = Validator::make($request->all(), [
            'product_name' => 'required|string|max:255',
            'product_type' => 'required|string|max:255',
            'category_id' => 'nullable|exists:category,id', // Optional category
            'specifications' => 'nullable|string',
            'unit_of_measure' => 'nullable|string|max:100',
            'price' => 'required|numeric',
            'availability_status' => 'required|in:In Stock,Out of Stock,Limited',
        ]);
        
        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 400);
        }
      

        // Create a new product request (admin will approve or reject)
        $newProduct = MasterProducts::create([
            'product_name' => $request->product_name,
            'product_type' => $request->product_type,
            'category' => $request->category_id,
            'specifications' => $request->specifications,
            'unit_of_measure' => $request->unit_of_measure,
            'slug' => Str::slug($request->product_name) . '-' . Str::random(6),
            'is_approved' => false, // Pending approval by admin
            'added_by' => Auth::id(), // Supplier is adding the product
        ]);
        $supplierOffer = SupplierOffers::updateOrCreate([
            'supplier_id' => Auth::id(), // Authenticated supplier
            'master_product_id' => $newProduct->id,
            'price' => $request->price,
            'availability_status' => $request->availability_status,
            'status' => 'Pending', // Default status, awaiting approval if needed
        ]);

        return response()->json(['message' => 'Product request submitted successfully', 'new_product' => $newProduct], 201);
    }

    /**
     * View the supplier's products list.
     */
    public function getSupplierProducts(Request $request)
    {
        // Fetch supplier's products from SupplierOffers
        $supplierOffers = SupplierOffers::with(['masterProduct', 'masterProduct.category','supplier'])
            ->where('supplier_id', Auth::id())
            ->paginate(10); // Pagination if needed

        return response()->json($supplierOffers);
    }

    /**
     * Edit product pricing in the supplier's inventory.
     */
    public function updateProductPricing(Request $request, $offerId)
    {
        $validator = Validator::make($request->all(), [
            'price' => 'required|numeric',
            'availability_status' => 'required|in:In Stock,Out of Stock,Limited',
        ]);

        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 400);
        }

        // Find the existing supplier offer
        $supplierOffer = SupplierOffers::find($offerId);

        if (!$supplierOffer || $supplierOffer->supplier_id != Auth::id()) {
            return response()->json(['error' => 'Offer not found or you are not authorized to edit this offer'], 404);
        }

        // Update the product pricing and availability
        $supplierOffer->update([
            'price' => $request->price,
            'availability_status' => $request->availability_status,
        ]);

        return response()->json(['message' => 'Product pricing updated successfully', 'supplier_offer' => $supplierOffer], 200);
    }

    /**
     * Delete product from the supplier's inventory.
     */
    public function deleteProductFromInventory($offerId)
    {
        // Find the existing supplier offer
        $supplierOffer = SupplierOffers::find($offerId);
        if (!$supplierOffer || $supplierOffer->supplier_id != Auth::id()) {
            return response()->json(['error' => 'Offer not found or you are not authorized to delete this offer'], 404);
        }
        $supplierOffer->delete();
        return response()->json(['message' => 'Product removed from inventory successfully'], 200);
    }

    /**
     * Get Status of Supplier Offers.
     */
    public function getSupplierOfferStatus()
    {
        $offers = SupplierOffers::where('supplier_id', Auth::id())->get();
        return response()->json($offers, 200);
    }

}


------------------------------------------------------------
FILE: app/Http/Controllers/SupplierOrderController.php
------------------------------------------------------------
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\Models\Orders;
use App\Models\OrderItem;
use App\Models\MasterProducts;
use App\Models\SupplierOffers;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Validator;

class SupplierOrderController extends Controller
{
    // Helper function | Workflow 
    private function workflow(Orders $order)
    {
        $currentWorkflow = $order->workflow;

        switch ($currentWorkflow) {
            case 'Supplier Assigned':
                $allConfirmed = $order->items()->where('supplier_confirms', false)->count() === 0;
                if (!$allConfirmed) {
                    break;
                }

                // Constants
                $ADMIN_MARGIN    = 0.50;
                $DELIVERY_MARGIN = 0.10;
                $FLEET_MARGIN    = 0.15;
                $GST_RATE        = 0.10;

                // Accumulators
                $customer_item_cost     = 0.0;
                $customer_delivery_cost = 0.0;
                $supplier_item_cost     = 0.0;
                $supplier_delivery_cost = 0.0;

                foreach ($order->items as $item) {
                    // Supplier material cost
                    $base_material_cost = ($item->supplier_unit_cost * $item->quantity) - $item->supplier_discount;
                    if ($base_material_cost < 0) { $base_material_cost = 0; }
                    $supplier_item_cost += $base_material_cost;

                    // Customer item cost with admin margin or quoted override
                    if ((int)$item->is_quoted === 1 && $item->quoted_price !== null) {
                        $customer_item_cost += (float)$item->quoted_price;
                    } else {
                        $customer_item_cost += $base_material_cost * (1 + $ADMIN_MARGIN);
                    }

                    // Delivery handling
                    $dtype = (string)$item->delivery_type;
                    if ($dtype === 'Supplier' || $dtype === 'ThirdParty') {
                        $customer_delivery_cost += $item->delivery_cost * (1 + $DELIVERY_MARGIN);
                        $supplier_delivery_cost += $item->delivery_cost;
                    } elseif ($dtype === 'Fleet') {
                        $customer_delivery_cost += $item->delivery_cost * (1 + $FLEET_MARGIN);
                        $supplier_delivery_cost += $item->delivery_cost;
                    } elseif ($dtype === 'Included' || $dtype === 'None' || $dtype === '' || $dtype === null) {
                        // No delivery cost
                    } else {
                        // Unknown type: supplier bears base delivery
                        $supplier_delivery_cost += (float)$item->delivery_cost;
                    }
                }

                // GST on customer-facing costs
                $gst_tax = ($customer_item_cost + $customer_delivery_cost) * $GST_RATE;

                // Totals
                $discount      = (float)($order->discount ?? 0);
                $other_charges = (float)($order->other_charges ?? 0);

                $total_price = $customer_item_cost
                            + $customer_delivery_cost
                            + $gst_tax
                            - $discount
                            + $other_charges;

                // Profit metrics
                $supplier_total    = $supplier_item_cost + $supplier_delivery_cost;
                $profit_before_tax = $total_price - $supplier_total - $gst_tax;
                $profit_margin_percent = $supplier_total > 0 ? ($profit_before_tax / $supplier_total) : 0.0;

                // Save to order
                $order->customer_item_cost     = round($customer_item_cost, 2);
                $order->customer_delivery_cost = round($customer_delivery_cost, 2);
                $order->supplier_item_cost     = round($supplier_item_cost, 2);
                $order->supplier_delivery_cost = round($supplier_delivery_cost, 2);
                $order->gst_tax                = round($gst_tax, 2);
                $order->total_price            = round($total_price, 2);

                // Actual profit amount (not percentage)
                $order->profit_amount          = round($profit_before_tax, 2);
                $order->profit_margin_percent  = round($profit_margin_percent,2);

                $order->workflow = 'Payment Requested';
                // dd($customer_item_cost, $customer_delivery_cost, $supplier_item_cost, $supplier_delivery_cost, $profit_margin_percent, $profit_before_tax);
                $order->save();

                break;
        }
    }


    // public function getSupplierOrders(Request $request)
    // {
    //     $user = Auth::user();

    //     // Pagination and filtering parameters
    //     $perPage = (int) $request->get('per_page', 10);
    //     $search = trim((string) $request->get('search', ''));
    //     $confirmed = $request->get('supplier_confirms');
    //     $deliveryDate = $request->get('supplier_delivery_date');
    //     $productId = $request->get('product_id');
    //     $details = $request->boolean('details', false);

    //     // Base query for supplier's order items - reusable for all metrics
    //     $baseQuery = function () use ($user, $search, $confirmed, $deliveryDate, $productId) {
    //         $query = OrderItem::where('supplier_id', $user->id);

    //         // Apply search filter (by product name)
    //         if (!empty($search)) {
    //             $query->whereHas('product', function ($q) use ($search) {
    //                 $q->where('product_name', 'like', '%' . $search . '%');
    //             });
    //         }

    //         // Apply confirmed filter
    //         if ($confirmed !== null) {
    //             $query->where('supplier_confirms', filter_var($confirmed, FILTER_VALIDATE_BOOLEAN));
    //         }

    //         // Apply delivery date filter
    //         if (!empty($deliveryDate)) {
    //             $query->whereDate('supplier_delivery_date', $deliveryDate);
    //         }

    //         // Apply product ID filter
    //         if (!empty($productId)) {
    //             $query->where('product_id', $productId);
    //         }

    //         return $query;
    //     };

    //     // Get metrics with applied filters
    //     $totalOrdersCount = $baseQuery()->count();
    //     $supplierConfirmedCount = $baseQuery()->where('supplier_confirms', true)->count();
    //     $awaitingPaymentCount = $baseQuery()->where('is_paid', false)->count();
    //     $deliveredCount = $baseQuery()->whereHas('order', function ($query) {
    //         $query->where('workflow', 'Delivered');
    //     })->count();

    //     // Get paginated results using the same base query
    //     $orderItemsQuery = $baseQuery()->with(['order', 'product', 'chosenOffer']);
    //     $orderItems = $orderItemsQuery->orderBy('created_at', 'desc')->paginate($perPage);

    //     // Prepare response data
    //     $data = [
    //         'data' => $orderItems->items(),
    //         'pagination' => [
    //             'current_page' => $orderItems->currentPage(),
    //             'per_page' => $orderItems->perPage(),
    //             'total' => $orderItems->total(),
    //             'last_page' => $orderItems->lastPage(),
    //         ],
    //         'metrics' => [
    //             'total_orders_count' => $totalOrdersCount,
    //             'supplier_confirmed_count' => $supplierConfirmedCount,
    //             'awaiting_payment_count' => $awaitingPaymentCount,
    //             'delivered_count' => $deliveredCount,
    //         ]
    //     ];

    //     // Add filters data if details=true
    //     if ($details) {
    //         // Get products that this supplier offers
    //         $supplierProducts = MasterProducts::whereHas('supplierOffers', function ($query) use ($user) {
    //             $query->where('supplier_id', $user->id);
    //         })
    //         ->select('id', 'product_name', 'photo')
    //         ->get()
    //         ->map(function ($product) {
    //             return [
    //                 'id' => $product->id,
    //                 'product_name' => $product->product_name,
    //                 'photo' => $product->photo,
    //             ];
    //         });

    //         $data['filters'] = [
    //             'products' => $supplierProducts
    //         ];
    //     }

    //     return response()->json([
    //         'success' => true,
    //         'data' => $data
    //     ]);
    // }
    public function getSupplierOrders(Request $request)
    {
        $user = Auth::user();

        // Pagination and filtering parameters
        $perPage = (int) $request->get('per_page', 10);
        $search = trim((string) $request->get('search', ''));
        $confirmed = $request->get('supplier_confirms');
        $deliveryDate = $request->get('supplier_delivery_date');
        $productId = $request->get('product_id');
        $details = $request->boolean('details', false);
        // dd($user);
        // Base query for orders that have items assigned to this supplier
        $baseQuery = function () use ($user, $search, $confirmed, $deliveryDate, $productId) {
            $query = Orders::whereHas('items', function ($q) use ($user, $search, $confirmed, $deliveryDate, $productId) {
                $q->where('supplier_id', $user->id);

                // Apply search filter (by product name)
                if (!empty($search)) {
                    $q->whereHas('product', function ($productQuery) use ($search) {
                        $productQuery->where('product_name', 'like', '%' . $search . '%');
                    });
                }

                // Apply confirmed filter
                if ($confirmed !== null) {
                    $q->where('supplier_confirms', filter_var($confirmed, FILTER_VALIDATE_BOOLEAN));
                }

                // Apply delivery date filter
                if (!empty($deliveryDate)) {
                    $q->whereDate('supplier_delivery_date', $deliveryDate);
                }

                // Apply product ID filter
                if (!empty($productId)) {
                    $q->where('product_id', $productId);
                }
            });

            return $query;
        };

        // Get metrics with applied filters
        $totalOrdersCount = $baseQuery()->count();
        
        $supplierConfirmedCount = Orders::whereHas('items', function ($q) use ($user, $search, $confirmed, $deliveryDate, $productId) {
            $q->where('supplier_id', $user->id)
            ->where('supplier_confirms', true);

            // Apply the same filters for consistency
            if (!empty($search)) {
                $q->whereHas('product', function ($productQuery) use ($search) {
                    $productQuery->where('product_name', 'like', '%' . $search . '%');
                });
            }
            if (!empty($deliveryDate)) {
                $q->whereDate('supplier_delivery_date', $deliveryDate);
            }
            if (!empty($productId)) {
                $q->where('product_id', $productId);
            }
        })->count();
        
        // $awaitingPaymentCount = Orders::whereHas('items', function ($q) use ($user, $search, $confirmed, $deliveryDate, $productId) {
        //     $q->where('supplier_id', $user->id)
        //     ->where('is_paid', false);
        $awaitingPaymentCount = Orders::where(function ($orderQuery) use ($user) {
        $orderQuery->whereNull('supplier_paid_ids')
                ->orWhereJsonDoesntContain('supplier_paid_ids', $user->id); // User ID not in paid list
        })
        ->whereHas('items', function ($q) use ($user, $search, $confirmed, $deliveryDate, $productId) {
            $q->where('supplier_id', $user->id);

            // Optional filters
            if (!empty($search)) {
                $q->whereHas('product', function ($productQuery) use ($search) {
                    $productQuery->where('product_name', 'like', '%' . $search . '%');
                });
            }

            if (!empty($deliveryDate)) {
                $q->whereDate('supplier_delivery_date', $deliveryDate);
            }

            if (!empty($productId)) {
                $q->where('product_id', $productId);
            }
        })->count();


        
        $deliveredCount = $baseQuery()->where('workflow', 'Delivered')->count();

        // Get paginated results with supplier's items count and relationship
        $ordersQuery = $baseQuery()->with(['items' => function ($query) use ($user) {
            $query->where('supplier_id', $user->id)
                ->with(['product', 'chosenOffer']);
        }]);

        $orders = $ordersQuery->orderBy('created_at', 'desc')->paginate($perPage);

        // Transform the response to include items count for this supplier
        $transformedOrders = $orders->getCollection()->map(function ($order) use ($user) {
            $supplierItems = $order->items->where('supplier_id', $user->id);
            $totalAmount = 0;
            foreach ($supplierItems as $item) {
                $itemCost = ($item->supplier_unit_cost * $item->quantity) - $item->supplier_discount + $item->supplier_delivery_cost;
                $totalAmount += $itemCost;
            }

            return [
                'id' => $order->id,
                'po_number' => $order->po_number,          // was 'order_number'
                'order_status' => $order->order_status,    // show status to suppliers
                // 'workflow' => $order->workflow,         // remove from supplier view
                'total_amount' => $totalAmount,
                'created_at' => $order->created_at,
                'updated_at' => $order->updated_at,
                'supplier_items_count' => $supplierItems->count(),
                'supplier_items' => $supplierItems->map(function ($item) {
                    return [
                        'id' => $item->id,
                        'product_id' => $item->product_id,
                        'quantity' => $item->quantity,
                        'supplier_unit_cost' => $item->supplier_unit_cost,
                        // 'supplier_delivery_cost' => $item->supplier_delivery_cost,
                        'delivery_cost' => $item->delivery_cost ?? null,  // keep if present in model
                        'delivery_type' => $item->delivery_type ?? null,  // keep if present in model
                        'supplier_discount' => $item->supplier_discount,
                        'supplier_delivery_date' => $item->supplier_delivery_date,
                        'supplier_confirms' => $item->supplier_confirms,
                        'supplier_notes' => $item->supplier_notes ?? null,
                        'product' => $item->product,
                        'chosen_offer' => $item->chosenOffer,
                    ];
                }),
            ];
        });

        // Prepare response data
        $data = [
            'data' => $transformedOrders,
            'pagination' => [
                'current_page' => $orders->currentPage(),
                'per_page' => $orders->perPage(),
                'total' => $orders->total(),
                'last_page' => $orders->lastPage(),
            ],
            'metrics' => [
                'total_orders_count' => $totalOrdersCount,
                'supplier_confirmed_count' => $supplierConfirmedCount,
                'awaiting_payment_count' => $awaitingPaymentCount,
                'delivered_count' => $deliveredCount,
            ]
        ];

        // Add filters data if details=true
        if ($details) {
            // Get products that this supplier offers
            $supplierProducts = MasterProducts::whereHas('supplierOffers', function ($query) use ($user) {
                $query->where('supplier_id', $user->id);
            })
            ->select('id', 'product_name', 'photo')
            ->get()
            ->map(function ($product) {
                return [
                    'id' => $product->id,
                    'product_name' => $product->product_name,
                    'photo' => $product->photo,
                ];
            });

            $data['filters'] = [
                'products' => $supplierProducts
            ];
        }

        return response()->json([
            'success' => true,
            'data' => $data
        ]);
    }

    public function updateOrderPricing(Request $request, OrderItem $orderItem)
    {
        $v = Validator::make($request->all(), [
            'supplier_unit_cost' => 'sometimes|required|numeric|min:0',
            'supplier_discount' => 'sometimes|required|numeric|min:0',
            'supplier_delivery_date' => 'sometimes|required|date',
            'supplier_confirms' => 'sometimes|required|boolean',
            'delivery_cost' => 'sometimes|required|numeric|min:0',
            'delivery_type'=> 'required|in:Included,Supplier,ThirdParty,Fleet,None ',
            'supplier_notes' => 'sometimes|nullable|string|max:500'
        ]);

        if ($v->fails()) {
            return response()->json(['error' => $v->errors()], 422);
        }

        // Check if the authenticated user is the supplier for this order item
        $user = Auth::user();

        if(!in_array($orderItem->order->workflow, ['Supplier Assigned', 'Requested'])) {  //, 'Payment Requested', 'On Hold', 'Delivered'
            return response()->json([
                'message' => 'Cannot update order item now as the order is in '.$orderItem->order->workflow.' status'
            ], 403);
        }   
        if ($orderItem->supplier_id !== $user->id) {
            return response()->json([
                'message' => 'You are not authorized to update this order item'
            ], 403);
        }

        // Check if order item is already confirmed
        if ($orderItem->supplier_confirms && $request->has('supplier_confirms') && !$request->supplier_confirms) {
            return response()->json([
                'message' => 'Cannot unconfirm an already confirmed order item'
            ], 422);
        }

        try {
            DB::beginTransaction();

            // Update the order item with provided fields
            $updateData = [];
            
            if ($request->has('supplier_unit_cost')) {
                $updateData['supplier_unit_cost'] = $request->supplier_unit_cost;
            }
            
            if ($request->has('delivery_cost')) {
                $updateData['delivery_cost'] = $request->delivery_cost;
            }
            
            if ($request->has('supplier_discount')) {
                $updateData['supplier_discount'] = $request->supplier_discount;
            }

            if ($request->has('delivery_type')) {
                $updateData['delivery_type'] = $request->delivery_type;
            }
            
            if ($request->has('supplier_delivery_date')) {
                $updateData['supplier_delivery_date'] = $request->supplier_delivery_date;
            }
            
            if ($request->has('supplier_confirms')) {
                $updateData['supplier_confirms'] = $request->supplier_confirms;
            }
            
            if ($request->has('supplier_notes')) {
                $updateData['supplier_notes'] = $request->supplier_notes;
            }

            // Update the order item
            $orderItem->update($updateData);

            // If supplier confirmed the order, trigger workflow check
            if ($request->has('supplier_confirms') && $request->supplier_confirms) {
                $this->workflow($orderItem->order);
            }

            DB::commit();

            // Reload the order item with relationships
            $orderItem->load(['order', 'product', 'chosenOffer']);

            return response()->json([
                'success' => true,
                'message' => 'Order item updated successfully',
                'data' => $orderItem
            ]);

        } catch (\Exception $e) {
            DB::rollBack();
            return response()->json([
                'error' => 'Failed to update order item: ' . $e->getMessage()
            ], 500);
        }
    }

    public function viewOrderDetails(Orders $order)
    {
        $user = Auth::user();

        // Ensure the supplier has items in this order
        $supplierItems = $order->items()->where('supplier_id', $user->id)->with(['product', 'chosenOffer'])->get();

        if ($supplierItems->isEmpty()) {
            return response()->json([
                'error' => 'You do not have any items in this order'
            ], 403);
        }

        // Reload the order with only selected fields and relationships
        $order = Orders::where('id', $order->id)
            ->select([
                'id',
                'po_number', // Make sure this field exists in your table
                'project_id',
                'client_id',
                'workflow',
                'delivery_address',
                'delivery_date',
                'delivery_time',
                'delivery_window',
                'delivery_method',
                'load_size',
                'special_equipment',
                'special_notes',
                'created_at',
                'updated_at'
            ])
            ->with(['client:id,name,email', 'project:id,name,site_contact_name,site_contact_phone,site_instructions'])
            ->first();

        return response()->json([
            'success' => true,
            'data' => [
                'order' => $order,
                'supplier_items' => $supplierItems
            ]
        ]);
    }



    
}


------------------------------------------------------------
FILE: app/Http/Controllers/UserManagement.php
------------------------------------------------------------
<?php
namespace App\Http\Controllers;

use App\Models\User;
use App\Models\Company;
use App\Models\Category;
use Illuminate\Http\Request;
use Illuminate\Support\Str;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Facades\Validator;
use Illuminate\Support\Facades\Storage;

class UserManagement extends Controller
{
    // List Users with Multiple Filters and Pagination
    public function index(Request $request)
    {
        $query = User::query();

        // Filters
        if ($request->has('role') && in_array($request->role, ['admin', 'client', 'supplier','accountant','support'])) {
          
            $query->where('role', $request->role);
        }

        if ($request->has('isDeleted')) {
            // Ensure the value is treated as a boolean (either true or false)
            $isDeleted = filter_var($request->isDeleted, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE);

            // If valid, apply the filter
            if ($isDeleted !== null) {
                $query->where('isDeleted', $isDeleted);
            }
        }

        if ($request->has('company_id') && is_numeric($request->company_id)) {
            $query->where('company_id', $request->company_id);
        }

        if ($request->has('contact_name')) {
            $query->where(function ($q) use ($request) {
                $q->where('contact_name', 'like', '%' . $request->contact_name . '%')
                ->orWhere('name', 'like', '%' . $request->contact_name . '%')
                ->orWhere('email', 'like', '%' . $request->contact_name . '%');
            });
        }

        if ($request->has('location')) {
            $query->where('location', 'like', '%' . $request->location . '%');
        }

        if ($request->has('lat') && $request->has('long')) {
            $query->where('lat', $request->lat)->where('long', $request->long);
        }

        // Get the 'per_page' value from the request, default to 10 if not provided
        $perPage = $request->get('per_page', 10); // Default to 10 if no value is provided

        $query->with('company');

        // Pagination
        $users = $query->paginate($perPage);

        return response()->json($users);
    }

    
    // Add User
    public function store(Request $request)
    {
        // Manual validation handling (same as in registerSupplier)
        $validator = Validator::make($request->all(), [
            'name' => 'required|string|max:255',
            'email' => 'required|email|unique:users,email',
            'password' => 'required|string|min:6',
            'role' => 'required|string|in:admin,client,supplier,accountant,support',
            'company_name' => 'nullable|string|max:255', // Make sure the company name is optional
            'contact_name' => 'nullable|string|max:255',
            'contact_number' => 'nullable|string|max:255',
            'location' => 'nullable|string|max:255',
            'lat' => 'nullable|numeric',
            'long' => 'nullable|numeric',
            'delivery_radius' => 'nullable|numeric',
            'shipping_address' => 'nullable|string|max:255',
            'billing_address' => 'nullable|string|max:255',
            'client_public_id' => 'nullable|string|unique:users,client_public_id',
            'profile_image' => 'nullable|image|mimes:jpg,png,jpeg,gif',
            'notes' => 'nullable|string|max:1000',
        ]);

        // Check if validation fails
        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 400);
        }

        // Handle Company ID if it's for client or supplier
        $company_id = null;
        if ($request->role !== 'admin' && $request->has('company_name')) {
            // Look for the company by name, or create it if not found
            $company = Company::firstOrCreate([
                'name' => Str::lower($request->company_name),  // Company name is case-insensitive
            ]);

            // Assign the found or created company ID
            $company_id = $company->id;
        }

        // Handle Profile Image
        $imageUrl = null;
        if ($request->hasFile('profile_image') && $request->file('profile_image')->isValid()) {
            // Store the file under 'profile_images' directory in the 'public' disk
            $path = $request->file('profile_image')->store('profile_images', 'public');
            $imageUrl = 'storage/' . $path; // Relative path to the image
        }

        // Create the User
        $user = User::create([
            'name' => $request->name,
            'email' => $request->email,
            'password' => Hash::make($request->password),
            'role' => $request->role,
            'company_id' => $company_id,  // Assign company_id (can be null or an existing company ID)
            'contact_name' => $request->contact_name,
            'contact_number' => $request->contact_number,
            'location' => $request->location,
            'lat' => $request->lat,
            'long' => $request->long,
            'delivery_radius' => $request->delivery_radius,
            'shipping_address' => $request->shipping_address,
            'billing_address' => $request->billing_address,
            'client_public_id' => $request->client_public_id ?? 'MC-' . rand(100, 999),
            'profile_image' => $imageUrl,
            'isDeleted' => false,
            'notes' => $request->notes,
        ]);

        // Return the created user along with a success message and profile image URL
        return response()->json([
            'message' => 'User registered successfully.',
            'user' => $user,
            'role' => $user->role,
            'profile_image_url' => $imageUrl, // Return the image URL in response
        ], 201);
    }

    // Show User Details
    public function show($id)
    {
        $user = User::with('company')->find($id);
        if (!$user) {
            return response()->json(['error' => 'User not found'], 404);
        }
        return response()->json($user);
    }

    // Update User
    public function update(Request $request, $id)
    {
        // Find the user by ID
        $user = User::find($id);
        if (!$user) {
            return response()->json(['error' => 'User not found'], 404);
        }

        // Validate the request
        $validator = Validator::make($request->all(), [
            'name' => 'string|max:255',
            'email' => 'email|unique:users,email,' . $id,
            'password' => 'nullable|string|min:6',
            'role' => 'string|in:admin,client,supplier,accountant,support',
            'contact_name' => 'nullable|string|max:255',
            'contact_number' => 'nullable|string|max:255',
            'location' => 'nullable|string|max:255',
            'lat' => 'nullable|numeric',
            'long' => 'nullable|numeric',
            'delivery_radius' => 'nullable|numeric',
            'shipping_address' => 'nullable|string|max:255',
            'billing_address' => 'nullable|string|max:255',
            'profile_image' => 'nullable|image|mimes:jpg,png,jpeg,gif,webp',
            'notes' => 'nullable|string|max:1000',
        ]);

        // Check if validation fails
        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 400);
        }

        // Handle Profile Image
        $profileImagePath = $user->profile_image; // Existing profile image path

        if ($request->hasFile('profile_image')) {
            // Check if there's an old image and delete it before uploading the new one
            if ($profileImagePath) {
                $oldImagePath = str_replace('storage/', '', $profileImagePath); // Get the relative path
                $oldImagePath = 'storage/app/public/' . $oldImagePath;
                if (Storage::exists($oldImagePath)) {
                    Storage::delete($oldImagePath); // Delete the old image
                }
            }

            // Store the new profile image
            $profileImagePath = 'storage/'.$request->file('profile_image')->store('profile_images', 'public');
        }

        // Update the User with the new data
        $user->update([
            'name' => $request->name ?? $user->name,
            'email' => $request->email ?? $user->email,
            'password' => $request->password ? Hash::make($request->password) : $user->password,
            'role' => $request->role ?? $user->role,
            'contact_name' => $request->contact_name ?? $user->contact_name,
            'contact_number' => $request->contact_number ?? $user->contact_number,
            'location' => $request->location ?? $user->location,
            'lat' => $request->lat ?? $user->lat,
            'long' => $request->long ?? $user->long,
            'delivery_radius' => $request->delivery_radius ?? $user->delivery_radius,
            'shipping_address' => $request->shipping_address ?? $user->shipping_address,
            'billing_address' => $request->billing_address ?? $user->billing_address,
            'profile_image' => $profileImagePath ? $profileImagePath : $user->profile_image, // Store the relative path
            'notes' => $request->notes ?? $user->notes,
        ]);

        // Return the updated user information as a JSON response
        return response()->json($user->load('company'));
    }

    // Soft Delete User (Mark isDeleted as true)
    public function destroy($id)
    {
        $user = User::find($id);
        if (!$user) {
            return response()->json(['error' => 'User not found'], 404);
        }

        // Mark the user as deleted
        if($user->isDeleted){
            $user->update(['isDeleted' => false]);
            return response()->json(['message' => 'User restored successfully']);
        }
        $user->update(['isDeleted' => true]);

        return response()->json(['message' => 'User marked as deleted successfully']);
    }

    // Check if Company Exists
    public function checkCompany(Request $request)
    {
        $companyName = Str::lower($request->company_name);
        $company = Company::where('name', $companyName)->first();

        if ($company) {
            return response()->json(['exists' => true, 'company_id' => $company->id]);
        } else {
            return response()->json(['exists' => false]);
        }
    }


    public function addCategory(Request $request)
    {

        $validator = Validator::make($request->all(), [
            'name' => 'required|string|max:120|unique:category,name',
        ]);

        // Check if validation fails
        if ($validator->fails()) {
            return response()->json(['error' => $validator->errors()], 400);
        }

        $category = Category::create([
            'name' => $request->name,
        ]);
        return response()->json(['message' => 'Category added successfully', 'category' => $category], 201);
    }
    public function listCategories(Request $request)
    {
        // Default pagination parameters
        $perPage = $request->get('per_page', 10);  // Default 10 items per page
        $page = $request->get('page', 1);
        // Fetch categories with pagination
        $categories = Category::paginate($perPage);
        return response()->json($categories, 200);
    }

    public function deleteCategory($id)
    {
        $category = Category::find($id);
        if (!$category) {
            return response()->json(['error' => 'Category not found'], 404);
        }
        $category->delete();
        return response()->json(['message' => 'Category deleted successfully'], 200);
    }

    public function updateCategory(Request $request, $id)
    {
        $category = Category::find($id);
        if (!$category) {
            return response()->json(['error' => 'Category not found'], 404);
        }

        $data = $request->validate([
            'name' => 'required|string|max:120|unique:category,name,' . $id,
        ]);

        $category->update([
            'name' => $data['name'],
        ]);

        return response()->json(['message' => 'Category updated successfully', 'category' => $category], 200);
    }

    public function getCategory($id)
    {
      
        $category = Category::find($id);
        if (!$category) {
            return response()->json(['error' => 'Category not found'], 404);
        }
        return response()->json($category, 200);
    }

    public function getCompanies()
    {
        $companies = Company::all();
        return response()->json($companies);
    }

    // public function getSuppliersWithDeliveryZones(Request $request)
    // {
    //     $perPage = (int) $request->get('per_page', 10);
    //     $search = $request->get('search');

    //     $suppliers = User::where('role', 'supplier')
    //         ->whereNotNull('delivery_zones')
    //         ->where('delivery_zones', '!=', '[]')
    //         ->when($search, function ($query) use ($search) {
    //             return $query->where('name', 'like', '%' . $search . '%');
    //         })
    //         ->select('id', 'name', 'email', 'profile_image', 'delivery_zones')
    //         ->paginate($perPage);

    //     // Decode JSON for each supplier in paginated result
    //     // $suppliers->getCollection()->transform(function ($supplier) {
    //     //     $supplier->delivery_zones = json_decode($supplier->delivery_zones, true);
    //     //     return $supplier;
    //     // });

    //     return response()->json($suppliers);
    // }

    public function getSuppliersWithDeliveryZones(Request $request)
    {
        $perPage = (int) $request->get('per_page', 10);
        $search = $request->get('search');

        // Query to get the suppliers with delivery zones
        $suppliers = User::where('role', 'supplier')
            ->whereNotNull('delivery_zones')
            ->where('delivery_zones', '!=', '[]')
            ->when($search, function ($query) use ($search) {
                return $query->where('name', 'like', '%' . $search . '%');
            })
            ->select('id', 'name', 'email', 'profile_image', 'delivery_zones')
            ->paginate($perPage);

        // Decode delivery zones for each supplier in the paginated result
        $suppliers->getCollection()->transform(function ($supplier) {
            $supplier->delivery_zones = json_decode($supplier->delivery_zones, true);
            return $supplier;
        });

        // Return the paginated result as JSON
        return response()->json($suppliers);
    }


}


------------------------------------------------------------
FILE: app/Http/Controllers/XeroController.php
------------------------------------------------------------
<?php

namespace App\Http\Controllers;

use App\Services\XeroService;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Cache;

class XeroController extends Controller
{
    private XeroService $xeroService;

    public function __construct(XeroService $xeroService)
    {
        $this->xeroService = $xeroService;
    }

    /**
     * Step 1: Redirect to Xero for authorization
     * GET /api/xero/authorize (open in browser)
     */
    public function authorize()
    {
        $auth = $this->xeroService->getAuthorizationUrl();
        Cache::put('xero_oauth_state', $auth['state'], now()->addMinutes(10));
        return redirect($auth['url']);
    }

    /**
     * Step 2: Handle callback from Xero
     * GET /api/xero/callback
     */
    public function callback(Request $request)
    {
        $storedState = Cache::get('xero_oauth_state');

        if (!$storedState || $request->get('state') !== $storedState) {
            return response()->json(['error' => 'Invalid state'], 400);
        }

        Cache::forget('xero_oauth_state');

        if (!$request->has('code')) {
            return response()->json(['error' => 'No authorization code'], 400);
        }

        try {
            $token = $this->xeroService->handleCallback($request->get('code'));

            return response()->json([
                'message'     => ' Successfully connected to Xero!',
                'tenant_id'   => $token->tenant_id,
                'tenant_name' => $token->tenant_name,
                'expires_at'  => $token->expires_at->toDateTimeString(),
            ]);

        } catch (\Exception $e) {
            return response()->json(['error' => $e->getMessage()], 500);
        }
    }

    /**
     * Check connection status
     * GET /api/xero/status
     */
    public function status()
    {
        try {
            if (!$this->xeroService->isConnected()) {
                return response()->json([
                    'connected' => false,
                    'message'   => 'Not connected. Visit /api/xero/authorize in browser.',
                ]);
            }

            $token = $this->xeroService->getValidToken();

            return response()->json([
                'connected'   => true,
                'tenant_id'   => $token->tenant_id,
                'tenant_name' => $token->tenant_name,
                'expires_at'  => $token->expires_at->toDateTimeString(),
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'connected' => false,
                'error'     => $e->getMessage(),
            ]);
        }
    }

    /**
     * Create Invoice - USE THIS FROM POSTMAN
     * POST /api/xero/invoice
     * 
     * Body:
     * {
     *   "customer_name": "John Doe",
     *   "customer_email": "john@example.com",
     *   "items": [
     *     {
     *       "description": "Product A",
     *       "quantity": 2,
     *       "unit_price": 50.00
     *     }
     *   ],
     *   "reference": "Order #123",
     *   "due_date": "+30 days"
     * }
     */
    public function createInvoice(Request $request)
    {
        $request->validate([
            'customer_name'           => 'required|string',
            'customer_email'          => 'nullable|email',
            'items'                   => 'required|array|min:1',
            'items.*.description'     => 'required|string',
            'items.*.quantity'        => 'required|numeric|min:1',
            'items.*.unit_price'      => 'required|numeric|min:0',
            'reference'               => 'nullable|string',
            'due_date'                => 'nullable|string',
        ]);

        try {
            $result = $this->xeroService->createInvoice($request->all());

            return response()->json([
                'message' => ' Invoice created successfully!',
                'invoice' => $result,
            ], 201);

        } catch (\Exception $e) {
            return response()->json([
                'error'   => 'Failed to create invoice',
                'message' => $e->getMessage(),
            ], 500);
        }
    }
}

------------------------------------------------------------
FILE: app/Http/Controllers/XeroInvoiceController.php
------------------------------------------------------------
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use GuzzleHttp\Client;
use XeroAPI\XeroPHP\Api\AccountingApi;
use XeroAPI\XeroPHP\Api\IdentityApi;  // Changed from ConnectionsApi
use XeroAPI\XeroPHP\Configuration;
use XeroAPI\XeroPHP\Models\Accounting\Invoice;
use XeroAPI\XeroPHP\Models\Accounting\Invoices;  // Added - wrapper object
use XeroAPI\XeroPHP\Models\Accounting\LineItem;  // Changed from InvoiceLine
use XeroAPI\XeroPHP\Models\Accounting\Contact;

class XeroInvoiceController extends Controller
{
    // Step 1: Retrieve the Tenant ID
    public function getTenantId(Request $request)
    {
        $accessToken = $request->bearerToken();
        if (!$accessToken) {
            return response()->json(['error' => 'Access token missing or expired'], 400);
        }

        try {
            $config = Configuration::getDefaultConfiguration()->setAccessToken($accessToken);

            // Use IdentityApi instead of ConnectionsApi
            $identityApi = new IdentityApi(
                new Client(),
                $config
            );

            // Get tenant connections
            $tenantConnections = $identityApi->getConnections();

            if (isset($tenantConnections[0])) {
                $tenantId = $tenantConnections[0]->getTenantId();
                return response()->json(['tenantId' => $tenantId], 200);
            } else {
                return response()->json(['error' => 'No Xero organizations found for this account.'], 404);
            }
        } catch (\Exception $e) {
            return response()->json(['error' => $e->getMessage()], 500);
        }
    }

    // Step 2: Create an Invoice in Xero using Tenant ID
    public function createInvoice(Request $request)
    {
        $request->validate([
            'client_name' => 'required|string',
            'description' => 'required|string',
            'quantity' => 'required|integer|min:1',
            'unit_amount' => 'required|numeric|min:0',
        ]);

        $accessToken = $request->bearerToken();
        if (!$accessToken) {
            return response()->json(['error' => 'Access token missing or expired'], 400);
        }

        try {
            $config = Configuration::getDefaultConfiguration()->setAccessToken($accessToken);

            // Use IdentityApi instead of ConnectionsApi
            $identityApi = new IdentityApi(
                new Client(),
                $config
            );

            $tenantConnections = $identityApi->getConnections();

            if (isset($tenantConnections[0])) {
                $tenantId = $tenantConnections[0]->getTenantId();
            } else {
                return response()->json(['error' => 'No Xero organizations found for this account.'], 404);
            }

            // Set the contact (client) details
            $contact = new Contact();
            $contact->setName($request->input('client_name'));

            // Use LineItem instead of InvoiceLine
            $lineItem = new LineItem();
            $lineItem->setDescription($request->input('description', 'Sample Product'));
            $lineItem->setQuantity($request->input('quantity', 1));
            $lineItem->setUnitAmount($request->input('unit_amount', 100));
            $lineItem->setAccountCode('200');  // String, not integer

            $lineItems = [];
            array_push($lineItems, $lineItem);

            // Create the invoice
            $invoice = new Invoice();
            $invoice->setType(Invoice::TYPE_ACCREC);  // Use constant
            $invoice->setDueDate(new \DateTime('+30 days'));
            $invoice->setContact($contact);
            $invoice->setLineItems($lineItems);  // Pass as array
            $invoice->setStatus(Invoice::STATUS_DRAFT);  // Optional: set status

            // Wrap invoice in Invoices object
            $invoices = new Invoices();
            $invoices->setInvoices([$invoice]);

            // Create AccountingApi with GuzzleHttp\Client
            $accountingApi = new AccountingApi(
                new Client(),
                $config
            );

            // Use createInvoices (plural) with Invoices wrapper
            $result = $accountingApi->createInvoices($tenantId, $invoices);

            return response()->json([
                'message' => 'Invoice created successfully',
                'invoice' => $result->getInvoices()[0]
            ], 201);

        } catch (\XeroAPI\XeroPHP\ApiException $e) {
            return response()->json([
                'error' => $e->getMessage(),
                'response_body' => $e->getResponseBody()
            ], 500);
        } catch (\Exception $e) {
            return response()->json(['error' => $e->getMessage()], 500);
        }
    }
}

------------------------------------------------------------
FILE: app/Http/Middleware/AuthMiddleware.php
------------------------------------------------------------
<?php
// app/Http/Middleware/AuthMiddleware.php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Auth;

class AuthMiddleware
{
    public function handle(Request $request, Closure $next): Response
    {
        $path = $request->path();
        $isAuthenticated = Auth::check();
        
        Log::info('AuthMiddleware Debug', [
            'path' => $path,
            'authenticated' => $isAuthenticated,
            'user_id' => $isAuthenticated ? Auth::id() : null,
            'session_id' => session()->getId(),
            'cookie_received' => $request->cookie(config('session.cookie'))
        ]);

        // Public routes that don't require authentication
        $publicRoutes = ['login', 'register', 'login-submit', 'register-submit', 'logout', '', 'debug-auth', 'debug-sessions', 'reset-sessions', 'debug-session-full'];
        
        // If not authenticated and trying to access protected route
        if (!$isAuthenticated && !in_array($path, $publicRoutes)) {
            Log::warning('Redirecting to login - not authenticated', [
                'session_match' => $request->cookie(config('session.cookie')) === session()->getId()
            ]);
            return redirect()->route('login')->withErrors(['message' => 'Please log in to access this page.']);
        }

        Log::info('Allowing request to proceed');
        return $next($request);
    }
}

------------------------------------------------------------
FILE: app/Http/Middleware/IsAdmin.php
------------------------------------------------------------
<?php
namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Illuminate\Http\Response;
use Illuminate\Support\Facades\Auth;

class isAdmin
{
    /**
     * Handle an incoming request.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \Closure  $next
     * @return \Illuminate\Http\Response
     */
    public function handle(Request $request, Closure $next)
    {
        // Ensure the user is authenticated before checking role
        $user = Auth::user();
      
        if (!$user) {
            // Return an unauthorized response if the user is not authenticated
            return response()->json(['message' => 'Unauthorized'], 401);  // Explicitly returning JsonResponse, but it's fine in this context
        }

        // Check if the authenticated user is an admin
        if ($user->role !== 'admin' && $user->role !== "support" && $user->role !== "accountant") {
            // Return a forbidden response if the user is not an admin
            return response()->json(['message' => 'Forbidden. Admin access only.'], 403);  // Explicitly returning JsonResponse
        }

        //check if user is deleted
        if($user->isDeleted == 1){
            return response()->json(['message' => 'Unauthorized'], 401);
        }

        // Allow the request to proceed to the next middleware or controller
        return $next($request);  // This is a valid return, it doesn't return a JsonResponse
    }
}


------------------------------------------------------------
FILE: app/Http/Middleware/IsClient.php
------------------------------------------------------------
<?php
namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Illuminate\Http\Response;
use Illuminate\Support\Facades\Auth;
class isClient
{
    /**
     * Handle an incoming request.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \Closure  $next
     * @return \Illuminate\Http\Response
     */
    public function handle(Request $request, Closure $next)
    {
        // Ensure the user is authenticated before checking role
        $user = Auth::user();
      
        if (!$user || $user->isDeleted == 1) {
            // Return an unauthorized response if the user is not authenticated
            return response()->json(['message' => 'Unauthorized'], 401);  
        }

        // Check if the authenticated user is an client
        if (Auth::user()->role !== 'client') {
            // Return a forbidden response if the user is not an client
            return response()->json(['message' => 'Forbidden. Client access only.'], 403);  // Explicitly returning JsonResponse
        }

        // Allow the request to proceed to the next middleware or controller
        return $next($request);  // This is a valid return, it doesn't return a JsonResponse
    }
}


------------------------------------------------------------
FILE: app/Http/Middleware/IsSupplier.php
------------------------------------------------------------
<?php
namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;

class isSupplier
{
    /**
     * Handle an incoming request.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \Closure  $next
     * @return \Illuminate\Http\Response
     */
    public function handle(Request $request, Closure $next)
    {
        // Ensure the user is authenticated before checking role
        $user = Auth::user();
      
        if (!$user) {
            // Return an unauthorized response if the user is not authenticated
            return response()->json(['message' => 'Unauthorized'], 401);  
        }

        // Check if the authenticated user is an supplier
        if (Auth::user()->role !== 'supplier' || $user->isDeleted == 1) {
            // Return a forbidden response if the user is not an supplier
            return response()->json(['message' => 'Forbidden. Supplier access only.'], 403);  // Explicitly returning JsonResponse
        }

        // Allow the request to proceed to the next middleware or controller
        return $next($request);  // This is a valid return, it doesn't return a JsonResponse
    }
}


------------------------------------------------------------
FILE: app/Models/Category.php
------------------------------------------------------------
<?php
namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Category extends Model
{
    use HasFactory;

    protected $table = 'category';

    protected $fillable = ['name'];


    public function products()
    {
        return $this->hasMany(MasterProducts::class, 'category');
    }
}


------------------------------------------------------------
FILE: app/Models/Company.php
------------------------------------------------------------
<?php
namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Company extends Model
{
    use HasFactory;

    protected $table = 'companies';

    protected $fillable = ['name'];

    public function users()
    {
        return $this->hasMany(User::class);
    }
}


------------------------------------------------------------
FILE: app/Models/MasterProducts.php
------------------------------------------------------------
<?php
namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class MasterProducts extends Model
{
    protected $table = 'master_products';
    protected $fillable = ['product_name', 'product_type', 'specifications', 'unit_of_measure', 'tech_doc', 'photo','is_approved','added_by','approved_by', 'slug', 'category'];

    public function supplierOffers()
    {
        return $this->hasMany(SupplierOffers::class, 'master_product_id');
    }

    public function category()
    {
        return $this->belongsTo(Category::class, 'category')->select('id', 'name');
    }

    public function added_by()
    {
        return $this->belongsTo(User::class, 'added_by')->select('id', 'name', 'email','profile_image');
    }

    // Relationship with the user who approved the product
    public function approved_by()
    {
        return $this->belongsTo(User::class, 'approved_by')->select('id', 'name', 'email','profile_image');
    }
}


------------------------------------------------------------
FILE: app/Models/OrderItem.php
------------------------------------------------------------
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\{BelongsTo};

class OrderItem extends Model
{
    protected $table = 'order_items';

    protected $fillable = [
        'order_id',
        'product_id',
        'quantity',
        'supplier_id',
        'custom_blend_mix',
        'supplier_unit_cost',
        'supplier_delivery_cost',
        'supplier_discount',
        'supplier_delivery_date',
        'choosen_offer_id',
        'suppier_notes',
        'supplier_confirms',
        'delivery_type',
        'delivery_cost',
        'is_qouted',
        'quoted_price',
        'is_paid',
    ];

    protected $casts = [
        'quantity'               => 'decimal:2',
        'supplier_unit_cost'     => 'decimal:2',
        'supplier_delivery_cost' => 'decimal:2',
        'supplier_discount'      => 'decimal:2',
        'quoted_price'           => 'decimal:2',
        'delivery_cost'          => 'decimal:2',
        'supplier_confirms'      => 'boolean',
        'is_paid'                => 'boolean',
        'is_qouted'              => 'boolean',
        'supplier_delivery_date' => 'datetime',

    ];

    // Relations
    public function order(): BelongsTo
    {
        return $this->belongsTo(Orders::class, 'order_id');
    }

    public function product(): BelongsTo
    {
        return $this->belongsTo(MasterProducts::class, 'product_id');
    }

    public function supplier(): BelongsTo
    {
        return $this->belongsTo(User::class, 'supplier_id');
    }

    public function chosenOffer(): BelongsTo
    {
        return $this->belongsTo(SupplierOffers::class, 'choosen_offer_id');
    }
}


------------------------------------------------------------
FILE: app/Models/Orders.php
------------------------------------------------------------
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\{BelongsTo, HasMany, HasManyThrough};

class Orders extends Model
{
    protected $table = 'orders';

    protected $fillable = [
        'po_number',
        'client_id',
        'project_id',
        'delivery_address',
        'delivery_lat',
        'delivery_long',
        'delivery_date',
        'delivery_time',
        'delivery_window',
        'delivery_method',
        'load_size',
        'special_equipment',
        'subtotal',
        'fuel_levy',
        'other_charges',
        'gst_tax',
        'discount',
        'total_price',
        'supplier_cost',
        'customer_cost',
        'customer_item_cost',
        'customer_delivery_cost',
        'payment_status',
        'order_status',
        'workflow',
        'reason',
        'repeat_order',
        'generate_invoice',
        'order_process',
        'special_notes',
        'supplier_paid_ids',
        'is_archived',
        'archived_by',
    ];

    protected $casts = [
        'delivery_date'     => 'datetime',
        'delivery_time'     => 'datetime:H:i:s',
        'delivery_lat'      => 'float',
        'delivery_long'     => 'float',
        'subtotal'          => 'decimal:2',
        'fuel_levy'         => 'decimal:2',
        'other_charges'     => 'decimal:2',
        'gst_tax'           => 'decimal:2',
        'discount'          => 'decimal:2',
        'total_price'       => 'decimal:2',
        'supplier_cost'     => 'decimal:2',
        'customer_cost'     => 'decimal:2',
        'customer_item_cost'         => 'decimal:2',
        'customer_delivery_cost'     => 'decimal:2',
        'supplier   _item_cost'         => 'decimal:2',
        'supplier   _delivery_cost'     => 'decimal:2',
        'profit_amount'      => 'decimal:2',
        'profit_margin_percent'      => 'decimal:2',
        'admin_margin'      => 'decimal:2',
        'repeat_order'      => 'boolean',
        'generate_invoice'  => 'boolean',
        'is_archived'       => 'boolean',
        'archived_by'        => 'integer',
    ];

    // Enums as constants (optional helpers)
    public const PAYMENT_STATUS = ['Pending','Paid','Partially Paid','Partial Refunded','Refunded','Requested'];
    public const ORDER_STATUS   = ['Draft','Confirmed','Scheduled','In Transit','Delivered','Completed','Cancelled'];
    public const DELIVERY_WINDOW = ['Morning','Afternoon','Evening'];
    public const DELIVERY_METHOD = ['Other','Tipper','Agitator','Pump','Ute'];
    public const ORDER_PROCESS   = ['Automated','Action Required'];
    public const WORKFLOW        = ['Requested','Supplier Missing','Supplier Assigned','Payment Requested','On Hold','Delivered'];

    // Relations
    public function client(): BelongsTo
    {
        return $this->belongsTo(User::class, 'client_id');
    }

    public function project(): BelongsTo
    {
        return $this->belongsTo(Projects::class, 'project_id');
    }

    public function items(): HasMany
    {
        return $this->hasMany(OrderItem::class, 'order_id');
    }

    // Convenience: unique suppliers on this order
    public function suppliers(): HasManyThrough
    {
        return $this->hasManyThrough(
            User::class,
            OrderItem::class,
            'order_id',   // OrderItem foreign key...
            'id',         // User local key
            'id',         // Order local key
            'supplier_id' // OrderItem supplier key
        )->whereNotNull('order_items.supplier_id')->distinct();
    }

    // Scopes
    public function scopeForClient($q, int $clientId) { return $q->where('client_id', $clientId); }
    public function scopeStatus($q, string $status)   { return $q->where('order_status', $status); }
}


------------------------------------------------------------
FILE: app/Models/Projects.php
------------------------------------------------------------
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\HasMany;


class Projects extends Model
{
    use HasFactory;

    // Define the table associated with the model
    protected $table = 'projects';

    // Define the fields that are mass assignable
    protected $fillable = [
        'name',
        'site_contact_name',
        'site_contact_phone',
        'site_instructions',
        'delivery_address',
        'delivery_lat',
        'delivery_long',
        'added_by',
        'is_archived',
        'archived_by'
    ];

    // Define the relationship to the User model
    public function added_by()
    {
        return $this->belongsTo(User::class, 'added_by')->select('id','name','email','profile_image');  // 'added_by' is the foreign key
    }

    public function archived_by()
    {
        return $this->belongsTo(User::class, 'archived_by')->select('id','name','email','profile_image');  // 'archived_by' is the foreign key
    }

    public function orders(): HasMany
    {
        return $this->hasMany(Orders::class, 'project_id');
    }
}


------------------------------------------------------------
FILE: app/Models/SupplierOffers.php
------------------------------------------------------------
<?php
namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class SupplierOffers extends Model
{
    protected $table = 'supplier_offers';
    protected $fillable = ['supplier_id', 'master_product_id', 'price', 'availability_status', 'status'];

    public function masterProduct()
    {
        return $this->belongsTo(MasterProducts::class);
    }

    public function supplier()
    {
        return $this->belongsTo(User::class, 'supplier_id')
            ->select('id', 'name', 'email', 'profile_image', 'delivery_zones')
            ->withCasts(['delivery_zones' => 'array']);
    }
}


------------------------------------------------------------
FILE: app/Models/User.php
------------------------------------------------------------
<?php

namespace App\Models;

use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Laravel\Sanctum\HasApiTokens; 


class User extends Authenticatable
{
    use HasFactory, Notifiable, HasApiTokens;

    protected $fillable = [
        'name',
        'email',
        'password',
        'role',
        'company_id',
        'contact_name',
        'contact_number',
        'location',
        'lat',
        'long',
        'delivery_radius',
        'shipping_address',
        'billing_address',
        'client_public_id',
        'profile_image',
        'isDeleted',
        'notes',
        'delivery_zones',
        'company_name'
    ];

    protected $hidden = ['password', 'remember_token'];
    protected $casts = [
        'isDeleted' => 'boolean',
        'lat' => 'float',
        'long' => 'float',
        'delivery_zones' => 'array',
    ];


    // If it's stored as TEXT and not JSON type, use accessor:
    public function getDeliveryZonesAttribute($value)
    {
        return $value ? json_decode($value, true) : [];
    }

    public function company()
    {
        return $this->belongsTo(Company::class);
    }

    public function projects()
    {
        return $this->hasMany(Projects::class, 'added_by');  // 'added_by' is the foreign key
    }

    public function supplierOffers()
    {
        return $this->hasMany(SupplierOffers::class, 'supplier_id'); // 'supplier_id' is the foreign key in SupplierOffer
    }
}


------------------------------------------------------------
FILE: app/Models/Xerotoken.php
------------------------------------------------------------
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class XeroToken extends Model
{
    protected $fillable = [
        'access_token',
        'refresh_token',
        'tenant_id',
        'tenant_name',
        'expires_at',
    ];

    protected $casts = [
        'expires_at' => 'datetime',
    ];

    public function hasExpired(): bool
    {
        return $this->expires_at->isPast();
    }

    public function expiresSoon(): bool
    {
        return $this->expires_at->subMinutes(5)->isPast();
    }
}

------------------------------------------------------------
FILE: app/Providers/AppServiceProvider.php
------------------------------------------------------------
<?php

namespace App\Providers;

use Illuminate\Support\ServiceProvider;

class AppServiceProvider extends ServiceProvider
{
    /**
     * Register any application services.
     */
    public function register(): void
    {
        //
    }

    /**
     * Bootstrap any application services.
     */
    public function boot(): void
    {
        //
    }
}


------------------------------------------------------------
FILE: app/Services/OrderPricingService.php
------------------------------------------------------------
<?php

namespace App\Services;

use App\Models\Orders;
use App\Models\OrderItem;
use Illuminate\Support\Facades\DB;

class OrderPricingService
{
    /**
     * Recalculate customer-facing pricing when admin edits item price/discount/quoted price.
     * Supplier totals remain unchanged.
     *
     * @param  Orders $order  Loaded order with items relation (or will lazy-load).
     * @param  float|null $adminMargin  Override admin margin (default 0.50).
     * @param  float|null $gstRate      Override GST rate (default 0.05).
     * @param  bool $save               Persist changes.
     * @return Orders
     */
    public static function recalcCustomer(Orders $order, ?float $adminMargin = null, ?float $gstRate = null, bool $save = true): Orders
    {
        $ADMIN_MARGIN = $adminMargin ?? 0.50; // 50%
        $GST_RATE     = $gstRate     ?? 0.10; // 10%

        // Ensure items loaded
        $order->loadMissing(['items:id,order_id,quantity,supplier_unit_cost,supplier_discount,is_quoted,quoted_price,delivery_type,delivery_cost']);

        // 1) Rebuild customer_item_cost from items only
        $customer_item_cost = 0.0;
        $allItems = OrderItem::where('order_id',$order->id)->get();
        foreach ($allItems as $item) {
        
            if ((int)$item->is_quoted === 1 && $item->quoted_price !== null) {
  
                $customer_item_cost += (float)$item->quoted_price;
                continue;
            }
           
            $base_material = ($item->supplier_unit_cost * $item->quantity) - $item->supplier_discount;
            if ($base_material < 0) { $base_material = 0; }
     
            $customer_item_cost += $base_material * (1 + $ADMIN_MARGIN);
        }
     

        // 2) Keep existing customer_delivery_cost and supplier totals unchanged
        $customer_delivery_cost = (float) ($order->customer_delivery_cost ?? 0);
        $supplier_item_cost     = (float) ($order->supplier_item_cost ?? 0);
        $supplier_delivery_cost = (float) ($order->supplier_delivery_cost ?? 0);

        // 3) Recompute GST and totals
        $gst_tax = ($customer_item_cost + $customer_delivery_cost) * $GST_RATE;

        $discount      = (float) ($order->discount ?? 0);
        $other_charges = (float) ($order->other_charges ?? 0);

        $total_price = $customer_item_cost
                     + $customer_delivery_cost
                     + $gst_tax
                     - $discount
                     + $other_charges;

        // 4) Profit metrics based on frozen supplier totals
        $supplier_total        = $supplier_item_cost + $supplier_delivery_cost;
        $profit_before_tax     = $total_price - $supplier_total - $gst_tax - $other_charges;
        $profit_margin_percent = $supplier_total > 0 ? ($profit_before_tax / $supplier_total) : 0.0;
        // dd($total_price,$supplier_total,$gst_tax,$discount,$other_charges,$profit_before_tax, $profit_margin_percent);

        // 5) Persist
        $order->customer_item_cost     = round($customer_item_cost, 2);
        // customer_delivery_cost unchanged
        $order->gst_tax                = round($gst_tax, 2);
        $order->total_price            = round($total_price, 2);
        $order->profit_margin_percent  = $profit_margin_percent;
        $order->profit_amount          = round($profit_before_tax, 2); // actual profit amount
        
        if ($save) {
            DB::transaction(function () use ($order) {
                $order->save();
            });
        }

        return $order;
    }
}


------------------------------------------------------------
FILE: app/Services/Payments/LiveGroup.php
------------------------------------------------------------
<?php
namespace App\Services\Payments;

use GuzzleHttp\Client;
use Illuminate\Support\Facades\Config;

class LiveGroup {
  private Client $http; private string $merchant; private string $apiKey;
  public function __construct() {
    $this->merchant = Config::get('livegroup.merchant_id');
    $this->apiKey   = Config::get('livegroup.api_key');
    $this->http     = new Client([
      'base_uri' => Config::get('livegroup.base_url'),
      'timeout'  => Config::get('livegroup.timeout'),
    ]);
  }
  public function createIntent(array $payload): array {
    return $this->req('POST', '/v1/payments/intents', $payload);
  }
  public function getIntent(string $intentId): array {
    return $this->req('GET', "/v1/payments/intents/{$intentId}");
  }
  private function req(string $m, string $path, array $json=[]): array {
    $res = $this->http->request($m, $path, [
      'headers' => [
        'Authorization' => "Bearer {$this->apiKey}",
        'X-Merchant-Id' => $this->merchant,
        'Accept' => 'application/json',
      ],
      'json' => $json ?: null,
    ]);
    return json_decode((string)$res->getBody(), true);
  }
}


------------------------------------------------------------
FILE: app/Services/XeroService.php
------------------------------------------------------------
<?php

namespace App\Services;

use App\Models\XeroToken;
use GuzzleHttp\Client;
use XeroAPI\XeroPHP\Configuration;
use XeroAPI\XeroPHP\Api\AccountingApi;
use XeroAPI\XeroPHP\Api\IdentityApi;
use XeroAPI\XeroPHP\Models\Accounting\Invoice;
use XeroAPI\XeroPHP\Models\Accounting\Invoices;
use XeroAPI\XeroPHP\Models\Accounting\LineItem;
use XeroAPI\XeroPHP\Models\Accounting\Contact;
use XeroAPI\XeroPHP\Models\Accounting\Contacts;
use League\OAuth2\Client\Provider\GenericProvider;

class XeroService
{
    private GenericProvider $provider;
    private ?XeroToken $token = null;

    public function __construct()
    {
        $this->provider = new GenericProvider([
            'clientId'                => config('services.xero.client_id'),
            'clientSecret'            => config('services.xero.client_secret'),
            'redirectUri'             => config('services.xero.redirect_uri'),
            'urlAuthorize'            => 'https://login.xero.com/identity/connect/authorize',
            'urlAccessToken'          => 'https://identity.xero.com/connect/token',
            'urlResourceOwnerDetails' => 'https://identity.xero.com/resources'
        ]);
    }

    /**
     * Get authorization URL
     */
    public function getAuthorizationUrl(): array
    {
        $authUrl = $this->provider->getAuthorizationUrl([
            'scope' => 'openid profile email offline_access accounting.transactions accounting.contacts accounting.settings'
        ]);

        return [
            'url'   => $authUrl,
            'state' => $this->provider->getState()
        ];
    }

    /**
     * Handle OAuth callback
     */
    public function handleCallback(string $code): XeroToken
    {
        $accessToken = $this->provider->getAccessToken('authorization_code', [
            'code' => $code
        ]);

        $config = Configuration::getDefaultConfiguration()
            ->setAccessToken($accessToken->getToken());

        $identityApi = new IdentityApi(new Client(), $config);
        $connections = $identityApi->getConnections();

        if (empty($connections)) {
            throw new \Exception('No Xero organizations found');
        }

        $tenant = $connections[0];

        // Clear old tokens and save new one
        XeroToken::truncate();

        return XeroToken::create([
            'access_token'  => $accessToken->getToken(),
            'refresh_token' => $accessToken->getRefreshToken(),
            'tenant_id'     => $tenant->getTenantId(),
            'tenant_name'   => $tenant->getTenantName(),
            'expires_at'    => now()->addSeconds($accessToken->getExpires() - time()),
        ]);
    }

    /**
     * Get valid token (auto-refresh if needed)
     */
    public function getValidToken(): XeroToken
    {
        $this->token = XeroToken::first();

        if (!$this->token) {
            throw new \Exception('Xero not connected. Visit /api/xero/authorize in browser first.');
        }

        if ($this->token->hasExpired() || $this->token->expiresSoon()) {
            $this->refreshToken();
        }

        return $this->token;
    }

    /**
     * Refresh access token
     */
    private function refreshToken(): void
    {
        $newAccessToken = $this->provider->getAccessToken('refresh_token', [
            'refresh_token' => $this->token->refresh_token
        ]);

        $this->token->update([
            'access_token'  => $newAccessToken->getToken(),
            'refresh_token' => $newAccessToken->getRefreshToken(),
            'expires_at'    => now()->addSeconds($newAccessToken->getExpires() - time()),
        ]);
    }

    /**
     * Check if connected
     */
    public function isConnected(): bool
    {
        return XeroToken::exists();
    }

    /**
     * Create invoice in Xero
     */
    public function createInvoice(array $data): array
    {
        $token = $this->getValidToken();

        $config = Configuration::getDefaultConfiguration()
            ->setAccessToken($token->access_token);

        $api = new AccountingApi(new Client(), $config);
        $tenantId = $token->tenant_id;

        // Create Contact
        $contact = new Contact();
        $contact->setName($data['customer_name']);
        if (!empty($data['customer_email'])) {
            $contact->setEmailAddress($data['customer_email']);
        }

        // Create Line Items
        $lineItems = [];
        foreach ($data['items'] as $item) {
            $lineItem = new LineItem();
            $lineItem->setDescription($item['description']);
            $lineItem->setQuantity($item['quantity']);
            $lineItem->setUnitAmount($item['unit_price']);
            $lineItem->setAccountCode($item['account_code'] ?? '200');
            $lineItems[] = $lineItem;
        }

        // Create Invoice
        $invoice = new Invoice();
        $invoice->setType(Invoice::TYPE_ACCREC);
        $invoice->setContact($contact);
        $invoice->setLineItems($lineItems);
        $invoice->setDate(new \DateTime());
        $invoice->setDueDate(new \DateTime($data['due_date'] ?? '+30 days'));
        $invoice->setStatus(Invoice::STATUS_DRAFT);

        if (!empty($data['reference'])) {
            $invoice->setReference($data['reference']);
        }

        // Send to Xero
        $invoices = new Invoices();
        $invoices->setInvoices([$invoice]);

        $result = $api->createInvoices($tenantId, $invoices);
        $createdInvoice = $result->getInvoices()[0];

        return [
            'invoice_id'     => $createdInvoice->getInvoiceId(),
            'invoice_number' => $createdInvoice->getInvoiceNumber(),
            'status'         => $createdInvoice->getStatus(),
            'total'          => $createdInvoice->getTotal(),
            'contact'        => $createdInvoice->getContact()->getName(),
        ];
    }
}

------------------------------------------------------------
FILE: bootstrap/app.php
------------------------------------------------------------
<?php

use Illuminate\Foundation\Application;
use Illuminate\Foundation\Configuration\Exceptions;
use Illuminate\Foundation\Configuration\Middleware;

return Application::configure(basePath: dirname(__DIR__))
    ->withRouting(
        web: __DIR__.'/../routes/web.php',
        api: __DIR__.'/../routes/api.php',
        commands: __DIR__.'/../routes/console.php',
        health: '/up',
    )
    ->withMiddleware(function (Middleware $middleware) {
        $middleware->use([
            // App\Http\Middleware\AuthMiddleware::class,
            // App\Http\Middleware\isAdmin::class,
        ]);
    })
    ->withExceptions(function (Exceptions $exceptions) {
        //
    })
    ->create();

------------------------------------------------------------
FILE: bootstrap/providers.php
------------------------------------------------------------
<?php

return [
    App\Providers\AppServiceProvider::class,
];


------------------------------------------------------------
FILE: config/app.php
------------------------------------------------------------
<?php

return [

    /*
    |--------------------------------------------------------------------------
    | Application Name
    |--------------------------------------------------------------------------
    |
    | This value is the name of your application, which will be used when the
    | framework needs to place the application's name in a notification or
    | other UI elements where an application name needs to be displayed.
    |
    */

    'name' => env('APP_NAME', 'Laravel'),

    /*
    |--------------------------------------------------------------------------
    | Application Environment
    |--------------------------------------------------------------------------
    |
    | This value determines the "environment" your application is currently
    | running in. This may determine how you prefer to configure various
    | services the application utilizes. Set this in your ".env" file.
    |
    */

    'env' => env('APP_ENV', 'production'),

    /*
    |--------------------------------------------------------------------------
    | Application Debug Mode
    |--------------------------------------------------------------------------
    |
    | When your application is in debug mode, detailed error messages with
    | stack traces will be shown on every error that occurs within your
    | application. If disabled, a simple generic error page is shown.
    |
    */

    'debug' => (bool) env('APP_DEBUG', false),

    /*
    |--------------------------------------------------------------------------
    | Application URL
    |--------------------------------------------------------------------------
    |
    | This URL is used by the console to properly generate URLs when using
    | the Artisan command line tool. You should set this to the root of
    | the application so that it's available within Artisan commands.
    |
    */

    'url' => env('APP_URL', 'http://localhost'),

    /*
    |--------------------------------------------------------------------------
    | Application Timezone
    |--------------------------------------------------------------------------
    |
    | Here you may specify the default timezone for your application, which
    | will be used by the PHP date and date-time functions. The timezone
    | is set to "UTC" by default as it is suitable for most use cases.
    |
    */

    'timezone' => 'UTC',

    /*
    |--------------------------------------------------------------------------
    | Application Locale Configuration
    |--------------------------------------------------------------------------
    |
    | The application locale determines the default locale that will be used
    | by Laravel's translation / localization methods. This option can be
    | set to any locale for which you plan to have translation strings.
    |
    */

    'locale' => env('APP_LOCALE', 'en'),

    'fallback_locale' => env('APP_FALLBACK_LOCALE', 'en'),

    'faker_locale' => env('APP_FAKER_LOCALE', 'en_US'),

    /*
    |--------------------------------------------------------------------------
    | Encryption Key
    |--------------------------------------------------------------------------
    |
    | This key is utilized by Laravel's encryption services and should be set
    | to a random, 32 character string to ensure that all encrypted values
    | are secure. You should do this prior to deploying the application.
    |
    */

    'cipher' => 'AES-256-CBC',

    'key' => env('APP_KEY'),

    'previous_keys' => [
        ...array_filter(
            explode(',', (string) env('APP_PREVIOUS_KEYS', ''))
        ),
    ],

    /*
    |--------------------------------------------------------------------------
    | Maintenance Mode Driver
    |--------------------------------------------------------------------------
    |
    | These configuration options determine the driver used to determine and
    | manage Laravel's "maintenance mode" status. The "cache" driver will
    | allow maintenance mode to be controlled across multiple machines.
    |
    | Supported drivers: "file", "cache"
    |
    */

    'maintenance' => [
        'driver' => env('APP_MAINTENANCE_DRIVER', 'file'),
        'store' => env('APP_MAINTENANCE_STORE', 'database'),
    ],

];


------------------------------------------------------------
FILE: config/auth.php
------------------------------------------------------------
<?php

return [

    /*
    |--------------------------------------------------------------------------
    | Authentication Defaults
    |--------------------------------------------------------------------------
    |
    | This option defines the default authentication "guard" and password
    | reset "broker" for your application. You may change these values
    | as required, but they're a perfect start for most applications.
    |
    */

    'defaults' => [
        'guard' => env('AUTH_GUARD', 'web'),
        'passwords' => env('AUTH_PASSWORD_BROKER', 'users'),
    ],

    /*
    |--------------------------------------------------------------------------
    | Authentication Guards
    |--------------------------------------------------------------------------
    |
    | Next, you may define every authentication guard for your application.
    | Of course, a great default configuration has been defined for you
    | which utilizes session storage plus the Eloquent user provider.
    |
    | All authentication guards have a user provider, which defines how the
    | users are actually retrieved out of your database or other storage
    | system used by the application. Typically, Eloquent is utilized.
    |
    | Supported: "session"
    |
    */

    'guards' => [
        'web' => [
            'driver' => 'session',
            'provider' => 'users',
        ],
    ],

    /*
    |--------------------------------------------------------------------------
    | User Providers
    |--------------------------------------------------------------------------
    |
    | All authentication guards have a user provider, which defines how the
    | users are actually retrieved out of your database or other storage
    | system used by the application. Typically, Eloquent is utilized.
    |
    | If you have multiple user tables or models you may configure multiple
    | providers to represent the model / table. These providers may then
    | be assigned to any extra authentication guards you have defined.
    |
    | Supported: "database", "eloquent"
    |
    */

    'providers' => [
        'users' => [
            'driver' => 'eloquent',
            'model' => env('AUTH_MODEL', App\Models\User::class),
        ],

        // 'users' => [
        //     'driver' => 'database',
        //     'table' => 'users',
        // ],
    ],

    /*
    |--------------------------------------------------------------------------
    | Resetting Passwords
    |--------------------------------------------------------------------------
    |
    | These configuration options specify the behavior of Laravel's password
    | reset functionality, including the table utilized for token storage
    | and the user provider that is invoked to actually retrieve users.
    |
    | The expiry time is the number of minutes that each reset token will be
    | considered valid. This security feature keeps tokens short-lived so
    | they have less time to be guessed. You may change this as needed.
    |
    | The throttle setting is the number of seconds a user must wait before
    | generating more password reset tokens. This prevents the user from
    | quickly generating a very large amount of password reset tokens.
    |
    */

    'passwords' => [
        'users' => [
            'provider' => 'users',
            'table' => env('AUTH_PASSWORD_RESET_TOKEN_TABLE', 'password_reset_tokens'),
            'expire' => 60,
            'throttle' => 60,
        ],
    ],

    /*
    |--------------------------------------------------------------------------
    | Password Confirmation Timeout
    |--------------------------------------------------------------------------
    |
    | Here you may define the number of seconds before a password confirmation
    | window expires and users are asked to re-enter their password via the
    | confirmation screen. By default, the timeout lasts for three hours.
    |
    */

    'password_timeout' => env('AUTH_PASSWORD_TIMEOUT', 10800),

];


------------------------------------------------------------
FILE: config/cache.php
------------------------------------------------------------
<?php

use Illuminate\Support\Str;

return [

    /*
    |--------------------------------------------------------------------------
    | Default Cache Store
    |--------------------------------------------------------------------------
    |
    | This option controls the default cache store that will be used by the
    | framework. This connection is utilized if another isn't explicitly
    | specified when running a cache operation inside the application.
    |
    */

    'default' => env('CACHE_STORE', 'database'),

    /*
    |--------------------------------------------------------------------------
    | Cache Stores
    |--------------------------------------------------------------------------
    |
    | Here you may define all of the cache "stores" for your application as
    | well as their drivers. You may even define multiple stores for the
    | same cache driver to group types of items stored in your caches.
    |
    | Supported drivers: "array", "database", "file", "memcached",
    |                    "redis", "dynamodb", "octane", "null"
    |
    */

    'stores' => [

        'array' => [
            'driver' => 'array',
            'serialize' => false,
        ],

        'database' => [
            'driver' => 'database',
            'connection' => env('DB_CACHE_CONNECTION'),
            'table' => env('DB_CACHE_TABLE', 'cache'),
            'lock_connection' => env('DB_CACHE_LOCK_CONNECTION'),
            'lock_table' => env('DB_CACHE_LOCK_TABLE'),
        ],

        'file' => [
            'driver' => 'file',
            'path' => storage_path('framework/cache/data'),
            'lock_path' => storage_path('framework/cache/data'),
        ],

        'memcached' => [
            'driver' => 'memcached',
            'persistent_id' => env('MEMCACHED_PERSISTENT_ID'),
            'sasl' => [
                env('MEMCACHED_USERNAME'),
                env('MEMCACHED_PASSWORD'),
            ],
            'options' => [
                // Memcached::OPT_CONNECT_TIMEOUT => 2000,
            ],
            'servers' => [
                [
                    'host' => env('MEMCACHED_HOST', '127.0.0.1'),
                    'port' => env('MEMCACHED_PORT', 11211),
                    'weight' => 100,
                ],
            ],
        ],

        'redis' => [
            'driver' => 'redis',
            'connection' => env('REDIS_CACHE_CONNECTION', 'cache'),
            'lock_connection' => env('REDIS_CACHE_LOCK_CONNECTION', 'default'),
        ],

        'dynamodb' => [
            'driver' => 'dynamodb',
            'key' => env('AWS_ACCESS_KEY_ID'),
            'secret' => env('AWS_SECRET_ACCESS_KEY'),
            'region' => env('AWS_DEFAULT_REGION', 'us-east-1'),
            'table' => env('DYNAMODB_CACHE_TABLE', 'cache'),
            'endpoint' => env('DYNAMODB_ENDPOINT'),
        ],

        'octane' => [
            'driver' => 'octane',
        ],

    ],

    /*
    |--------------------------------------------------------------------------
    | Cache Key Prefix
    |--------------------------------------------------------------------------
    |
    | When utilizing the APC, database, memcached, Redis, and DynamoDB cache
    | stores, there might be other applications using the same cache. For
    | that reason, you may prefix every cache key to avoid collisions.
    |
    */

    'prefix' => env('CACHE_PREFIX', Str::slug((string) env('APP_NAME', 'laravel')).'-cache-'),

];


------------------------------------------------------------
FILE: config/database.php
------------------------------------------------------------
<?php

use Illuminate\Support\Str;

return [

    /*
    |--------------------------------------------------------------------------
    | Default Database Connection Name
    |--------------------------------------------------------------------------
    |
    | Here you may specify which of the database connections below you wish
    | to use as your default connection for database operations. This is
    | the connection which will be utilized unless another connection
    | is explicitly specified when you execute a query / statement.
    |
    */

    'default' => env('DB_CONNECTION', 'sqlite'),

    /*
    |--------------------------------------------------------------------------
    | Database Connections
    |--------------------------------------------------------------------------
    |
    | Below are all of the database connections defined for your application.
    | An example configuration is provided for each database system which
    | is supported by Laravel. You're free to add / remove connections.
    |
    */

    'connections' => [

        'sqlite' => [
            'driver' => 'sqlite',
            'url' => env('DB_URL'),
            'database' => env('DB_DATABASE', database_path('database.sqlite')),
            'prefix' => '',
            'foreign_key_constraints' => env('DB_FOREIGN_KEYS', true),
            'busy_timeout' => null,
            'journal_mode' => null,
            'synchronous' => null,
            'transaction_mode' => 'DEFERRED',
        ],

        'mysql' => [
            'driver' => 'mysql',
            'url' => env('DB_URL'),
            'host' => env('DB_HOST', '127.0.0.1'),
            'port' => env('DB_PORT', '3306'),
            'database' => env('DB_DATABASE', 'laravel'),
            'username' => env('DB_USERNAME', 'root'),
            'password' => env('DB_PASSWORD', ''),
            'unix_socket' => env('DB_SOCKET', ''),
            'charset' => env('DB_CHARSET', 'utf8mb4'),
            'collation' => env('DB_COLLATION', 'utf8mb4_unicode_ci'),
            'prefix' => '',
            'prefix_indexes' => true,
            'strict' => true,
            'engine' => null,
            'options' => extension_loaded('pdo_mysql') ? array_filter([
                PDO::MYSQL_ATTR_SSL_CA => env('MYSQL_ATTR_SSL_CA'),
            ]) : [],
        ],

        'mariadb' => [
            'driver' => 'mariadb',
            'url' => env('DB_URL'),
            'host' => env('DB_HOST', '127.0.0.1'),
            'port' => env('DB_PORT', '3306'),
            'database' => env('DB_DATABASE', 'laravel'),
            'username' => env('DB_USERNAME', 'root'),
            'password' => env('DB_PASSWORD', ''),
            'unix_socket' => env('DB_SOCKET', ''),
            'charset' => env('DB_CHARSET', 'utf8mb4'),
            'collation' => env('DB_COLLATION', 'utf8mb4_unicode_ci'),
            'prefix' => '',
            'prefix_indexes' => true,
            'strict' => true,
            'engine' => null,
            'options' => extension_loaded('pdo_mysql') ? array_filter([
                PDO::MYSQL_ATTR_SSL_CA => env('MYSQL_ATTR_SSL_CA'),
            ]) : [],
        ],

        'pgsql' => [
            'driver' => 'pgsql',
            'url' => env('DB_URL'),
            'host' => env('DB_HOST', '127.0.0.1'),
            'port' => env('DB_PORT', '5432'),
            'database' => env('DB_DATABASE', 'laravel'),
            'username' => env('DB_USERNAME', 'root'),
            'password' => env('DB_PASSWORD', ''),
            'charset' => env('DB_CHARSET', 'utf8'),
            'prefix' => '',
            'prefix_indexes' => true,
            'search_path' => 'public',
            'sslmode' => 'prefer',
        ],

        'sqlsrv' => [
            'driver' => 'sqlsrv',
            'url' => env('DB_URL'),
            'host' => env('DB_HOST', 'localhost'),
            'port' => env('DB_PORT', '1433'),
            'database' => env('DB_DATABASE', 'laravel'),
            'username' => env('DB_USERNAME', 'root'),
            'password' => env('DB_PASSWORD', ''),
            'charset' => env('DB_CHARSET', 'utf8'),
            'prefix' => '',
            'prefix_indexes' => true,
            // 'encrypt' => env('DB_ENCRYPT', 'yes'),
            // 'trust_server_certificate' => env('DB_TRUST_SERVER_CERTIFICATE', 'false'),
        ],

    ],

    /*
    |--------------------------------------------------------------------------
    | Migration Repository Table
    |--------------------------------------------------------------------------
    |
    | This table keeps track of all the migrations that have already run for
    | your application. Using this information, we can determine which of
    | the migrations on disk haven't actually been run on the database.
    |
    */

    'migrations' => [
        'table' => 'migrations',
        'update_date_on_publish' => true,
    ],

    /*
    |--------------------------------------------------------------------------
    | Redis Databases
    |--------------------------------------------------------------------------
    |
    | Redis is an open source, fast, and advanced key-value store that also
    | provides a richer body of commands than a typical key-value system
    | such as Memcached. You may define your connection settings here.
    |
    */

    'redis' => [

        'client' => env('REDIS_CLIENT', 'phpredis'),

        'options' => [
            'cluster' => env('REDIS_CLUSTER', 'redis'),
            'prefix' => env('REDIS_PREFIX', Str::slug((string) env('APP_NAME', 'laravel')).'-database-'),
            'persistent' => env('REDIS_PERSISTENT', false),
        ],

        'default' => [
            'url' => env('REDIS_URL'),
            'host' => env('REDIS_HOST', '127.0.0.1'),
            'username' => env('REDIS_USERNAME'),
            'password' => env('REDIS_PASSWORD'),
            'port' => env('REDIS_PORT', '6379'),
            'database' => env('REDIS_DB', '0'),
            'max_retries' => env('REDIS_MAX_RETRIES', 3),
            'backoff_algorithm' => env('REDIS_BACKOFF_ALGORITHM', 'decorrelated_jitter'),
            'backoff_base' => env('REDIS_BACKOFF_BASE', 100),
            'backoff_cap' => env('REDIS_BACKOFF_CAP', 1000),
        ],

        'cache' => [
            'url' => env('REDIS_URL'),
            'host' => env('REDIS_HOST', '127.0.0.1'),
            'username' => env('REDIS_USERNAME'),
            'password' => env('REDIS_PASSWORD'),
            'port' => env('REDIS_PORT', '6379'),
            'database' => env('REDIS_CACHE_DB', '1'),
            'max_retries' => env('REDIS_MAX_RETRIES', 3),
            'backoff_algorithm' => env('REDIS_BACKOFF_ALGORITHM', 'decorrelated_jitter'),
            'backoff_base' => env('REDIS_BACKOFF_BASE', 100),
            'backoff_cap' => env('REDIS_BACKOFF_CAP', 1000),
        ],

    ],

];


------------------------------------------------------------
FILE: config/filesystems.php
------------------------------------------------------------
<?php

return [

    /*
    |--------------------------------------------------------------------------
    | Default Filesystem Disk
    |--------------------------------------------------------------------------
    |
    | Here you may specify the default filesystem disk that should be used
    | by the framework. The "local" disk, as well as a variety of cloud
    | based disks are available to your application for file storage.
    |
    */

    'default' => env('FILESYSTEM_DISK', 'local'),

    /*
    |--------------------------------------------------------------------------
    | Filesystem Disks
    |--------------------------------------------------------------------------
    |
    | Below you may configure as many filesystem disks as necessary, and you
    | may even configure multiple disks for the same driver. Examples for
    | most supported storage drivers are configured here for reference.
    |
    | Supported drivers: "local", "ftp", "sftp", "s3"
    |
    */

    'disks' => [

        'local' => [
            'driver' => 'local',
            'root' => storage_path('app/private'),
            'serve' => true,
            'throw' => false,
            'report' => false,
        ],

        'public' => [
            'driver' => 'local',
            'root' => storage_path('app/public'),
            'url' => env('APP_URL').'/storage',
            'visibility' => 'public',
            'throw' => false,
            'report' => false,
        ],

        's3' => [
            'driver' => 's3',
            'key' => env('AWS_ACCESS_KEY_ID'),
            'secret' => env('AWS_SECRET_ACCESS_KEY'),
            'region' => env('AWS_DEFAULT_REGION'),
            'bucket' => env('AWS_BUCKET'),
            'url' => env('AWS_URL'),
            'endpoint' => env('AWS_ENDPOINT'),
            'use_path_style_endpoint' => env('AWS_USE_PATH_STYLE_ENDPOINT', false),
            'throw' => false,
            'report' => false,
        ],

    ],

    /*
    |--------------------------------------------------------------------------
    | Symbolic Links
    |--------------------------------------------------------------------------
    |
    | Here you may configure the symbolic links that will be created when the
    | `storage:link` Artisan command is executed. The array keys should be
    | the locations of the links and the values should be their targets.
    |
    */

    'links' => [
        public_path('storage') => storage_path('app/public'),
    ],

];


------------------------------------------------------------
FILE: config/livegroup.php
------------------------------------------------------------
<?php
return [
  'merchant_id' => env('LIVEGROUP_MERCHANT_ID'),
  'api_key'     => env('LIVEGROUP_API_KEY'),
  'base_url'    => rtrim(env('LIVEGROUP_BASE_URL',''),'/'),
  'timeout'     => 15,
];


------------------------------------------------------------
FILE: config/logging.php
------------------------------------------------------------
<?php

use Monolog\Handler\NullHandler;
use Monolog\Handler\StreamHandler;
use Monolog\Handler\SyslogUdpHandler;
use Monolog\Processor\PsrLogMessageProcessor;

return [

    /*
    |--------------------------------------------------------------------------
    | Default Log Channel
    |--------------------------------------------------------------------------
    |
    | This option defines the default log channel that is utilized to write
    | messages to your logs. The value provided here should match one of
    | the channels present in the list of "channels" configured below.
    |
    */

    'default' => env('LOG_CHANNEL', 'stack'),

    /*
    |--------------------------------------------------------------------------
    | Deprecations Log Channel
    |--------------------------------------------------------------------------
    |
    | This option controls the log channel that should be used to log warnings
    | regarding deprecated PHP and library features. This allows you to get
    | your application ready for upcoming major versions of dependencies.
    |
    */

    'deprecations' => [
        'channel' => env('LOG_DEPRECATIONS_CHANNEL', 'null'),
        'trace' => env('LOG_DEPRECATIONS_TRACE', false),
    ],

    /*
    |--------------------------------------------------------------------------
    | Log Channels
    |--------------------------------------------------------------------------
    |
    | Here you may configure the log channels for your application. Laravel
    | utilizes the Monolog PHP logging library, which includes a variety
    | of powerful log handlers and formatters that you're free to use.
    |
    | Available drivers: "single", "daily", "slack", "syslog",
    |                    "errorlog", "monolog", "custom", "stack"
    |
    */

    'channels' => [

        'stack' => [
            'driver' => 'stack',
            'channels' => explode(',', (string) env('LOG_STACK', 'single')),
            'ignore_exceptions' => false,
        ],

        'single' => [
            'driver' => 'single',
            'path' => storage_path('logs/laravel.log'),
            'level' => env('LOG_LEVEL', 'debug'),
            'replace_placeholders' => true,
        ],

        'daily' => [
            'driver' => 'daily',
            'path' => storage_path('logs/laravel.log'),
            'level' => env('LOG_LEVEL', 'debug'),
            'days' => env('LOG_DAILY_DAYS', 14),
            'replace_placeholders' => true,
        ],

        'slack' => [
            'driver' => 'slack',
            'url' => env('LOG_SLACK_WEBHOOK_URL'),
            'username' => env('LOG_SLACK_USERNAME', 'Laravel Log'),
            'emoji' => env('LOG_SLACK_EMOJI', ':boom:'),
            'level' => env('LOG_LEVEL', 'critical'),
            'replace_placeholders' => true,
        ],

        'papertrail' => [
            'driver' => 'monolog',
            'level' => env('LOG_LEVEL', 'debug'),
            'handler' => env('LOG_PAPERTRAIL_HANDLER', SyslogUdpHandler::class),
            'handler_with' => [
                'host' => env('PAPERTRAIL_URL'),
                'port' => env('PAPERTRAIL_PORT'),
                'connectionString' => 'tls://'.env('PAPERTRAIL_URL').':'.env('PAPERTRAIL_PORT'),
            ],
            'processors' => [PsrLogMessageProcessor::class],
        ],

        'stderr' => [
            'driver' => 'monolog',
            'level' => env('LOG_LEVEL', 'debug'),
            'handler' => StreamHandler::class,
            'handler_with' => [
                'stream' => 'php://stderr',
            ],
            'formatter' => env('LOG_STDERR_FORMATTER'),
            'processors' => [PsrLogMessageProcessor::class],
        ],

        'syslog' => [
            'driver' => 'syslog',
            'level' => env('LOG_LEVEL', 'debug'),
            'facility' => env('LOG_SYSLOG_FACILITY', LOG_USER),
            'replace_placeholders' => true,
        ],

        'errorlog' => [
            'driver' => 'errorlog',
            'level' => env('LOG_LEVEL', 'debug'),
            'replace_placeholders' => true,
        ],

        'null' => [
            'driver' => 'monolog',
            'handler' => NullHandler::class,
        ],

        'emergency' => [
            'path' => storage_path('logs/laravel.log'),
        ],

    ],

];


------------------------------------------------------------
FILE: config/mail.php
------------------------------------------------------------
<?php

return [

    /*
    |--------------------------------------------------------------------------
    | Default Mailer
    |--------------------------------------------------------------------------
    |
    | This option controls the default mailer that is used to send all email
    | messages unless another mailer is explicitly specified when sending
    | the message. All additional mailers can be configured within the
    | "mailers" array. Examples of each type of mailer are provided.
    |
    */

    'default' => env('MAIL_MAILER', 'log'),

    /*
    |--------------------------------------------------------------------------
    | Mailer Configurations
    |--------------------------------------------------------------------------
    |
    | Here you may configure all of the mailers used by your application plus
    | their respective settings. Several examples have been configured for
    | you and you are free to add your own as your application requires.
    |
    | Laravel supports a variety of mail "transport" drivers that can be used
    | when delivering an email. You may specify which one you're using for
    | your mailers below. You may also add additional mailers if needed.
    |
    | Supported: "smtp", "sendmail", "mailgun", "ses", "ses-v2",
    |            "postmark", "resend", "log", "array",
    |            "failover", "roundrobin"
    |
    */

    'mailers' => [

        'smtp' => [
            'transport' => 'smtp',
            'scheme' => env('MAIL_SCHEME'),
            'url' => env('MAIL_URL'),
            'host' => env('MAIL_HOST', '127.0.0.1'),
            'port' => env('MAIL_PORT', 2525),
            'username' => env('MAIL_USERNAME'),
            'password' => env('MAIL_PASSWORD'),
            'timeout' => null,
            'local_domain' => env('MAIL_EHLO_DOMAIN', parse_url((string) env('APP_URL', 'http://localhost'), PHP_URL_HOST)),
        ],

        'ses' => [
            'transport' => 'ses',
        ],

        'postmark' => [
            'transport' => 'postmark',
            // 'message_stream_id' => env('POSTMARK_MESSAGE_STREAM_ID'),
            // 'client' => [
            //     'timeout' => 5,
            // ],
        ],

        'resend' => [
            'transport' => 'resend',
        ],

        'sendmail' => [
            'transport' => 'sendmail',
            'path' => env('MAIL_SENDMAIL_PATH', '/usr/sbin/sendmail -bs -i'),
        ],

        'log' => [
            'transport' => 'log',
            'channel' => env('MAIL_LOG_CHANNEL'),
        ],

        'array' => [
            'transport' => 'array',
        ],

        'failover' => [
            'transport' => 'failover',
            'mailers' => [
                'smtp',
                'log',
            ],
            'retry_after' => 60,
        ],

        'roundrobin' => [
            'transport' => 'roundrobin',
            'mailers' => [
                'ses',
                'postmark',
            ],
            'retry_after' => 60,
        ],

    ],

    /*
    |--------------------------------------------------------------------------
    | Global "From" Address
    |--------------------------------------------------------------------------
    |
    | You may wish for all emails sent by your application to be sent from
    | the same address. Here you may specify a name and address that is
    | used globally for all emails that are sent by your application.
    |
    */

    'from' => [
        'address' => env('MAIL_FROM_ADDRESS', 'hello@example.com'),
        'name' => env('MAIL_FROM_NAME', 'Example'),
    ],

];


------------------------------------------------------------
FILE: config/queue.php
------------------------------------------------------------
<?php

return [

    /*
    |--------------------------------------------------------------------------
    | Default Queue Connection Name
    |--------------------------------------------------------------------------
    |
    | Laravel's queue supports a variety of backends via a single, unified
    | API, giving you convenient access to each backend using identical
    | syntax for each. The default queue connection is defined below.
    |
    */

    'default' => env('QUEUE_CONNECTION', 'database'),

    /*
    |--------------------------------------------------------------------------
    | Queue Connections
    |--------------------------------------------------------------------------
    |
    | Here you may configure the connection options for every queue backend
    | used by your application. An example configuration is provided for
    | each backend supported by Laravel. You're also free to add more.
    |
    | Drivers: "sync", "database", "beanstalkd", "sqs", "redis", "null"
    |
    */

    'connections' => [

        'sync' => [
            'driver' => 'sync',
        ],

        'database' => [
            'driver' => 'database',
            'connection' => env('DB_QUEUE_CONNECTION'),
            'table' => env('DB_QUEUE_TABLE', 'jobs'),
            'queue' => env('DB_QUEUE', 'default'),
            'retry_after' => (int) env('DB_QUEUE_RETRY_AFTER', 90),
            'after_commit' => false,
        ],

        'beanstalkd' => [
            'driver' => 'beanstalkd',
            'host' => env('BEANSTALKD_QUEUE_HOST', 'localhost'),
            'queue' => env('BEANSTALKD_QUEUE', 'default'),
            'retry_after' => (int) env('BEANSTALKD_QUEUE_RETRY_AFTER', 90),
            'block_for' => 0,
            'after_commit' => false,
        ],

        'sqs' => [
            'driver' => 'sqs',
            'key' => env('AWS_ACCESS_KEY_ID'),
            'secret' => env('AWS_SECRET_ACCESS_KEY'),
            'prefix' => env('SQS_PREFIX', 'https://sqs.us-east-1.amazonaws.com/your-account-id'),
            'queue' => env('SQS_QUEUE', 'default'),
            'suffix' => env('SQS_SUFFIX'),
            'region' => env('AWS_DEFAULT_REGION', 'us-east-1'),
            'after_commit' => false,
        ],

        'redis' => [
            'driver' => 'redis',
            'connection' => env('REDIS_QUEUE_CONNECTION', 'default'),
            'queue' => env('REDIS_QUEUE', 'default'),
            'retry_after' => (int) env('REDIS_QUEUE_RETRY_AFTER', 90),
            'block_for' => null,
            'after_commit' => false,
        ],

    ],

    /*
    |--------------------------------------------------------------------------
    | Job Batching
    |--------------------------------------------------------------------------
    |
    | The following options configure the database and table that store job
    | batching information. These options can be updated to any database
    | connection and table which has been defined by your application.
    |
    */

    'batching' => [
        'database' => env('DB_CONNECTION', 'sqlite'),
        'table' => 'job_batches',
    ],

    /*
    |--------------------------------------------------------------------------
    | Failed Queue Jobs
    |--------------------------------------------------------------------------
    |
    | These options configure the behavior of failed queue job logging so you
    | can control how and where failed jobs are stored. Laravel ships with
    | support for storing failed jobs in a simple file or in a database.
    |
    | Supported drivers: "database-uuids", "dynamodb", "file", "null"
    |
    */

    'failed' => [
        'driver' => env('QUEUE_FAILED_DRIVER', 'database-uuids'),
        'database' => env('DB_CONNECTION', 'sqlite'),
        'table' => 'failed_jobs',
    ],

];


------------------------------------------------------------
FILE: config/sanctum.php
------------------------------------------------------------
<?php

use Laravel\Sanctum\Sanctum;

return [

    /*
    |--------------------------------------------------------------------------
    | Stateful Domains
    |--------------------------------------------------------------------------
    |
    | Requests from the following domains / hosts will receive stateful API
    | authentication cookies. Typically, these should include your local
    | and production domains which access your API via a frontend SPA.
    |
    */

    'stateful' => explode(',', env('SANCTUM_STATEFUL_DOMAINS', sprintf(
        '%s%s',
        'localhost,localhost:3000,127.0.0.1,127.0.0.1:8000,::1',
        Sanctum::currentApplicationUrlWithPort(),
        // Sanctum::currentRequestHost(),
    ))),

    /*
    |--------------------------------------------------------------------------
    | Sanctum Guards
    |--------------------------------------------------------------------------
    |
    | This array contains the authentication guards that will be checked when
    | Sanctum is trying to authenticate a request. If none of these guards
    | are able to authenticate the request, Sanctum will use the bearer
    | token that's present on an incoming request for authentication.
    |
    */

    'guard' => ['web'],

    /*
    |--------------------------------------------------------------------------
    | Expiration Minutes
    |--------------------------------------------------------------------------
    |
    | This value controls the number of minutes until an issued token will be
    | considered expired. This will override any values set in the token's
    | "expires_at" attribute, but first-party sessions are not affected.
    |
    */

    'expiration' => null,

    /*
    |--------------------------------------------------------------------------
    | Token Prefix
    |--------------------------------------------------------------------------
    |
    | Sanctum can prefix new tokens in order to take advantage of numerous
    | security scanning initiatives maintained by open source platforms
    | that notify developers if they commit tokens into repositories.
    |
    | See: https://docs.github.com/en/code-security/secret-scanning/about-secret-scanning
    |
    */

    'token_prefix' => env('SANCTUM_TOKEN_PREFIX', ''),

    /*
    |--------------------------------------------------------------------------
    | Sanctum Middleware
    |--------------------------------------------------------------------------
    |
    | When authenticating your first-party SPA with Sanctum you may need to
    | customize some of the middleware Sanctum uses while processing the
    | request. You may change the middleware listed below as required.
    |
    */

    'middleware' => [
        'authenticate_session' => Laravel\Sanctum\Http\Middleware\AuthenticateSession::class,
        'encrypt_cookies' => Illuminate\Cookie\Middleware\EncryptCookies::class,
        'validate_csrf_token' => Illuminate\Foundation\Http\Middleware\ValidateCsrfToken::class,
    ],

];


------------------------------------------------------------
FILE: config/services.php
------------------------------------------------------------
<?php

return [

    /*
    |--------------------------------------------------------------------------
    | Third Party Services
    |--------------------------------------------------------------------------
    |
    | This file is for storing the credentials for third party services such
    | as Mailgun, Postmark, AWS and more. This file provides the de facto
    | location for this type of information, allowing packages to have
    | a conventional file to locate the various service credentials.
    |
    */

    'postmark' => [
        'token' => env('POSTMARK_TOKEN'),
    ],

    'resend' => [
        'key' => env('RESEND_KEY'),
    ],

    'ses' => [
        'key' => env('AWS_ACCESS_KEY_ID'),
        'secret' => env('AWS_SECRET_ACCESS_KEY'),
        'region' => env('AWS_DEFAULT_REGION', 'us-east-1'),
    ],

    'xero' => [
        'client_id'     => env('XERO_CLIENT_ID'),
        'client_secret' => env('XERO_CLIENT_SECRET'),
        'redirect_uri'  => env('XERO_REDIRECT_URI'),
    ],

    'slack' => [
        'notifications' => [
            'bot_user_oauth_token' => env('SLACK_BOT_USER_OAUTH_TOKEN'),
            'channel' => env('SLACK_BOT_USER_DEFAULT_CHANNEL'),
        ],
    ],

];


------------------------------------------------------------
FILE: config/session.php
------------------------------------------------------------
<?php

use Illuminate\Support\Str;

return [

    /*
    |--------------------------------------------------------------------------
    | Default Session Driver
    |--------------------------------------------------------------------------
    |
    | This option determines the default session driver that is utilized for
    | incoming requests. Laravel supports a variety of storage options to
    | persist session data. Database storage is a great default choice.
    |
    | Supported: "file", "cookie", "database", "memcached",
    |            "redis", "dynamodb", "array"
    |
    */

    'driver' => env('SESSION_DRIVER', 'database'),

    /*
    |--------------------------------------------------------------------------
    | Session Lifetime
    |--------------------------------------------------------------------------
    |
    | Here you may specify the number of minutes that you wish the session
    | to be allowed to remain idle before it expires. If you want them
    | to expire immediately when the browser is closed then you may
    | indicate that via the expire_on_close configuration option.
    |
    */

    'lifetime' => (int) env('SESSION_LIFETIME', 120),

    'expire_on_close' => env('SESSION_EXPIRE_ON_CLOSE', false),

    /*
    |--------------------------------------------------------------------------
    | Session Encryption
    |--------------------------------------------------------------------------
    |
    | This option allows you to easily specify that all of your session data
    | should be encrypted before it's stored. All encryption is performed
    | automatically by Laravel and you may use the session like normal.
    |
    */

    'encrypt' => env('SESSION_ENCRYPT', false),

    /*
    |--------------------------------------------------------------------------
    | Session File Location
    |--------------------------------------------------------------------------
    |
    | When utilizing the "file" session driver, the session files are placed
    | on disk. The default storage location is defined here; however, you
    | are free to provide another location where they should be stored.
    |
    */

    'files' => storage_path('framework/sessions'),

    /*
    |--------------------------------------------------------------------------
    | Session Database Connection
    |--------------------------------------------------------------------------
    |
    | When using the "database" or "redis" session drivers, you may specify a
    | connection that should be used to manage these sessions. This should
    | correspond to a connection in your database configuration options.
    |
    */

    'connection' => env('SESSION_CONNECTION'),

    /*
    |--------------------------------------------------------------------------
    | Session Database Table
    |--------------------------------------------------------------------------
    |
    | When using the "database" session driver, you may specify the table to
    | be used to store sessions. Of course, a sensible default is defined
    | for you; however, you're welcome to change this to another table.
    |
    */

    'table' => env('SESSION_TABLE', 'sessions'),

    /*
    |--------------------------------------------------------------------------
    | Session Cache Store
    |--------------------------------------------------------------------------
    |
    | When using one of the framework's cache driven session backends, you may
    | define the cache store which should be used to store the session data
    | between requests. This must match one of your defined cache stores.
    |
    | Affects: "dynamodb", "memcached", "redis"
    |
    */

    'store' => env('SESSION_STORE'),

    /*
    |--------------------------------------------------------------------------
    | Session Sweeping Lottery
    |--------------------------------------------------------------------------
    |
    | Some session drivers must manually sweep their storage location to get
    | rid of old sessions from storage. Here are the chances that it will
    | happen on a given request. By default, the odds are 2 out of 100.
    |
    */

    'lottery' => [2, 100],

    /*
    |--------------------------------------------------------------------------
    | Session Cookie Name
    |--------------------------------------------------------------------------
    |
    | Here you may change the name of the session cookie that is created by
    | the framework. Typically, you should not need to change this value
    | since doing so does not grant a meaningful security improvement.
    |
    */

    // 'cookie' => env(
    //     'SESSION_COOKIE',
    //     Str::slug((string) env('APP_NAME', 'laravel')).'-session'
    // ),
    'cookie' => 'laravel_session',

    /*
    |--------------------------------------------------------------------------
    | Session Cookie Path
    |--------------------------------------------------------------------------
    |
    | The session cookie path determines the path for which the cookie will
    | be regarded as available. Typically, this will be the root path of
    | your application, but you're free to change this when necessary.
    |
    */

    'path' => env('SESSION_PATH', '/'),

    /*
    |--------------------------------------------------------------------------
    | Session Cookie Domain
    |--------------------------------------------------------------------------
    |
    | This value determines the domain and subdomains the session cookie is
    | available to. By default, the cookie will be available to the root
    | domain and all subdomains. Typically, this shouldn't be changed.
    |
    */

    'domain' => env('SESSION_DOMAIN'),

    /*
    |--------------------------------------------------------------------------
    | HTTPS Only Cookies
    |--------------------------------------------------------------------------
    |
    | By setting this option to true, session cookies will only be sent back
    | to the server if the browser has a HTTPS connection. This will keep
    | the cookie from being sent to you when it can't be done securely.
    |
    */

    'secure' => env('SESSION_SECURE_COOKIE'),

    /*
    |--------------------------------------------------------------------------
    | HTTP Access Only
    |--------------------------------------------------------------------------
    |
    | Setting this value to true will prevent JavaScript from accessing the
    | value of the cookie and the cookie will only be accessible through
    | the HTTP protocol. It's unlikely you should disable this option.
    |
    */

    'http_only' => env('SESSION_HTTP_ONLY', true),

    /*
    |--------------------------------------------------------------------------
    | Same-Site Cookies
    |--------------------------------------------------------------------------
    |
    | This option determines how your cookies behave when cross-site requests
    | take place, and can be used to mitigate CSRF attacks. By default, we
    | will set this value to "lax" to permit secure cross-site requests.
    |
    | See: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#samesitesamesite-value
    |
    | Supported: "lax", "strict", "none", null
    |
    */

    'same_site' => env('SESSION_SAME_SITE', 'lax'),

    /*
    |--------------------------------------------------------------------------
    | Partitioned Cookies
    |--------------------------------------------------------------------------
    |
    | Setting this value to true will tie the cookie to the top-level site for
    | a cross-site context. Partitioned cookies are accepted by the browser
    | when flagged "secure" and the Same-Site attribute is set to "none".
    |
    */

    'partitioned' => env('SESSION_PARTITIONED_COOKIE', false),

];


------------------------------------------------------------
FILE: php_views.php
------------------------------------------------------------
<?php
/**
 * Laravel Views to Single File Converter
 * Usage: php convert_views.php /path/to/your/laravel/project
 */

class LaravelViewsConverter
{
    protected $outputFile = 'backend.txt';
    protected $excludedDirs = ['vendor', 'node_modules', 'storage', 'cache', 'resources','database','tests'];
    protected $allowedExtensions = ['.blade.php', '.php', '.html', '.css', '.js'];

    public function convert($projectPath)
    {
        $viewsPath = $projectPath . '/';
        
        if (!is_dir($viewsPath)) {
            echo "Error: Views directory not found at: $viewsPath\n";
            return false;
        }

        $output = "LARAVEL VIEWS CONVERSION\n";
        $output .= "Generated: " . date('Y-m-d H:i:s') . "\n";
        $output .= "Project: " . realpath($projectPath) . "\n";
        $output .= str_repeat("=", 80) . "\n\n";

        $this->processDirectory($viewsPath, $output, $viewsPath);

        file_put_contents($this->outputFile, $output);
        
        echo "Success! All views have been converted to: " . $this->outputFile . "\n";
        echo "Total file size: " . number_format(strlen($output)) . " bytes\n";
        
        return true;
    }

    protected function processDirectory($dir, &$output, $basePath)
    {
        $files = scandir($dir);
        
        foreach ($files as $file) {
            if ($file == '.' || $file == '..') continue;
            
            $fullPath = $dir . '/' . $file;
            $relativePath = str_replace($basePath . '/', '', $fullPath);
            
            // Skip excluded directories
            if (is_dir($fullPath)) {
                if (in_array($file, $this->excludedDirs)) continue;
                $this->processDirectory($fullPath, $output, $basePath);
                continue;
            }
            
            // Check file extension
            $includeFile = false;
            foreach ($this->allowedExtensions as $ext) {
                if (str_ends_with($file, $ext)) {
                    $includeFile = true;
                    break;
                }
            }
            
            if (!$includeFile) continue;
            
            // Add file to output
            $output .= "\n" . str_repeat("-", 60) . "\n";
            $output .= "FILE: " . $relativePath . "\n";
            $output .= str_repeat("-", 60) . "\n";
            
            $content = file_get_contents($fullPath);
            $output .= $content . "\n";
        }
    }
}

// CLI execution
if (php_sapi_name() === 'cli') {
    $projectPath = $argv[1] ?? getcwd();
    
    $converter = new LaravelViewsConverter();
    $converter->convert($projectPath);
}

------------------------------------------------------------
FILE: public/index.php
------------------------------------------------------------
<?php

use Illuminate\Foundation\Application;
use Illuminate\Http\Request;

define('LARAVEL_START', microtime(true));

// Determine if the application is in maintenance mode...
if (file_exists($maintenance = __DIR__.'/../storage/framework/maintenance.php')) {
    require $maintenance;
}

// Register the Composer autoloader...
require __DIR__.'/../vendor/autoload.php';

// Bootstrap Laravel and handle the request...
/** @var Application $app */
$app = require_once __DIR__.'/../bootstrap/app.php';

$app->handleRequest(Request::capture());


------------------------------------------------------------
FILE: routes/api.php
------------------------------------------------------------
<?php

// API Routes
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Route;
//Controller Imports
use App\Http\Controllers\AuthController;
use App\Http\Controllers\UserManagement;
use App\Http\Controllers\ApiAuthController;
use App\Http\Controllers\ProjectController;
use App\Http\Controllers\Admin\MasterProductsController;
use App\Http\Controllers\XeroController;
use App\Http\Controllers\SupplierController;
use App\Http\Controllers\OrderController;
use App\Http\Controllers\SupplierOrderController;
use App\Http\Controllers\Admin\OrderAdminController;
use App\Http\Controllers\Admin\DashboardController;
use App\Http\Controllers\PaymentController;
//Middleware Imports
use App\Http\Middleware\IsAdmin;
use App\Http\Middleware\IsSupplier;
use App\Http\Middleware\IsClient;


// Auth Routes - No middleware on login routes
Route::post('register/client', [ApiAuthController::class, 'registerClient']);
Route::post('register/supplier', [ApiAuthController::class, 'registerSupplier']);
Route::post('login', [ApiAuthController::class, 'login']);
Route::get('xero/callback', [ApiAuthController::class, 'xeroCallback']);
Route::prefix('xero')->group(function () {
    Route::get('/authorize', [XeroController::class, 'authorize']);  // Open in browser
    Route::get('/callback', [XeroController::class, 'callback']);
    Route::get('/status', [XeroController::class, 'status']);
    Route::post('/invoice', [XeroController::class, 'createInvoice']); // Use from Postman
});


//General Authenticated Routes
Route::middleware('auth:sanctum')->group(function () {
    Route::post('logout', [ApiAuthController::class, 'logout']);
    Route::get('user', [ApiAuthController::class, 'checkAuth']);

    // profile + password
    Route::post('profile', [ApiAuthController::class, 'updateProfile']);
    Route::post('change-password', [ApiAuthController::class, 'changePassword']);
    Route::get('categories', [UserManagement::class, 'listCategories']);


    

});


// Admin Routes - Only apply `isAdmin` middleware to these routes
Route::middleware(['auth:sanctum', IsAdmin::class])->group(function () {

    //Dashboard Api
    Route::get('/admin/dashboard/summary', [DashboardController::class, 'summary']);

    // User Management CRUD Operations
    Route::get('users', [UserManagement::class, 'index']);
    Route::post('users', [UserManagement::class, 'store']);
    Route::get('users/{id}', [UserManagement::class, 'show']);
    Route::post('users/{id}', [UserManagement::class, 'update']);
    Route::get('user-delete-restore/{id}', [UserManagement::class, 'destroy']);
    
    // Company Check
    Route::post('check-company', [UserManagement::class, 'checkCompany']);
    Route::get('companies', [UserManagement::class, 'getCompanies']);

    //MasterProduct CRUD Operations
    Route::get('master-products', [MasterProductsController::class, 'index']);
    Route::get('master-products/{id}', [MasterProductsController::class, 'show']);
    Route::post('master-products', [MasterProductsController::class, 'store']);
    Route::post('master-products/{id}', [MasterProductsController::class, 'update']);
    Route::delete('master-products/{id}', [MasterProductsController::class, 'destroy']);
    Route::get('approve-reject-master-product/{id}', [MasterProductsController::class, 'approveRejectMasterProduct']);
    Route::post('approve-reject-supplier-offer/{id}', [MasterProductsController::class, 'approveRejectSupplierOffer']);

    //category routes
    // Route::get('categories', [UserManagement::class, 'listCategories']);
    Route::post('categories', [UserManagement::class, 'addCategory']);
    Route::post('categories/{id}', [UserManagement::class, 'updateCategory']);
    Route::delete('categories/{id}', [UserManagement::class, 'deleteCategory']);
    Route::get('categories/{id}', [UserManagement::class, 'getCategory']);

    //SupplierWithZones
    Route::get('suppliers-with-zones', [UserManagement::class, 'getSuppliersWithDeliveryZones']);


    //order routes
    Route::get('admin/orders', [OrderAdminController::class, 'index']);
    Route::get('admin/orders/{order}', [OrderAdminController::class, 'show']);
    Route::post('admin/orders/{order}/items/{item}/quoted-price', [OrderAdminController::class, 'setItemQuotedPrice']);
    Route::post('admin/orders/{order}/admin-update', [OrderAdminController::class, 'adminUpdate']);
    Route::post('admin/orders/assign-supplier', [OrderAdminController::class, 'assignSupplier']);
    Route::post('admin/update-item-pricing/{orderItem}', [OrderAdminController::class, 'updateOrderPricingAdmin']);
    Route::post('admin/orders/{order}/items/{orderItem}/mark-paid', [OrderAdminController::class, 'supplierPaidStatus']);
    Route::post('admin/orders/update-order-status/{order}', [OrderAdminController::class, 'updateOrderStatus']);
    Route::post('admin/orders/payment-status/{order}', [OrderAdminController::class, 'updatePaymentStatus']);
    Route::delete('admin/delete-order/{order}', [OrderAdminController::class, 'archiveOrder']);

    //Get Archives 
    Route::get('admin/archives', [OrderAdminController::class, 'getArchive']);

});

//Supplier Routes - Only apply `isSupplier` middleware to these routes
Route::middleware(['auth:sanctum', IsSupplier::class])->group(function () {
    // Supplier Product Management
    Route::post('supplier-offers', [SupplierController::class, 'addProductToInventory']);
    Route::post('request-master-product', [SupplierController::class, 'requestNewProduct']);
    Route::get('supplier-products', [SupplierController::class, 'getSupplierProducts']);
    Route::post('update-pricing/{offerId}', [SupplierController::class, 'updateProductPricing']);
    Route::get('master-product-inventory', [SupplierController::class, 'getMasterProductInventory']);
    Route::delete('supplier-offers/{offerId}', [SupplierController::class, 'deleteProductFromInventory']);
    Route::get('supplier-offer-status', [SupplierController::class, 'getSupplierOfferStatus']);

    //Delivery Zones
    Route::post('delivery-zones', [SupplierController::class, 'deliveryZonesManagement']);
    Route::get('delivery-zones', [SupplierController::class, 'getDeliveryZones']);

    //Supplier Order Management
    Route::get('supplier-orders', [SupplierOrderController::class, 'getSupplierOrders']);
    Route::post('supplier-orders/update-pricing/{orderItem}', [SupplierOrderController::class, 'updateOrderPricing']);
    Route::get('supplier-orders/{order}', [SupplierOrderController::class, 'viewOrderDetails']);
});


//Client Routes - Only apply `isClient` middleware to these routes
Route::middleware(['auth:sanctum', IsClient::class])->group(function () {

    //payment routes
    Route::post('/payment-intent/{orderId}', [PaymentController::class, 'createPaymentIntent']);
    Route::post('/payment-intent/{orderId}', [PaymentController::class, 'createPaymentIntent']);
    Route::post('/process-payment', [PaymentController::class, 'processPayment']);

    // Project Management CRUD Operations
    Route::get('projects', [ProjectController::class, 'index']);
    Route::get('projects/{id}', [ProjectController::class, 'show']);
    Route::get('project-details/{id}', [ProjectController::class, 'projectDetails']);
    Route::post('projects', [ProjectController::class, 'store']);
    Route::post('projects/{project}', [ProjectController::class, 'update']);
    Route::delete('projects/{project}', [ProjectController::class, 'destroy']);


    // Order Management
    Route::post('orders', [OrderController::class, 'createOrder']);
    Route::get('my-orders', [OrderController::class, 'getMyOrders']);
    Route::get('orders/{order}', [OrderController::class, 'viewMyOrder']);
    Route::get('/mark-repeat-order/{order}', [OrderController::class, 'markRepeatOrder']);
    Route::post('repeat-order/{order}', [OrderController::class, 'repeatOrder']);
    Route::post('reorder-from-project', [OrderController::class, 'reorderFromProject']);
    Route::post('set-order-status/{order}', [OrderController::class, 'setOrderStatus']);
    Route::delete('orders/{order}', [OrderController::class, 'archiveOrder']);

    //Product listing and searching
    Route::get('client/products', [OrderController::class, 'getClientProducts']);
    Route::get('client/products/{id}', [OrderController::class, 'getClientProductDetails']);
});



Route::post('/register-admin', [AuthController::class, 'registerAdmin']);



// Route::middleware('auth:sanctum')->post('/payments/intents', [PaymentController::class,'createIntent']);
// Route::get('/payments/return', [PaymentController::class,'handleReturn']);

------------------------------------------------------------
FILE: routes/console.php
------------------------------------------------------------
<?php

use Illuminate\Foundation\Inspiring;
use Illuminate\Support\Facades\Artisan;

Artisan::command('inspire', function () {
    $this->comment(Inspiring::quote());
})->purpose('Display an inspiring quote');


------------------------------------------------------------
FILE: routes/web.php
------------------------------------------------------------
<?php
// routes/web.php

use App\Http\Controllers\AuthController;
use App\Http\Controllers\AdminController;
use Illuminate\Support\Facades\Route;
use App\Http\Controllers\Admin\MasterProductsController;
use Illuminate\Http\Request;

Route::get('/', function () {
    return view('welcome');
});

// Public routes - NO middleware
Route::middleware('guest')->group(function () {
    Route::get('/login', fn() => view('login'))->name('login');
    Route::get('/register', fn() => view('register'))->name('register');
    Route::post('/login-submit', [AuthController::class, 'login'])->name('login.submit');
    Route::post('/register-submit', [AuthController::class, 'register'])->name('register.submit');
});

// Protected routes - auth middleware only
Route::middleware('auth')->group(function () {
    Route::get('/dashboard', [AuthController::class, 'dashboard'])->name('dashboard');
    Route::get('/clients', [AdminController::class, 'clients'])->name('clients');
    Route::get('/clients/create', fn() => view('clients.create'))->name('client.create');
    Route::post('/client-add', [AdminController::class, 'addClient'])->name('client.add');
});

// Logout - no middleware
Route::get('/logout', [AuthController::class, 'logout'])->name('logout');

Route::get('/import-products', [MasterProductsController::class, 'importMasterProducts']);
Route::get('/import-offers', [MasterProductsController::class, 'importOffers']);
Route::get('/import-users', [MasterProductsController::class, 'importUsers']);
Route::get('/geocode-suppliers', [MasterProductsController::class, 'updateDeliveryZonesFromCSV']);
Route::get('/import-offers-with-products', [MasterProductsController::class, 'importOffersWithProducts']);

------------------------------------------------------------
FILE: vite.config.js
------------------------------------------------------------
import { defineConfig } from 'vite';
import laravel from 'laravel-vite-plugin';
import tailwindcss from '@tailwindcss/vite';

export default defineConfig({
    plugins: [
        laravel({
            input: ['resources/css/app.css', 'resources/js/app.js'],
            refresh: true,
        }),
        tailwindcss(),
    ],
});

